<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>汇编语言（王爽）ch1 | CodeSaw</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/css/highlight.css">
  
  <meta name="description" content="第一部分:硬件模型 Abstract 硬件基础  全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————冯诺依曼结构。 CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？">
<meta name="keywords" content="i386">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言（王爽）ch1">
<meta property="og:url" content="http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch1/index.html">
<meta property="og:site_name" content="CodeSaw">
<meta property="og:description" content="第一部分:硬件模型 Abstract 硬件基础  全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————冯诺依曼结构。 CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch1/3.png">
<meta property="og:updated_time" content="2020-06-26T02:30:19.084Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汇编语言（王爽）ch1">
<meta name="twitter:description" content="第一部分:硬件模型 Abstract 硬件基础  全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————冯诺依曼结构。 CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？">
<meta name="twitter:image" content="http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch1/3.png"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">CodeSaw</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-汇编语言（王爽）ch1" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      汇编语言（王爽）ch1
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2018-10-02T09:03:13.000Z" itemprop="datePublished">2018-10-02</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <h2 id="第一部分硬件模型">第一部分:硬件模型</h2>
<h3 id="abstract">Abstract</h3>
<h4 id="硬件基础">硬件基础</h4>
<blockquote>
<p>全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————<code>冯诺依曼结构</code>。<br>
CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？<br>
<a id="more"></a></p>
</blockquote>
<ul>
<li>存储单元的地址（地址）</li>
<li>读/写操作（控制）</li>
<li>读/写的具体数据（数据）</li>
</ul>
<blockquote>
<p>答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它<code>内存地址空间</code>。</p>
</blockquote>
<blockquote>
<p>以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构<code>《微机原理和接口》</code>，也不是讲整个计算机系统的结构和功能<code>《组成原理》</code>。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。 固有的硬件体系指的是这套<code>CPU+RAM</code>的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说<strong>不同的CPU有不同的汇编语言</strong>，用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。</p>
</blockquote>
<h4 id="指令和数据">指令和数据</h4>
<blockquote>
<p>学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。 从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是<code>从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算</code>。但是如果我把<code>data1</code>和<code>data2</code>互换一下，其实也是可以的。但是需要考虑到的是<code>data2</code>所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。</p>
</blockquote>
<h4 id="寄存器">寄存器</h4>
<blockquote>
<p>8086CPU有14个寄存器，都是16位的。但是这16位的寄存器也可以独立作为两个8位的寄存器使用。<br>
寄存器和内存是汇编程序猿眼中最直观的计算机样子。 ##### 汇编层面的CPU * 运算器进行信息处理 * 寄存器进行信息存储 * 控制器控制各种器件进行工作 * 内部总线连接各种器件，在它们之间进行数据的传送</p>
</blockquote>
<h5 id="架构16位机">8086架构（16位机）</h5>
<p>具体深究到物理实现就是《组成原理》知识了。<br>
* 运算器一次最多可以处理16位数据<br>
* 寄存器的最大宽度为16位<br>
* 寄存器和运算器之间的通路为16位</p>
<h5 id="汇编层面的内存">汇编层面的内存</h5>
<blockquote>
<p>CPU在访问内存单元的时候，需要知道内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存空间在这个空间上都有唯一的地址，这个惟一的地址就叫做<code>物理地址</code>。<br>
CPU首先在内部形成这个物理地址，然后通过地址总线送入存储器。这个地址一定是一个内存单元的物理地址。不同的CPU架构形成地址的方式不一样。</p>
</blockquote>
<h5 id="csip">CS:IP</h5>
<blockquote>
<p>前面提到了8086CPU内部需要形成物理地址，但是8086是16位机————只能处理和传输16位的地址，但是8086的地址总线有20位，所以需要两个16位来共同形成一个20位的地址。 14个寄存器中，CS是段寄存器，存放基地址。而IP存放偏移量。公式:<code>CSx16+IP</code>。<br>
首先需要明白的就是，一个内存单元是8位二进制也叫一个字节。而十六进制的一位可以表示成为二进制的4位。完全只是为了方便才写成16进制的。<strong>20位的地址（5位16进制）</strong>可以写成<code>4C780H</code>，后面的H表示16进制。<code>一个X进制的数据左移一位，相当于乘以X</code>。所以为了记起来方便一些可以记成<code>CS寄存器的数据左移一位+IP寄存器的值</code>。但是<strong>两个寄存器只有16位（4位16进制)</strong>，到后面计算的时候需要注意这两个前提，避免溢出。 书中特别强调了对<strong>段</strong>的理解。这里的段并不是指内存被物理上分成一段一段的。而是因为CPU在管理内存的时候，使用<code>CSx16+IP</code>的方式来进行管理。<strong>所以可以将地址连续，起始地址为16的倍数的一组内存单元看成是一个段。</strong>重点在于不是所有的起始地址都可以作为段地址————这是因为<code>CSx16</code>决定的。而且因为<code>IP</code>是16位的所以每一个段的长度最大为<code>64KB</code>。</p>
</blockquote>
<h5 id="执行过程">执行过程</h5>
<blockquote>
<p><strong>在8086机中，任意时刻CPU将CS:IP指向的内容当做指令执行。</strong>汇编中使用<code>jmp 段地址:偏移地址</code>对CS:IP进行修改。或者使用<code>jmp 寄存器</code>来修改IP的值。<br>
###### 8086的工作过程 * 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓存器。 * IP指向下一条指令。 * 执行指令,从CS:IP中取指令，重复上面的过程。</p>
</blockquote>
<h3 id="书中划线">书中划线</h3>
<ul>
<li>汇编语言和机器语言的差别在于指令的表示方法上。</li>
<li>微机存储器的容量是以<strong>字节</strong>为最小单位的来计算的。</li>
<li>在内存和磁盘上，数据和指令没有任何区别。</li>
<li>在汇编语言这门课中，我们所面对的是<strong>内存地址空间</strong>。CPU向这段地址中读写数据实际上就是向相应的物理存储器中读写数据。</li>
<li>内存地址空间的大小受到CPU地址总线宽度的限制。</li>
</ul>
<h3 id="实验1-查看cpu和内存用机器指令和汇编指令编程">实验1 查看CPU和内存，用机器指令和汇编指令编程</h3>
<h4 id="工具介绍">工具介绍</h4>
<blockquote>
<p>debug是DOS,Windows都提供的实模式（8086方式）程序的调试工具。下面是本次实验将会用到的参数:<br>
##### r (读写寄存器) * <code>r</code>查看所有的寄存器的值 * <code>r 寄存器名称</code>修改制定寄存器的值</p>
</blockquote>
<h5 id="d-读写内存">d （读写内存）</h5>
<ul>
<li><code>d 段地址:偏移地址</code> 列出从指定内存单元开始的128个内存单元的内容</li>
<li><code>d 段地址:起始偏移地址 结尾偏移地址</code>列出在偏移地址范围之内的内存单元的内容</li>
</ul>
<h5 id="e-读写内存">e （读写内存）</h5>
<ul>
<li><code>e 段地址:偏移地址  data1  data2 data3……</code>从特定单元开始讲数据写入内存</li>
<li><code>e 段地址:偏移地址 回车</code>表示挨个儿修改内存，空格表示默认不修改，回车表示修改结束</li>
</ul>
<h5 id="eut">e+u+t</h5>
<ul>
<li>使用<code>e</code>参数向内存中写入机器码</li>
<li>使用<code>u 段地址:偏移地址</code>可以将内存中机器码翻译成为汇编语言</li>
<li><code>t</code>参数执行<code>CS:IP</code>指向的内存地址单元的任何指令，注意修改参数</li>
</ul>
<h5 id="a">a</h5>
<ul>
<li><code>a 段地址:偏移地址</code>可以直接使用汇编的格式写入机器指令</li>
</ul>
<h4 id="实验任务">实验任务</h4>
<blockquote>
<p>一共有4个实验。写出来的都是我觉得很有意思且值得讨论的实验。</p>
</blockquote>
<h5 id="第二个实验">第二个实验</h5>
<blockquote>
<p>给出起始地址为<code>2000:0000</code>的三条指令，使用这三条指令计算2的8次方。</p>
</blockquote>
<pre><code>&lt;img src=&quot;2.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;&quot;&gt;</code></pre>
<blockquote>
<p>有意思的是这个算法，a += a；如果这里的a是2的话，实际上<code>a+a</code>等于<code>ax2</code>所以可以2的8次方可以通过8次这样的加法完成，但是如果a是其他的值就不行了。</p>
</blockquote>
<h5 id="最后两个实验">最后两个实验</h5>
<blockquote>
<p>使用<code>e</code>参数对特定的内存单元进行读写。 <img src="3.png" width="50%" height="50%" alt=""></p>
</blockquote>
<blockquote>
<p>这两个实验间接地证明了<strong>内存地址空间</strong>的存在。<br>
我在向内存<code>B810:0000</code>中写数据的时候，发现显示器上会出现有颜色的字符和表情包，猜想这个地址应该是显存的物理地址。这也说明这里的内存不仅仅指的是主存储器，还有其他的和CPU直接相连的RAM。</p>
</blockquote>
<p>​</p>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/Assembly/">Assembly</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-link" href="/tags/i386/">i386</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2018/10/04/汇编语言（王爽）ch2/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          汇编语言（王爽）ch2
        
      </div>
    </a>
  
  
    <a href="/2018/10/02/汇编语言（王爽）ch0/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          汇编语言（王爽）ch0
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->

</body>
</html>
