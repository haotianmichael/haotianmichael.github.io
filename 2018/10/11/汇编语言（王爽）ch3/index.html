<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>汇编语言（王爽）ch3 | CodeSaw</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/css/highlight.css">
  
  <meta name="description" content="第三部分:指令核心 Abstract 内存寻址  内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，注意这里的内存指的是内存地址空间。 CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。">
<meta name="keywords" content="i386">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言（王爽）ch3">
<meta property="og:url" content="http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/index.html">
<meta property="og:site_name" content="CodeSaw">
<meta property="og:description" content="第三部分:指令核心 Abstract 内存寻址  内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，注意这里的内存指的是内存地址空间。 CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/113.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/7.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/13.png">
<meta property="og:updated_time" content="2020-06-26T02:29:54.925Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汇编语言（王爽）ch3">
<meta name="twitter:description" content="第三部分:指令核心 Abstract 内存寻址  内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，注意这里的内存指的是内存地址空间。 CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。">
<meta name="twitter:image" content="http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/113.png"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">CodeSaw</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-汇编语言（王爽）ch3" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      汇编语言（王爽）ch3
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2018-10-10T21:29:35.000Z" itemprop="datePublished">2018-10-10</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <h2 id="第三部分指令核心">第三部分:指令核心</h2>
<h3 id="abstract">Abstract</h3>
<h4 id="内存寻址">内存寻址</h4>
<blockquote>
<p>内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，<strong>注意这里的内存指的是内存地址空间</strong>。<br>
CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。<br>
<a id="more"></a> 寻址的方式有很多种类 ，不过归结到底都是<code>段地址+偏移地址</code>。段地址存储在段寄存器中，而偏移地址的方式就有很多种。见下图:<br>
<img src="113.png" width="50%" height="50%" alt=""></p>
</blockquote>
<blockquote>
<p>需要注意的是: * 上图中的<code>idata</code>表示立即数，<code>[]</code>表示偏移地址。<code>(ax)</code>表示寄存器ax的内容。 * <code>[]</code>中的除了立即数之外，只有<code>bx</code>,<code>si</code>,<code>di</code>和<code>bp</code>四个寄存器可以进行寻址，其他的寄存器不行。 * <code>[bp]</code>的段寄存器默认是<code>ss</code>。 * 编译器masm和调试器debug两个工具对于<code>mov ax,[idata]</code>中的<code>idata</code>处理不同，编译器会将其识别为<code>idata</code>,所以在使用编译器的时候这种形式应该写成<code>mov ax,ds:[idata]</code></p>
</blockquote>
<h4 id="数据处理总结性质">数据处理(总结性质)</h4>
<blockquote>
<p>计算机处理的最终还是数据，那么就有两个最基本的问题: * 处理的数据在什么地方？ * 要处理的数据有多长？ ##### 问题一 绝大部分机器指令都是进行数据处理的指令，处理大致分为三类:读取，写入，运算。在机器指令这一层来说并不关心数据的值，而关心<strong>指令执行前一秒，将要处理的数据所在的位置</strong>。指令在执行之前，所要处理的数据可以在三个地方:CPU内部，寄存器，端口。 ##### 问题二<br>
8086指令可以处理两种尺寸的数据:Byte和Word。所以在机器指令中需要指明是字操作和字节操作。<br>
* 通过寄存器指明:<code>ax</code>，<code>al</code>等 * 用操作符<code>X ptr</code>指明内存单元的长度，<code>X</code>是<code>word</code>或者<code>byte</code>。比如:<code>mov byte ptr ds:[0],1</code>。 * 还有一些默认的操作比如栈操作默认为字操作。</p>
</blockquote>
<h4 id="指令详解">指令详解</h4>
<h5 id="伪指令补充">伪指令补充</h5>
<ul>
<li><code>db</code> 定义字节型数据</li>
<li><code>dw</code> 定义字型数据</li>
<li><code>dd</code> 定义双字节型数据</li>
<li><code>dup</code> 和前面三个伪指令结合使用，用来进行数据的重复。<code>db 3 dup(1,2,3)</code>表示定义的三个字节型数据分别为1,2,3。</li>
</ul>
<h5 id="loop循环指令">LOOP循环指令</h5>
<blockquote>
<p>主要进行两步操作，（cx）=(cx)-1，判断cx中的值。不为零则转至标号处执行程序，如果为零则向下执行。可见<code>cx</code>中的值影响了loop指令的执行结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">	循环执行的程序段</span><br><span class="line">	loop s</span><br></pre></td></tr></table></figure>
<h5 id="jmp转移指令">JMP转移指令</h5>
<blockquote>
<p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的的指令。<br>
根据修改的方式，只修改IP的称为<code>段内转移</code>，修改IP和CS的称为<code>段间转移</code>。由于转移指令对IP的修改范围不同，段内转移又分为:<code>短转移（8位）</code>和<code>近转移（16位）</code>。不同的转移方式，其基本的原理确实相同的。<br>
###### 1-JMP short offset 转移指令值得注意的点就是offset指的不是确定的地址，而是从标号到指令之间的位移。<br>
<code>(IP)=(IP)+8位位移</code>，段内短转移的位移范围位8位有符号数，用补码表示。<code>offset处的地址-JMP指令后的第一个字节的地址</code>。 ###### 1-JMP near ptr offset <code>(IP)=(IP)+16位位移</code> ,段内近转移的位移范围是16位有符号数，用补码表示。原理和前者一样。 ###### 2-JMP far ptr offset 前面的几种类型地址都是通过offset和位移，而接下来的几种是在寄存器和内存中的给定IP或者CS。<strong>内存地址单元可以用任意的寻址方式得到。</strong><br>
<code>（CS）=标号所在段的段地址</code>，<code>（IP）=标号所在段中的偏移地址</code> 。段间转移，会发现其跳转地址实际上是在指令中的offset的地址。和前两个还是有区别的。 ###### 2-JMP 16位reg 最基础的跳转指令，只是修改IP=16位的寄存器中内容。 ###### 2-JMP word ptr 内存单元地址 比如:<code>jmp word ptr ds:[0]</code>中<code>ptr</code>后面的就是一个地址，<code>jmp word ds:[0],0</code>后面跟两个地址。注意<strong>（CS）=(内存地址单元+2)，（IP）=（内存地址单元）</strong>。 ###### 2-jcxz 该指令为有条件转移指令，<strong>所有的有条件转移指令都是短转移</strong>。方式为:<br>
<code>if((cx)==0)jmp short offset</code><br>
另外，所有的<code>loop</code>循环指令都是短转移。</p>
</blockquote>
<h5 id="call和ret指令">CALL和RET指令</h5>
<h6 id="ret近转移">ret(近转移)</h6>
<blockquote>
<p>书中说<strong>ret指令用栈中的数据修改IP中的内容</strong>。之前对栈有一个分类，这里的栈是<strong>满递减堆栈</strong>。所以由此可知堆栈指针<code>SP</code>一直指向最后一个压栈的数据。<code>ret</code>指令实际上把堆栈中的最后一个数据作为自己跳转的偏移地址。方式如下:<br>
<code>(IP)=((ss)*16+(sp))</code>,<code>(sp)=(sp)+2</code><br>
从上面也可以看出来这两条指令等同于:<code>pop IP</code></p>
</blockquote>
<h6 id="retf远转移">retf(远转移)</h6>
<blockquote>
<p>书中说<strong>retf指令用栈中的数据修改IP和CS中的内容</strong>。类似:<br>
<code>(IP)=((ss)*16+(sp))</code>,<code>(sp)=(sp)+2</code><br>
<code>（CS）=（（ss）*16+(sp)）</code>,<code>(sp)=(sp)+2</code><br>
这四条指令等同于:<code>pop IP</code>,<code>pop CS</code></p>
</blockquote>
<h6 id="call指令">call指令</h6>
<blockquote>
<p>call指令不能实现短转移，但是其转移的原理和jmp指令相同。如下：<br>
<code>(sp)=(sp)-2</code>,<code>((ss)*16+(sp))=(IP)</code>,<code>(IP)=(IP)+16位位移</code>这几条指令相当于:<br>
<code>push IP</code>和<code>jmp near ptr offset</code></p>
</blockquote>
<h6 id="call和ret指令子程序">call和ret指令(子程序)</h6>
<blockquote>
<p>先看一段代码:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,1</span><br><span class="line">	   mov cx,3</span><br><span class="line">	   call s</span><br><span class="line">	   mov bx,ax</span><br><span class="line">	   mov ax,4c00h</span><br><span class="line">	   int 21h</span><br><span class="line">	s: add ax,ax</span><br><span class="line">	   loop s</span><br><span class="line">	   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序执行到<code>call s</code>的时候，IP指向了后面的一条指令，然后CPU执行<code>call s</code>指令————<code>将当前的IP（mov bx,ax的地址）压栈，然后修改为s地址</code>。然后子程序开始执行，执行结束之后执行<code>ret</code>指令————<code>从栈中弹出一个值，将CS:IP的值指向mov bx,ax</code>。然后返回为原来的地址。这两条指令为子程序的调用提供了可能。</p>
</blockquote>
<h4 id="标志寄存器">标志寄存器</h4>
<blockquote>
<p>寄存器是汇编程序员解决问题的最有利的手段，不仅仅在于可以存储数据，还具有辅助指令执行的功能。标志寄存器就是如此，<strong>用来存储CPU执行指令的某些执行结果。</strong>存储的信息称为“程序状态字PSW”。状态寄存器的每一位都有具体的含义。下面分别介绍:<br>
##### ZF标志 零标志位，相关指令执行结束如果结果为0，zf=1；如果不为0，zf=0.</p>
</blockquote>
<h5 id="pf标志">PF标志</h5>
<blockquote>
<p>奇偶标志位，相关指令执行结束如果结果的所有bit位中1的个数为偶数，pf=1,否则pf=0.</p>
</blockquote>
<h5 id="sf标志">SF标志</h5>
<blockquote>
<p>符号标志位，相关指令执行结束如果结果为负，sf=1；否则sf=0。<strong>该标志是CPU对有符号数计算结果的一种记录。</strong></p>
</blockquote>
<h5 id="cf标志">CF标志</h5>
<blockquote>
<p>进位标志位，在进行<strong>无符号</strong>数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p>
</blockquote>
<h5 id="of标志">OF标志</h5>
<blockquote>
<p>溢出标志位，在进行<strong>有符号</strong>数运算的时候，记录了是否发生溢出。</p>
</blockquote>
<h5 id="标志寄存器在debug中的使用">标志寄存器在Debug中的使用</h5>
<blockquote>
<p>标志寄存器是按照有意义的各个标志位单独表示的。如下。 <img src="7.png" width="50%" height="50%" alt=""> 下图是已知的标志位的表示:<br>
<img src="13.png" width="50%" height="50%" alt=""> #### 其他指令（总结性质） 还有很多的指令比如<code>MOV</code>,<code>CMP</code>，<code>abc</code>等。但这里并不打算详细讲解每一条指令，就像书中所说:<strong>汇编语言只是载体，目的在于理解机器运行的原理和方式。</strong><br>
至此，我们已经学习了<code>寄存器</code>，<code>内存</code>,<code>汇编指令</code>，并且掌握了一个<strong>正常的程序控制流</strong>在机器层面的运行过程。接下来的内容，就属于操作系统的层面，引入<strong>异常控制流</strong>，也就是在正常的执行过程中有外界干扰的情况，这是理解整个OS的重点，也是我写这几篇技术博客的主要学习目的。(<code>mit6.828</code>中的汇编大同小异，只是指令集换成了AT&amp;T的格式)。</p>
</blockquote>
<h3 id="实验7-寻址方式在结构化数据访问中的应用">实验7 寻址方式在结构化数据访问中的应用</h3>
<h3 id="实验9-根据材料编程">实验9 根据材料编程</h3>
<h3 id="实验10-编写子程序">实验10 编写子程序</h3>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/Assembly/">Assembly</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-link" href="/tags/i386/">i386</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2018/10/12/汇编语言（王爽）ch4/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          汇编语言（王爽）ch4
        
      </div>
    </a>
  
  
    <a href="/2018/10/04/汇编语言（王爽）ch2/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          汇编语言（王爽）ch2
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->

</body>
</html>
