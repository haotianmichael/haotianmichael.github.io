<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mit6.828(Fall 2018) Lab0 | CodeSaw</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/css/highlight.css">
  
  <meta name="description" content="Lab0 Abstract  从8086汇编实验之后，前后两周的时间勉强通过Lab1。 最大的感触是基础太差:对C语言的理解，对程序编译链接本质的理解，对GDB等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。 但是这次触动中却又多了一丝见山不是山，见山又是山的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如printf函数的实现就涉及C语言中变参的特性。">
<meta name="keywords" content="MIT 6.828,OS,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Mit6.828(Fall 2018) Lab0">
<meta property="og:url" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/index.html">
<meta property="og:site_name" content="CodeSaw">
<meta property="og:description" content="Lab0 Abstract  从8086汇编实验之后，前后两周的时间勉强通过Lab1。 最大的感触是基础太差:对C语言的理解，对程序编译链接本质的理解，对GDB等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。 但是这次触动中却又多了一丝见山不是山，见山又是山的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如printf函数的实现就涉及C语言中变参的特性。">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/3.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/4.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/5.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/1.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/2.png">
<meta property="og:updated_time" content="2020-06-26T02:31:46.798Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mit6.828(Fall 2018) Lab0">
<meta name="twitter:description" content="Lab0 Abstract  从8086汇编实验之后，前后两周的时间勉强通过Lab1。 最大的感触是基础太差:对C语言的理解，对程序编译链接本质的理解，对GDB等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。 但是这次触动中却又多了一丝见山不是山，见山又是山的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如printf函数的实现就涉及C语言中变参的特性。">
<meta name="twitter:image" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/3.png"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">CodeSaw</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-Mit6-828-Fall-2018-Lab0" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      Mit6.828(Fall 2018) Lab0
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2018-11-04T16:35:45.000Z" itemprop="datePublished">2018-11-04</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <h2 id="lab0">Lab0</h2>
<h3 id="abstract">Abstract</h3>
<blockquote>
<p>从<code>8086汇编</code>实验之后，前后两周的时间勉强通过Lab1。<br>
最大的感触是<strong>基础太差</strong>:对C语言的理解，对程序编译链接本质的理解，对<code>GDB</code>等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。 但是这次触动中却又多了一丝<code>见山不是山，见山又是山</code>的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如<code>printf</code>函数的实现就涉及C语言中变参的特性。有理由相信这种<strong>血浓于水</strong>的关系在后续的Lab中还会进一步加强，所以我也希望这会是我学习OS最完美的方法论——————<strong>Talk is cheap, show me the code.</strong>。 截止到Lab1，整个学习的过程显得很清晰————就是<strong>通过调试<code>kernel</code>的反汇编代码来理解运行原理并加以修改</strong>。Lab0是我在实验过程中掉进的坑，查阅的资料和逐渐点亮的技能树，缩短实验前的准备时间对理解OS本身还是很有帮助的。 <a id="more"></a></p>
</blockquote>
<h3 id="实验环境的搭建">6.828实验环境的搭建</h3>
<ul>
<li>虚拟机环境: Ubuntu14.4 (<strong>32位</strong>)</li>
<li>仿真器: Qemu <code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li>
<li>实验代码: Lab <code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code> &gt; 虚拟机环境<code>32位</code>，因为<code>JOS</code>就是32位的操作系统。<br>
&gt; 仿真器使用MIT进行patched过的(见上链接)。原因是实验中分页机制是有意修改过的，使用<code>patched version</code>的话在后面<code>Exercise</code>中不需要手动转换地址。<br>
&gt; 关于实验代码，默认熟悉<code>Git</code>和<code>MakeFile</code>。每做完一个<code>Exercise</code>可以使用<code>make grade</code>进行测试。<br>
&gt; 在整个实验环境搭建的过程中，可能会因为虚拟机发型版本的不同而出现不同的链接库丢失，Google一下。详细的搭建过程见<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#" target="_blank" rel="noopener">Tools Guide</a></li>
</ul>
<h3 id="关于6.828">关于6.828</h3>
<blockquote>
<p>MIT的OS课程。学习共有三条主线:<code>Lectures</code>,<code>Readings</code>,<code>Labs</code>。<br>
当然最重要的就是<code>Labs</code>。关于剩余的两部分，主要围绕一个叫做<code>xv6</code>的小型OS展开的。简单来讲，这是一个<strong>麻雀虽小五脏俱全</strong>的OS。有<code>Documents</code>和<code>Source Code</code>两份资料。知乎上评价很高，有人将其翻译成为中文版本上传至Github.<a href="https://github.com/ranxian/xv6-chinese" target="_blank" rel="noopener">XV6_Ch</a>，传说看懂源码之后可以超神……<br>
做<code>Lab</code>的过程中，课程会提供大量的Readings来阅读，当然都是英文的。详细见<a href="https://pdos.lcs.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">Reference</a>。</p>
</blockquote>
<h3 id="汇编和内联汇编">80386汇编和内联汇编</h3>
<h4 id="att-80386">AT&amp;T-80386</h4>
<blockquote>
<p>在之前的汇编实验中，我们学习了16位的<code>Intel-8086</code>汇编。而在32位机器上需要使用32位的<code>80386</code>汇编语言。虽然对于<code>Linux</code>来说，<code>8086</code>和<code>80386</code>的机器是有很大的差别的，主要体现在实模式和保护模式上。但是就语言本身而言，更多的是递进的关系而语法差别并不大。目前还没有遇到保护模式相关的障碍。<br>
<code>x86</code>的汇编主要有两种格式:<code>Intel</code>和<code>AT&amp;T</code>。<code>6.828</code>使用的是<code>AT&amp;T</code>,而实际上Linux中的汇编也是后者居多。<strong>汇编语言本身主要有指令集<code>Instruction Set</code>和伪指令<code>Directives</code>两大部分内容</strong>。当然最全的文献是Intel自家的Documents，不过我觉得有些太杂和多了。下面的的资料在实验过程中帮了我很多。值得细看。</p>
</blockquote>
<ul>
<li>MIT----<a href="https://pdos.lcs.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">pcasm-book</a>。</li>
<li>Wikipedia----<a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Added_with_80386" target="_blank" rel="noopener">x86 Instruction Set</a></li>
<li>Oracle----<a href="https://docs.oracle.com/cd/E26502_01/html/E28388/eoiyg.html" target="_blank" rel="noopener">x86 Assembler Directives</a></li>
</ul>
<h4 id="内联汇编">内联汇编</h4>
<blockquote>
<p>因为操作系统本身就是和硬件打交道最频繁的系统软件，有些地方需要使用到汇编来简单粗暴的完成工作。<strong>内联汇编</strong>就是嵌入在C语言中的汇编语言，格式和原来的有很大的不同。不过IBM的那份资料可以解决一大半问题，也是难得的中文文档……</p>
</blockquote>
<ul>
<li>MIT----<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">Brennan's Guide to Inline Assembly</a></li>
<li>IBM----<a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html" target="_blank" rel="noopener">汇编语言开发指南</a></li>
</ul>
<h3 id="elf文件">ELF文件</h3>
<blockquote>
<p>实名Diss网上各种对ELF的讲解，故意弄混<code>section</code>和<code>segment</code>的概念。加上对二进制工具使用的不熟练，让我一度以为链接的难度系数是整个实验过程中最高的……直到我看到<code>CSAPP</code>中关于链接部分的讲解。</p>
</blockquote>
<h4 id="编译驱动程序">编译驱动程序</h4>
<blockquote>
<p><code>Compiler driver</code>指的是从C文件变成二进制文件的机器操作过程。我们从两个角度理解这个过程:<strong>机器运行的角度和C文件类型变化的角度</strong>。编译器和汇编器将多个<code>C</code>文件编译成相应的多个<strong>可重定位目标文件</strong>，也就是平时的<code>.o</code>文件，这种文件由不同的代码节和数据节构成，<strong>节</strong>在原文中是<code>section</code>。而链接器将多个<code>.o</code>文件链接成为一个<strong>可执行目标文件</strong>也就是平时的二进制文件。见下图:</p>
</blockquote>
<p><img src="3.png" width="50%" height="50%" alt=""></p>
<blockquote>
<p>熟悉一个程序的第一步是关注其输入输出。一句话总结链接器的功能:<strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</strong> 站在机器的角度，编译器和汇编器将ASCII格式的C文件编译成为字节块<strong>section</strong>的集合，而链接器做的就是将<strong>不同</strong>可重定位目标文件中的各种<code>sections</code>做归类，<strong>确定被链接块的运行时的内存位置</strong>。这是重点，目标文件纯粹是字节块的集合，而链接器本身对程序也所知甚少，她做的仅仅是对<strong>字节文件</strong>做处理，将多个文件的字节块放到了一个文件中。</p>
</blockquote>
<h4 id="链接过程">链接过程</h4>
<blockquote>
<p>链接器做两件事: * 符号解析: 输入文件的符号引用都对应到其定义上。 * 重定位: 编译器和汇编器生成的文件地址都是从0开始的，并没有和内存挂上关系。而链接器将这些不同的<code>section</code>定位到内存中的一个地址。也就是其加载地址。 重点关注第二步重定位，本质上就是将多个可重定位文件中同类型的<code>.section</code>合并为一个大的聚合节。但是注意这时候还没有<code>segment</code>的概念,聚合节还是叫做<code>.section</code>。我查阅了<code>CSAPP</code>的英文版，全书第一次提到<code>segment</code> 是在链接器部分的最末尾，也就是讲重定位的时候。下面是原文:</p>
</blockquote>
<p><img src="4.png" width="50%" height="50%" alt=""></p>
<blockquote>
<p>明显看到<code>segment</code>还是内存的概念而非可执行文件中的部分。所以从头到尾链接过程都没有生成过<code>segment</code>这样一种东西，其只是多个<code>sections</code>对应于内存中的<strong>映射</strong>。全书对链接部分的讲解也很少提及<code>segment</code>，<strong>所以我们对链接的理解最小单位应该是<code>section</code>，链接过程就是对<code>section</code>进行操作;而最后重定位的时候将多个大的<code>section</code>映射到一段内存中，映射的单位才是<code>segment</code></strong>。现在看下图就很清楚了:</p>
</blockquote>
<p><img src="5.png" width="50%" height="50%" alt=""></p>
<blockquote>
<p>从文件类型的角度来看: 目前我们谈到的ELF文件有可重定位目标文件和可执行目标文件。可以使用二进制工具ELF文件进行分析。关于链接更本质的过程还是很复杂的，Lab1后面会有一部分和<strong>符号表</strong>相关的实验，建议先详细看看<code>CSAPP</code>和下面提供的资料。 * MIT----<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf" target="_blank" rel="noopener">The definitive standard for the ELF format</a> * Wikipedia----<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a> * ELF中文文档----<a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf" target="_blank" rel="noopener">ELF.Ch</a> ### 二进制分析工具 6.828中主要使用<code>objdump</code>，基本工具可以通过<code>man</code>来查看用法，这里列出几个最常见的参数。</p>
</blockquote>
<h4 id="objdump">Objdump</h4>
<blockquote>
<p>对目标文件进行分析，在Linux平台上有三种<code>object file</code>:<code>Relocatable object File</code>,<code>Executable object File</code>,<code>Shared object File</code>，一直没搞懂为啥都叫<code>object File</code>。不过因为这三种目标文件对应于链接的不同阶段，所以对于链接过程本质的理解直接影响这里使用这个二进制分析工具。</p>
</blockquote>
<ul>
<li><code>-f</code> Display file headers</li>
<li><code>-d</code> Disassembly</li>
<li><code>-h</code> Section headers</li>
<li><code>-x</code> All headers</li>
<li><code>-S</code> Display source code</li>
</ul>
<h4 id="nm">Nm</h4>
<blockquote>
<p>列出目标文件中的符号表内容，应该和重定位关系密切。</p>
</blockquote>
<h3 id="阅读源码cli工具">阅读源码CLI工具</h3>
<blockquote>
<p>虽然我是<a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a>党，但是不得不承认VIM在进行文本操作的时候还是更<strong>方便:)</strong>一些。</p>
</blockquote>
<h4 id="vim-ctags">VIM-Ctags</h4>
<blockquote>
<p>这个就很强大了，用于在<code>tags</code>文件所在的根目录下寻找函数声明和宏定义，在阅读源码的时候基本上不知道的定义和关键字都可以使用<code>Ctags</code>来进行定位，非常实用。<br>
安装成功之后，在工程目录下面执行命令<code>ctags -R *</code>对当前目录递归建立索引，会生成<code>tags</code>文件。在源码中遇到未见过的函数便将光标放在其上<code>Ctrl - }</code>即可跳转到其声明的位置。<code>Ctrl - o</code>自动返回。</p>
</blockquote>
<h4 id="vim_taglist">VIM_TagList</h4>
<blockquote>
<p>这个实际上没怎么用，功能是在VIM中打开目录树，便于程序员操作。可以先留下来，进一步观察。</p>
</blockquote>
<h4 id="tmux">Tmux</h4>
<blockquote>
<p>这又是一个神器，终端分屏功能强大，有<code>window</code>,<code>pannel</code>等概念。和<code>on-my-zsh</code>配合使用简直了。不愿意折腾的话也可以在<code>bash</code>下直接使用。我们在<code>GDB</code>调试OS的时候使用她作为分屏工具，需要在家目录下加入配置文件<code>~/.tmux.conf</code>。<br>
<img src="1.png" width="50%" height="50%" alt=""></p>
</blockquote>
<h4 id="vimgrep">VimGrep</h4>
<blockquote>
<p>用于在指定目录下进行全局搜索并在另一个窗口打开;关键字<code>sample</code>;在vim命令模式下执行命令； * :<code>vim/sample/% | copen</code> 当前文件搜索 * :<code>vim/sample/* | copen</code> 当前目录搜索 * :<code>vim/sample/ ../** | copen</code> 从上一级目录开始递归搜索 * :<code>vim/sample path1/**  path2/** | copen</code> 多路径搜索 * : <code>cclose</code> 关闭当前搜索<br>
<img src="2.png" width="50%" height="50%" alt=""></p>
</blockquote>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/C/">C</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-link" href="/tags/Linux/">Linux</a>, <a class="article-tag-link" href="/tags/MIT-6-828/">MIT 6.828</a>, <a class="article-tag-link" href="/tags/OS/">OS</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2018/11/05/Mit6-828-Fall2018-Lab1/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Mit6.828(Fall 2018) Lab1
        
      </div>
    </a>
  
  
    <a href="/2018/10/16/汇编语言（王爽）ch5/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          汇编语言（王爽）ch5
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->

</body>
</html>
