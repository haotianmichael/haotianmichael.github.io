<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "5d4a5755"
    });
  daovoice('update');
  </script>















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Assembly,MIT 6.828,OS,C,Linux," />





  <link rel="alternate" href="/atom.xml" title="CodeSaw" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Lab1Before Lab Lab1一共有三部分:Bootstrap,BootLoader,Kernel;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分monitor中test_backtrace的功能。如果GDB调试出错，可能是因为调试器没有链接到操作系统上：123add add-auto-load-safe-path /Your Working Dir">
<meta name="keywords" content="Assembly,MIT 6.828,OS,C,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Mit6.828(Fall 2018) Lab1">
<meta property="og:url" content="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/index.html">
<meta property="og:site_name" content="CodeSaw">
<meta property="og:description" content="Lab1Before Lab Lab1一共有三部分:Bootstrap,BootLoader,Kernel;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分monitor中test_backtrace的功能。如果GDB调试出错，可能是因为调试器没有链接到操作系统上：123add add-auto-load-safe-path /Your Working Dir">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/6.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/7.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/9.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/14.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/13.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/15.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/22.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/16.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/17.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/19.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/20.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/21.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/23.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/24.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/25.png">
<meta property="og:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/26.png">
<meta property="og:updated_time" content="2018-11-18T15:21:09.387Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mit6.828(Fall 2018) Lab1">
<meta name="twitter:description" content="Lab1Before Lab Lab1一共有三部分:Bootstrap,BootLoader,Kernel;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分monitor中test_backtrace的功能。如果GDB调试出错，可能是因为调试器没有链接到操作系统上：123add add-auto-load-safe-path /Your Working Dir">
<meta name="twitter:image" content="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/6.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/"/>






  <title>Mit6.828(Fall 2018) Lab1 | CodeSaw</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <a href="https://github.com/haotianmichael" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CodeSaw</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Talk is cheap, show me the Code.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HaotianMichael">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CodeSaw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Mit6.828(Fall 2018) Lab1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-04T21:31:02Z">
                2018-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article</span>
                
                <span title="Words count in article">
                  7.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time</span>
                
                <span title="Reading time">
                  28
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><h3 id="Before-Lab"><a href="#Before-Lab" class="headerlink" title="Before Lab"></a>Before Lab</h3><blockquote>
<p>Lab1一共有三部分:<code>Bootstrap</code>,<code>BootLoader</code>,<code>Kernel</code>;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分<code>monitor</code>中<strong>test_backtrace</strong>的功能。<br>如果<code>GDB</code>调试出错，可能是因为调试器没有链接到操作系统上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add </span><br><span class="line">add-auto-load-safe-path /Your Working Dir/.gdbinit</span><br><span class="line">line to your configuration file &quot;/root/.gdbinit&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<a id="more"></a>
<h3 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h3><h4 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h4><h5 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h5><blockquote>
<p>JOS中使用AT&amp;T格式的汇编语言，在Lab0中介绍了相关资料。实验要求熟悉<strong>x86汇编</strong>和<strong>Inline汇编</strong>两种写法。</p>
</blockquote>
<h4 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h4><blockquote>
<p>Lab1的工作目录:</p>
<ul>
<li><code>/boot</code>目录包含和启动相关的文件。</li>
<li><code>/kern</code>目录包含内核和监视器相关的文件。</li>
<li><code>/lib</code>目录包含一些链接使用的库函数比如printf。</li>
<li><code>/inc</code>目录包含头文件，申明了需要使用的数据结构。</li>
<li><code>/obj</code>目录是make之后相应的反汇编代码，供调试使用。<br>Lab1主要分析<code>/obj/kern/kern.asm</code>和<code>obj/boot/boot.asm</code>两个文件。这两个文件分别是<code>/boot</code>和<code>/kern</code>目录下的文件编译连接后的目标文件被反汇编而生成的。之所以这样做是因为反汇编之后可以看到每一条指令在内存中的绝对地址。这样调试的时候非常方便。至于<strong>实模式</strong>和<strong>保护模式</strong>下的地址转换在后续的实验中也会重点关注。</li>
</ul>
</blockquote>
<h4 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h4><blockquote>
<p>最早的8086机器只有1Mb的寻址空间，后面的80x86系列机器为了向后兼容所以衍生出实模式和保护模式这两种概念，但是BIOS一直都存在于从<code>0x00000000</code>到<code>0x00100000</code>这1Mb的空间中。JOS的内存布局也是规定只有<code>0x00000000</code>到<code>0x10000000</code>这256MB大小的空间，但是默认地址线是32位的。<strong>这个很重要，因为后面实验对JOS进行虚拟内存分配的时候页框地址最大也只能是<code>0x10000000</code>，内核如何处理映射就是一个问题。</strong>具体布局见下图:   </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/6.png" width="300" height="200" alt="pic2" align="center"></p>
<h4 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h4><h5 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h5><blockquote>
<p>这里介绍一下常用的GDB调试参数: </p>
<ul>
<li><code>si</code>: 单步调试</li>
<li><code>info register</code>: 查看当前各寄存器的值</li>
<li><code>x/Nx Addr</code>: 查看内存地址Addr之后<strong>N字</strong>的内容</li>
<li><code>x/Ni Addr</code>: 查看内存地址Addr之后的N条反汇编指令</li>
<li><code>x/Ni $eip</code>: 查看CPU当前执行的下N条指令（其中$eip可以换成不同的寄存器，这里就不一一列举了）<br>通过分析前面的JOS内存的布局，BIOS作为固件存在于<code>0xf0000</code>到<code>0xfffff</code>这64KB的空间上。<strong>注意启动为实模式，CPU的地址线寻址都是20位的。</strong>启动仿真器之后看到第一条代码停在了<code>0xffff0</code>的地址上，说明这是BIOS程序的入口。<code>0xffff0</code>到BIOS程序顶部<code>0xfffff</code>只有16字节的空间，需要更大的运行空间，因此第一条指令<code>ljmp   $0xf000,$0xe05b</code>；也就是跳转到<code>0xfe05b</code>这个地址正式开始运行BIOS的程序。<br>BIOS本身也是一个很复杂的系统，但是和OS关系不大。通过调试BIOS的代码我们知道了它的功能:</li>
<li>建立中断向量表及相应的中断例程</li>
<li>初始化部分硬件及自检(POST)</li>
<li>激活<code>INT 19</code>中断来加载启动盘第一扇区512字节的内容到内存(Linux)<br>这里应该说明第一扇区的内容是<code>/boot</code>目录下的内容:<code>boot.S</code>和<code>main.c</code>,这两个文件最后被编译链接成为可执行目标文件(这里需要ELF的知识)。在Linux系统中，这个可执行目标文件大小就是512字节，正好放在启动盘的第一个sector中,被称为<strong>bootsect</strong>。而BIOS的主要工作之一就是将<code>bootsect</code>加载到内存中，执行完任务之后，BIOS跳转到<code>bootsect</code>的初始位置。至此BIOS将权限交给操作系统，OS继续完成剩下的启动过程。<br>这里发现了一个小问题:就是在查看<code>/obj/boot</code>目录的时候，发现出现了<code>boot.out</code>和<code>boot</code>两个文件，如下:</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/7.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p><code>strip</code>命令将ELF文件中的符号表信息等调试信息删掉，减少文件本身的大小。理论上讲<code>bootsect</code>最后应该被链接到启动盘<code>kernel</code>的第一个扇区上，换句话讲最后的<strong>操作系统启动盘</strong>只有一个。查看<code>/obj/boot</code>目录下生成的这个两个文件:<code>boot.out</code>的格式为<strong>可执行目标文件</strong>，<code>boot</code>是<strong>x86 boot sector</strong>的格式，这两个文件中一定有一个作为<code>bootsect</code>链接使用。见下图:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/8.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>可是经过分析这两个文件大小都是<strong>8K</strong>,经过优化之后也要<strong>4K</strong>大小，和<code>512Bytes</code>相差太远。而且文件<code>boot</code>还不可以使用二进制工具分析。这个细节方面应该和<strong>链接</strong>关系很大，<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">《程序员的自我修养》</a>这本书是国内少有的讲链接装载的好书，有时间再拜读吧。</p>
</blockquote>
<h3 id="The-Boot-Loader"><a href="#The-Boot-Loader" class="headerlink" title="The Boot Loader"></a>The Boot Loader</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><h5 id="分析boot-boot-S"><a href="#分析boot-boot-S" class="headerlink" title="分析boot/boot.S"></a>分析boot/boot.S</h5><blockquote>
<p>分析一下<code>/boot/boot.S</code>这个文件:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">##############1.申明部分###############</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8       </span><br><span class="line">.set PROT_MODE_DSEG, 0x10       </span><br><span class="line">.set CR0_PE_ON,      0x1        </span><br><span class="line"></span><br><span class="line">#################2.16位实模式部分##########</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     </span><br><span class="line">  cli                      %禁止中断   </span><br><span class="line">  cld                        </span><br><span class="line"></span><br><span class="line">  xorw    %ax,%ax            %清零段寄存器</span><br><span class="line">  movw    %ax,%ds            </span><br><span class="line">  movw    %ax,%es            </span><br><span class="line">  movw    %ax,%ss            </span><br><span class="line">  </span><br><span class="line">###开启A20地址线##</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al          % 将64号端口的内容读到%al寄存器中   </span><br><span class="line">  testb   $0x2,%al           %检测%al的第二位是否为零（代表输入缓冲区是否为满，可以对端口继续读写）</span><br><span class="line">  jnz     seta20.1           %不为零则重复执行seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al          %将$0xd1写入%al寄存器</span><br><span class="line">  outb    %al,$0x64          %将%al寄存器的值写入64号端口</span><br><span class="line"></span><br><span class="line">seta20.2:                     %同样的方式</span><br><span class="line">  inb     $0x64,%al              </span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al              </span><br><span class="line">  outb    %al,$0x60          %两个端口读写   激活A20地址线</span><br><span class="line">###实模式————&gt;保护模式##</span><br><span class="line">  lgdt    gdtdesc    %加载GDT</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax    %取出%CR0寄存器的第零位并置1</span><br><span class="line">  movl    %eax, %cr0      %实模式向保护模式的转换</span><br><span class="line"></span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###########3.32位保护模式部分#############</span><br><span class="line"></span><br><span class="line">  .code32</span><br><span class="line">protcseg:</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax   </span><br><span class="line">  movw    %ax, %ds               </span><br><span class="line">  movw    %ax, %es               </span><br><span class="line">  movw    %ax, %fs               </span><br><span class="line">  movw    %ax, %gs               </span><br><span class="line">  movw    %ax, %ss               </span><br><span class="line"></span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spin:   %BUG Point！</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line">###########4.数据区################</span><br><span class="line">.p2align 2                       </span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL			</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)	   </span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                     </span><br><span class="line">  .long   gdt</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>申明部分</strong>两个宏定义是在保护模式下的段描述符的申明，对于保护模式后面还有介绍，这里权把它们看成是<code>CS</code>和<code>DS</code>段寄存器。<br><strong>实模式部分</strong>首先关掉了中断<code>cli</code>，因为接下来就要进行实模式下中断服务例程向保护模式下IDT中断描述符的交接。期间系统无法响应正常的中断服务。<code>cld</code>将标志位DF置零，DF和字符串操作相关;清零段寄存器。并打开了第21（A20）到第32根地址线，在没打开之前高于1MB的地址总是会“回滚”到0，这也是Linux检测保护模式和实模式的一个方法。<strong>接下来加载GDT，<code>movl %eax, %cr0</code>这句话是将系统控制寄存器<code>%CR0</code>的第0位（PE位）置一，意味着处理器工作方式变为保护模式。</strong>这里没有直接对<code>%CR0</code>进行操作，而是通过<code>%eax</code>来实现主要是为了不破坏寄存器的其他位，值得借鉴。最后<code>ljmp $PROT_MODE_CSEG, $protcseg</code>是跳转指令，<strong>需要注意的是现在已经是保护模式了，而在实模式下和保护模式下对于地址的转换方式已经从段寻址变成GDT寻址。</strong>这里只需要知道跳转到了<code>protcseg</code>这个地址。<br><strong>保护模式</strong>初始化了重要的段寄存器，然后跳转到<code>boot/main.c/bootmain</code>函数，开始将启动盘剩余的内核部分载入内存。<strong>注意在AT&amp;T格式的汇编语言中，操作数的字长是由操作符的最后一个字母决定的，后缀’b’,’w’,’l’分别表示字节（byte:8位），字（word:16位）和长字（long:32位）。</strong><br><strong>数据区部分</strong>都是在保护模式下建立GDT全局描述符的时候相关的宏定义。  </p>
</blockquote>
<h5 id="分析boot-main-c"><a href="#分析boot-main-c" class="headerlink" title="分析boot/main.c"></a>分析boot/main.c</h5><blockquote>
<p>分析一下<code>boot/main.c</code>这个文件:  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define SECTSIZE 512</span><br><span class="line">#define ELFHDR ((struct Elf *) 0x100000)</span><br><span class="line"></span><br><span class="line">void readsect(void*, uint32_t);</span><br><span class="line">void readseg(uint32_t, uint32_t, uint32_t);</span><br><span class="line">void bootmain(void);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先看这两个宏定义，<code>SECTSIZE</code>是磁盘一个<code>sector</code>的大小，一般读写操作都要求地址对齐，这个宏定义就会派上用场。<code>ELFHDR</code>是一个指向ELF文件结构体的指针，不得不说<strong>强转</strong>是C语言最有力的工具之一，由此可知<code>0x100000</code>便是内存载入的首地址。这个地址也是BIOS程序结束的地方，可见JOS对于内存的规划分配还是很精确的。  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">readseg(uint32_t pa, uint32_t count, uint32_t offset)</span><br><span class="line">&#123;</span><br><span class="line">	    //pa是加载地址    count是加载文件大小    offset是在内核文件中的偏移量</span><br><span class="line">        uint32_t end_pa;</span><br><span class="line">        end_pa = pa + count;   //结束地址</span><br><span class="line">        pa &amp;= ~(SECTSIZE - 1);  //将加载地址与最小单位512对齐</span><br><span class="line">        offset = (offset / SECTSIZE) + 1;   //计算加载部分在启动盘中的哪一个sector中，因为sector从1开始算起</span><br><span class="line">        while (pa &lt; end_pa) &#123;</span><br><span class="line">                readsect((uint8_t*) pa, offset);  </span><br><span class="line">                pa += SECTSIZE;    //这句话表明 最终分配的内存有可能是大于实际需要内存的，因为总是以512为最小分配单元分配的</span><br><span class="line">                offset++;  </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>readseg</code>函数中的对齐，看下面这个sample函数:  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	long SECSIZE = 0x200;  </span><br><span class="line">	long pa = 0x30301;</span><br><span class="line">	long to = 0x10387;</span><br><span class="line">	</span><br><span class="line">	to &amp;= ~(SECSIZE - 1);</span><br><span class="line">	pa &amp;= ~(SECSIZE - 1);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;secsize is : %lx\n&quot;, SECSIZE);</span><br><span class="line">	printf(&quot;pa is : %lx\n&quot;, pa);</span><br><span class="line">	printf(&quot;to is : %lx\n&quot;, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之所以需要对齐，因为磁盘和内存之间读写如果按照规定的最小粒度进行，CPU的访问性能会提高。具体见<a href="https://www.ibm.com/developerworks/library/pa-dalign/" target="_blank" rel="noopener">IBM.alignment</a>。上述函数的执行结果见下图:</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/9.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p><code>readsect</code>函数都是一些端口操作。也没仔细研究Orz。下面主要看一下<code>bootmain</code>函数剩下的部分:  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   for (; ph &lt; eph; ph++)</span><br><span class="line">            readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于JOS对于ELF文件的申明见<code>/inc/elf.h</code>。一共有三个结构体，<code>Elf</code>代表文件头；<code>Proghdr</code>代表加载时候segment的信息；<code>Secthdr</code>代表运行时section的信息；<br>在Lab0中，我们分析过对一个程序加载的时候是以<code>segments</code>为最小粒度的。所以我们重点关注<code>Elf</code>和<code>Proghdr</code>这两个结构体的细节。  </p>
<ul>
<li><code>e_phoff</code>: segment表在整个程序中的偏移量</li>
<li><code>e_phnum</code>: segment表项的个数</li>
<li><code>ph-&gt;p_pa</code>: 该segment在内存中的加载地址</li>
<li><code>ph-&gt;p_memsz</code>: 该segment的大小</li>
<li><code>ph-&gt;p_offset</code>: 该segment相对于表起始地址的偏移量<br>所以<code>ph</code>就是segment段表的开始地址。而<code>eph</code>就是segment段表的项数。这个循环是把所有的segments都加载到相对应的内存地址中。<br>加载结束后，再次跳转<code>((void (*)(void)) (ELFHDR-&gt;e_entry))()</code>,通过调试反汇编代码，发现跳转的这个地址为<code>call *0x10018</code>,注意这里是一个指针，可以看到内核函数真正的入口在<code>0x0010000c</code>。所以正确的操作见下图:</li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/10.png" width="300" height="200" alt="pic2" align="center"></p>
<h5 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h5><blockquote>
<p>在上面分析的过程基本上回答了所有的问题: </p>
<ul>
<li><code>%CR0</code>标志位的改变意味着实模式切换到保护模式</li>
<li><code>call *0x10018</code>是最后一条BootLoader执行的指令，<code>movw $0x1234, 0x472</code>是内核第一条指令，这条指令在<code>0x0010000c</code>这个入口地址。</li>
<li>通过读取ELF文件中关于加载segments的信息，因为main函数最开始加载了8个sectors的内容到内存中，这部分内容就是和ELF格式和细节信息有关系。</li>
</ul>
</blockquote>
<h4 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h4><h5 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h5><blockquote>
<p>重温C语言指针，实验中推荐<a href="https://book.douban.com/subject/1236999/" target="_blank" rel="noopener">TCPL</a>。分析实验中给出的部分示例代码，体会指针的魅力:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = (int *) ((char *) c + 1);</span><br><span class="line">*c = 500;</span><br><span class="line">printf(&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;,</span><br><span class="line">a[0], a[1], a[2], a[3]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码将c强转成为char类型的指针之后加一，然后赋值为500；问题就出现在char类型和int类型的指针大小是不一样的。int类型为4个字节，而char类型只有1个字节;所以这样势必会导致赋值的时候改变数组中原来的布局。已知a[1]原来的值400，16进制为0x190;a[2]的值原来为301，16进制为0x12D;500的16进制为0x1F4;一个地址单元为一个字节，为见下图:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/11.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>可以看到读写操作是按照字节为最小单元，最后导致a[1]的值变成0x1F490也就是十进制的128144；而a[2]由于被抹掉以个字节，所以变成0x100也就是256。下图是最终的运行结果:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/12.png" width="300" height="200" alt="pic2" align="center"></p>
<h5 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h5><blockquote>
<p>关于链接器和加载器，最经典的当然是这本<a href="https://www.iecc.com/linker/" target="_blank" rel="noopener">loader and linker</a>。这是中译本<a href="https://paper.seebug.org/papers/Archive/refs/elf/《链接器和加载器》中译本.pdf" target="_blank" rel="noopener">ll.Ch</a>。不过我做实验的时候没有想明白他们为什么要在这里引入这两个复杂的概念；题目很简单，但是不知道<code>LMA</code>和<code>VMA</code>是和虚拟内存有关系还是和链接器，加载器有关系。后来用<code>readelf -h kernel</code>发现<code>VMA</code>就是虚拟地址，所以这里他们所谓的linking address和loading address只是实验中自行定义的字面意思<strong>加载的地址</strong>和<strong>执行的地址</strong>，和链接器加载器没有关系！！另外在Lab0中已经分析过加载时候的<code>section</code>是所有<code>sections</code>组合成的一个聚合节，这里不考虑链接时候的单个<code>section</code>的概念。<strong>这样的话，就可以明白实验讲解的思路————引入使用ELF中<code>segments</code>的概念来解释加载过程，而加载过程时候已经开启了分页机制，所以这时候用<code>loading address</code>和<code>linking address</code>来解释<code>0xf0100000</code>和<code>0x00100000</code>的区别。而实际上<code>0xf0100000</code>就是映射到<code>0x00100000</code>上，相关细节在Kernel部分会继续分析。</strong><br>readelf和objdump的操作见下图:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/14.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>将链接地址改掉之后，第一条报错的应该是和链接地址直接相关的指令，跳转指令<code>ljmp $PROT_MODE_CSEG, $protcseg</code>;</p>
</blockquote>
<h5 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h5><blockquote>
<p>前面分析过<code>#define ELFHDR ((struct Elf *) 0x100000)</code>所以我们可以知道，内核的装载地址(load address)就是<code>0x00100000</code>，而内核开始执行的地址应该是<code>e_entry</code>也就是<code>0x0010000c</code>。从BIOS到BootLoader的时候，内核还没有开始装载。所以<code>0x00100000</code>是空的。  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/13.png" width="300" height="200" alt="pic2" align="center"></p>
<h3 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h3><h4 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h4><blockquote>
<p>Lab1中的地址映射: <code>0x00000000</code>————<code>0x00400000</code>映射到<code>0x00000000</code>————<code>0x00400000</code>；<code>0xf0000000</code>————<code>0xf0400000</code>映射到<code>0x00000000</code>————<code>0x00400000</code>;<br>在实验过程中关注了一下地址: 在执行到<code>kern/entry.S</code>文件之前，所有的内存地址都是物理地址（书中代言为线性地址，但是线性地址=物理地址所以没有太大区分）。直到<code>%CR0</code>寄存器的PG标志位被置零。这时候分页机制才被激活。<code>0x00100000</code>和<code>0xf0100000</code>都映射到<code>0x00100000</code>，所有两个地址存储的数值是一样的。而在映射还没有建好之前是不一样的。  </p>
</blockquote>
<h5 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h5><blockquote>
<p><code>%CR0</code>寄存器PG位控制分页机制的实现。看到<code>mov %eax, %cr0</code>执行结束之后，索引地址变成了<code>0xf0100010</code>。地址映射不对，第一条错误的指令一定会是跳转指令<code>jmp *%eax</code>。具体的分页细节在Lab2中分析。实验操作见下图:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/15.png" width="300" height="200" alt="pic2" align="center"></p>
<h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><h5 id="分析kern-printf-c"><a href="#分析kern-printf-c" class="headerlink" title="分析kern/printf.c"></a>分析kern/printf.c</h5><blockquote>
<p>下面分析一下<code>kern/printf.c</code>这个文件:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void putch(int ch, int *cnt)</span><br><span class="line">&#123;</span><br><span class="line">        cputchar(ch);//显示屏输出函数console</span><br><span class="line">        *cnt++;   //每进行一次显示屏输出，参数自加</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int vcprintf(const char *fmt, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">        int cnt = 0;   //cnt将自身指针传给putch(int, int*)，在函数里进行自加</span><br><span class="line">        vprintfmt((void*)putch, &amp;cnt, fmt, ap);  //格式判断</span><br><span class="line">        return cnt;                  //返回最终输出的参数个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cprintf(const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        int cnt;</span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        cnt = vcprintf(fmt, ap);//变参传递</span><br><span class="line">        va_end(ap);</span><br><span class="line">        return cnt;  //返回参数个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>cprintf</code>是主函数，这里用到了C语言的变参特性。变参在C库<code>stdarg.h</code>中定义至少要有一个固定的参数:<code>fun(const char *fmt, ...)</code>。主要有三个宏组成: </p>
<ul>
<li><code>va_list</code>: 申明可变参数指针ap，依次指向省略号表示的可变参数</li>
<li><code>va_start(ap, lastFix)</code>:  初始化ap，开始指向第一个可变参数</li>
<li><code>va_arg(ap, type)</code>: 将ap指向下一个可变参数</li>
<li><code>va_end(ap)</code>: 清除ap指针，结束函数<br>可以看到变参<code>fmt</code>和变参指针<code>ap</code>被一路传到<code>vcprintf</code>———&gt;<code>vprintfmt</code>。在<code>vprintfmt</code>中使用。该文件中重点关注两个函数:</li>
<li>在<code>lib/printfmt.c</code>中的函数: <code>vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)</code></li>
<li>在<code>kern/console.c</code>中的函数: <code>cputchar(int c)</code><br>经过观察之后就可以知道: <strong><code>vprintfmt</code>函数判断字符串输出参数的类型并调用<code>cputchar</code>函数将相应的输出显示到显示屏上</strong>。<br>在函数分析之前再介绍一个vim的新技能:搜索高亮<code>:match Search /xxx/</code>,可以对现在正在关注的关键字进行高亮显示，调试的时候很有用:  </li>
</ul>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/22.png" width="300" height="200" alt="pic2" align="center"></p>
<h6 id="分析函数vprintfmt"><a href="#分析函数vprintfmt" class="headerlink" title="分析函数vprintfmt"></a>分析函数vprintfmt</h6><blockquote>
<p><code>vprintfmt</code>函数其实很简单，主体就是一个while循环:在遇到<code>%</code>之前直接输出，遇到<code>%</code>之后开始判断格式并输出。</p>
</blockquote>
<h6 id="分析函数cputchar"><a href="#分析函数cputchar" class="headerlink" title="分析函数cputchar"></a>分析函数cputchar</h6><blockquote>
<p><strong>在<code>vprintfmt</code>函数中需要注意一个变量:<code>ch = *(unsigned char *) fmt++</code>。<code>ch</code>代表了当前ap指针指向的变参，也就是我们需要输出的内容。</strong><code>cputchar(ch)</code>中的参数正好就是这个<code>ch</code>。我们使用Ctags跟踪这个<code>ch</code>参数经过的函数:<code>putch(int ch, int *)</code>————&gt;<code>cputchar(int ch)</code>————&gt;<code>cons_putc(int ch)</code>。现在基本上可以看清所有的控制台输出操作都是定义在<code>console.c</code>文件中的。我们直接分析一下<code>cons_putc(int ch)</code>这个函数:  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void cons_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">        serial_putc(c);</span><br><span class="line">        lpt_putc(c);</span><br><span class="line">        cga_putc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上三个子函数都涉及到的内联汇编<code>inb()</code>和<code>outb()</code>两个函数在<code>inc/x86.h</code>中有定义。其中<code>serial_putc</code>是串口输出，<code>lpt_putc</code>是并口输出，而<code>cga_putc</code>是显示屏输出，具体不细分析了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; !(inb(0x378+1) &amp; 0x80) &amp;&amp; i &lt; 12800; i++)</span><br><span class="line">       delay();    //判断数据缓冲区寄存器是否为空，为空则一直循环</span><br><span class="line">   outb(0x378+0, c);     //将C参数代表的内容写到端口中</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>另外，在<code>cga_putc(c)</code>函数中，有一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">    for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">        crt_buf[i] = 0x0700 | &apos; &apos;;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>我们知道<code>cga_putc(c)</code>函数是用于显示屏输出的函数，而查看这几个宏定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static uint16_t crt_pos //光标</span><br><span class="line">#define CRT_ROWS        25   //显示屏行</span><br><span class="line">#define CRT_COLS        80    //显示屏列</span><br><span class="line">#define CRT_SIZE        (CRT_ROWS * CRT_COLS)  //显示屏面积</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>简单来讲就是如果输出满屏之后，需要页面向上滚动一行。</p>
</blockquote>
<h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h4><h5 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h5><blockquote>
<p>经过上面的分析之后，知道格式化输出是在<code>kern/printfmt.c/vprintfmt()</code>这个函数中。找到相应的位置修改就行。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/16.png" width="300" height="200" alt="pic2" align="center"></p>
<h5 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h5><blockquote>
<p>这是Exercise.8后面的一些问题，当然很简单了:<br>1.cputchar(int c)         2.一句话，就是满屏时候的处理方法          3.主要是变参指针<code>ap</code>和格式化变参<code>fmt</code>的指向问题，之前分析过<br>4.将代码加到<code>kern/monitor.c</code>中，输出见下图。因为57616的十六进制就是ell。而0x0x00646c72在小端存储的机器上用char*表示就是<code>rld\0</code>。如果想要用大端存储的话，只要反过来就行0x726c6400。  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/17.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>5.根据变参的定义，如果fmt参数不够，那最终ap指针会指向一个未知内存区域。所以输出的数不一定。见下图:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/18.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>6.关于变参的定义是在<code>inc/stdarg.h</code>中,我们看一下<code>va_arg</code>是如何一次一次取出变参的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define va_arg(ap, type) __builtin_va_arg(ap, type) //Fall 2018</span><br><span class="line"></span><br><span class="line">#define va_arg(ap, type) \</span><br><span class="line">	(*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))  //Fall 2015</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>可以看到va_arg是通过地址往后增长来取出下一个变参的。<strong>而正常编译器是从右往左的顺序将参数入栈的（因为栈是从高地址向低地址延伸的）。</strong>如果这时候栈的顺序变了，那只需要将va_arg函数中的对地址的加法改为减法就行。  </p>
</blockquote>
<h4 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h4><h5 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h5><blockquote>
<p>关于栈的定义在<code>kern/entry.S</code>中。见下图:</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/19.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>因为栈是从高地址向低地址延伸的，所以<code>mov $(bootstacktop) %esp</code>将栈顶地址赋值给<code>%esp</code>寄存器。而在数据段中对栈大小的定义也很清楚了————<code>KSTKSIZE</code>是一个宏定义，大小为8x4KB=32KB。</p>
</blockquote>
<h5 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h5><blockquote>
<p>需要深入了解栈调用的机制，就需要了解<strong>stack pointer</strong><code>%esp</code>和<strong>base pointer</strong><code>%ebp</code>这两个寄存器的用法。我们通过调试<code>test_backtrace()</code>函数来深入了解。(实际上只要有函数调用就会有栈，但很明显test_backtrace不是第一个调用的函数。当然你也可以从第一个函数i386_init开始，这个时候%esp也刚刚完成初始化0xf0110000,感觉会更爽一些)。<br><code>test_backtrace</code>函数的调用发生在<code>kern/init.c/i386_init()</code>中，所以我们第一个断点设置在<code>0xf01000de</code>。从反汇编代码中可以看出，开始调用<code>test_backtrace</code>之前，还有两条指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5, (%esp)</span><br><span class="line">call f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>在还没有开始执行的时候，查看一下寄存器的状态<code>info registers</code>:<code>%esp</code>的值为<code>0xf010ffe0</code>，<code>%ebp</code>的值为<code>0xf010fff8</code>。<br>然后开始执行第一句，将参数5<strong>movl</strong>到栈顶，注意这里不是压栈而是直接存进去的，所以栈指针<code>%esp</code>是不会移动的。但是这时候栈顶元素应该是0x5。我们可以通过<code>info registers</code>命令和<code>x/8x $esp</code>来分别验证，效果如下:</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/20.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>在看一下第二条指令<code>call f0100040</code>。<code>call</code>指令可以分成两条指令:<code>push %eip</code>和<code>jmp 0xf0100040</code>。所以看到<code>push</code>指令是正宗的压栈指令，这时候<code>%esp</code>寄存器的值是要-4的，而且递减满堆栈的顺序是<strong>先-4，再压栈</strong>。这次栈顶元素应该是下一条指令的地址<code>0xf01000ea</code>，而且<code>%esp</code>的值还得-4。我们可以通过<code>info registers</code>和<code>x/8x $esp</code>来分别验证:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/21.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>第三条指令就正式进入到<code>test_backtrace</code>函数内部了。分析一下函数内部的<strong>调用代码</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void test_backtrace(int x)</span><br><span class="line">&#123;</span><br><span class="line">f0100040:       55                      push   %ebp</span><br><span class="line">f0100041:       89 e5                   mov    %esp,%ebp</span><br><span class="line">f0100043:       53                      push   %ebx</span><br><span class="line">f0100044:       83 ec 14                sub    $0x14,%esp</span><br><span class="line">f0100047:       8b 5d 08                mov    0x8(%ebp),%ebx</span><br><span class="line">        cprintf(&quot;entering test_backtrace %d\n&quot;, x);</span><br><span class="line">f010004a:       89 5c 24 04             mov    %ebx,0x4(%esp)</span><br><span class="line">f010004e:       c7 04 24 20 1a 10 f0    movl   $0xf0101a20,(%esp)</span><br><span class="line">f0100055:       e8 c1 09 00 00          call   f0100a1b &lt;cprintf&gt;</span><br><span class="line">        if (x &gt; 0)</span><br><span class="line">f010005a:       85 db                   test   %ebx,%ebx    </span><br><span class="line">f010005c:       7e 0d                   jle    f010006b &lt;test_backtrace+0x2b&gt;</span><br><span class="line">                test_backtrace(x-1);</span><br><span class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</span><br><span class="line">f0100061:       89 04 24                mov    %eax,(%esp)</span><br><span class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</span><br><span class="line">f0100069:       eb 1c                   jmp    f0100087 &lt;test_backtrace+0x47&gt;</span><br><span class="line">        else</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>基本上所有被调用的函数开头都会有这两条指令:<code>push %ebp</code>;<code>mov %esp, %ebp</code>;<br>实验指导书上也解释了<code>%ebp</code>寄存器的作用:<strong>On entry to a C function, the function’s prologue code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current esp value into ebp for the duration of the function.</strong>每一个函数都有一个<code>%ebp</code>值，作为函数的栈帧，需要在每次调用新函数的时候压栈以保存上一个函数的返回地址。<br>这个时候莫名其妙的压栈了一个寄存器<code>%ebx</code>。我们将<code>%ebx</code>全局高亮显示发现，后面紧接着会有<code>mov 0x8(%ebp), %ebx</code>。那<code>0x8(%ebp)</code>存储的到底是啥？不难想到就是参数5。然后<code>%esp</code>指针接着扩展当前函数的栈空间。关注一下第二次调用<code>test_backtrace()</code>，前一条指令<code>mov %eax, (%esp)</code>和第一次调用的时候完全一样，而<code>%eax</code>中存的也是参数5-1=4;当然调用指令<code>call</code>也需要一次压栈。总结一下，如果是从<code>push %ebp</code>开始算起是函数栈的开头的话，那我们每一个函数调用会花费<code>4（push %ebp）+4(push %ebx)+20(sub $0x14,%esp)+4(call)</code>一共是32Bytes字节的空间。所以整个栈的布局见下图:   </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/23.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>当然在调用过程中还调用了<code>cprintf()</code>这个函数，不过20字节用来分配栈空间也够了。</p>
</blockquote>
<h5 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h5><blockquote>
<p>经过上面的分析，栈的布局已经很清楚了。所以我们需要知道对于<code>read_ebp()</code>函数来说读出的是当前<code>%ebp</code>指针指向的地址，所以按照上面栈的布局:<code>(%ebp)--&gt;上一个%ebp</code>,<code>0x4（%ebp）--&gt;%eip</code>,<code>0x8(%ebp)--&gt;参数1</code>…当然这里的参数比5个少。<br>下面就是考验C语言的时刻，一定要注意格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">mon_backtrace(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        // Your code here.</span><br><span class="line">        /*</span><br><span class="line">         parameter &quot;argc&quot; indicates numbers of paras passed by the command-line;  parameter &quot;argv&quot; indicates specific paras accordingly.</span><br><span class="line">        */</span><br><span class="line">        struct Eipdebuginfo info;</span><br><span class="line">        cprintf(&quot;Stack backtrace:\n&quot;);</span><br><span class="line">        uint32_t *ebp = (uint32_t*)read_ebp();</span><br><span class="line">        while(ebp) &#123;</span><br><span class="line">                uint32_t eip = ebp[1];</span><br><span class="line">                cprintf(&quot;  ebp %x  eip %x  args &quot;, ebp, eip);</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+2));//这里提一下指针的用法，指导书中有讲解</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+3));</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+4));</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+5));</span><br><span class="line">                cprintf(&quot;%08.x\n&quot;, *(ebp+6));</span><br><span class="line"></span><br><span class="line">                ebp = (uint32_t*)*(ebp);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h5 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h5><blockquote>
<p>对每一个<code>%eip</code>，尝试着给出其<strong>文件名称</strong>，<strong>函数名称</strong>和<strong>行号</strong>。这些信息都属于调试的信息。实验要做的是找到这些调试信息，并按照规定格式将它们输出。这里需要了解<a href="https://sourceware.org/gdb/onlinedocs/stabs.html#Stab-Sections" target="_blank" rel="noopener">STAB</a>符号表的概念。<br>首先查看下<code>kern/kernel.ld</code>链接脚本。发现了有关<code>_STAB_*</code>的两个信息————<code>.stab</code>和<code>.stabstr</code>。其中stab是今天的重点。<code>kern/kdebug.c</code>中的宏定义说明了stab和stabstr的关系。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern const struct Stab __STAB_BEGIN__[];      // Beginning of stabs table</span><br><span class="line">extern const struct Stab __STAB_END__[];        // End of stabs table</span><br><span class="line">extern const char __STABSTR_BEGIN__[];          // Beginning of string table</span><br><span class="line">extern const char __STABSTR_END__[];            // End of string table</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再看一下<code>inc/stab.h</code>对stab定义的数据结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Entries in the STABS table are formatted as follows.</span><br><span class="line">struct Stab &#123;</span><br><span class="line">        uint32_t n_strx;        // index into string table of name    该项对应的在stabstr节内的索引偏移</span><br><span class="line">        uint8_t n_type;         // type of symbol   该项描述的符号类型   重点关注</span><br><span class="line">        uint8_t n_other;        // misc info (usually empty)   </span><br><span class="line">        uint16_t n_desc;        // description field  源文件的行号  重点关注</span><br><span class="line">        uintptr_t n_value;      // value of symbol   地址值   重点关注</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>通过<code>objdump -G obj/kern/kernel</code>来查看当前ELF文件中的符号表信息。见下图:  </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/24.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>仔细观察上图，发现每一列的分类就是按照stab数据结构分类的。重点关注一下<code>n_type</code>这个关键字，它表示该描述项的符号类型，上图中出现有很多<code>SO</code>，<code>FUN</code>…等符号类型。将这些列单独列出来进行对比:   </p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/25.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>很明显<code>SO</code>指的是文件名，<code>FUN</code>指的是函数名。<strong>注意这是objdump对应的符号表，JOS对符号表有自己定义的数据结构见<code>inc/stab.h</code></strong>。输出的顺序都是按照地址来排序的，很整齐。所以<code>stab_binsearch()</code>查找函数原理也就猜的差不多了，<strong>这些调试信息和相应地址的关系是通过符号表来连接的。当然所有的这些知识都可以通过<code>kern/kdebug.c</code>这个文件中对<code>stab</code>的注释（见过最全的注释了）学习到。所以我们最后分析一下这个文件:</strong><br>整个文件一共有两个函数<code>debuginfo_eip</code>和<code>stab_binsearch</code>。JOS建立了一个数据结构<code>Eipdebuginfo</code>用来存放调试信息，<code>debuginfo_eip</code>调用<code>stab_binsearch</code>函数完成一个实例化的<code>Eipdebuginfo</code>，所有的输出信息其实最后都存储在这个实例中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Eipdebuginfo &#123;</span><br><span class="line">        const char *eip_file;           // Source code filename for EIP</span><br><span class="line">        int eip_line;                   // Source code linenumber for EIP</span><br><span class="line"></span><br><span class="line">        const char *eip_fn_name;        // Name of function containing EIP</span><br><span class="line">                                        </span><br><span class="line">        int eip_fn_namelen;             // Length of function name</span><br><span class="line">        uintptr_t eip_fn_addr;          // Address of start of function</span><br><span class="line">        int eip_fn_narg;                // Number of function arguments</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p><code>stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right, int type, uintptr_t addr)</code>函数本质上就是一个二分查找。<strong><code>type</code>指的就是符号表项的符号类型，该函数每次查找的时候都需要确定查找的符号类型</strong>。我们需要完成的部分是行号，通过检查<code>inc/stab.h</code>文件，很容易知道行号的宏定义是<code>S_LINE</code>。二分查找失败的标志就是<code>LeftA &gt; rightA</code>。所以代码也很简单了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Your code here.</span><br><span class="line">       stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);   </span><br><span class="line">       if(lline &lt;= rline)&#123;</span><br><span class="line">               info-&gt;eip_line = stabs[lline].n_desc;  //确定行号</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">               return -1;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>最后将monitor的命令补充完整就更简单了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add :</span><br><span class="line">debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(&quot;\t%s:%d: %.*s+%d\n&quot;, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, info.eip_fn_addr);</span><br><span class="line">to kern/monitor.c/mon_backtrace()</span><br><span class="line"></span><br><span class="line">add :</span><br><span class="line">        &#123;&quot;backtrace&quot;, &quot;Display each stack frame called&quot;, mon_backtrace &#125;,</span><br><span class="line">to kern/monitor/commands[]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>运行结果见下图:</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/26.png" width="300" height="200" alt="pic2" align="center"></p>
<blockquote>
<p>实验过程中有几处细节涉及到编译器的优化，因为还不是很了解编译链接的细节和原理，所以被我忽略掉了。<br>至此Lab1结束。</p>
</blockquote>

      
    </div>
    
    
    
    

    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2018/11/05/Mit6-828-Fall2018-Lab1/">Mit6.828(Fall 2018) Lab1</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 HaotianMichael 的个人博客">HaotianMichael</a></p>
  <p><span>发布时间:</span>2018年11月04日 - 21:11</p>
  <p><span>最后更新:</span>2018年11月18日 - 23:11</p>
  <p><span>原始链接:</span><a href="/2018/11/05/Mit6-828-Fall2018-Lab1/" title="Mit6.828(Fall 2018) Lab1">http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
    });
    });  
</script>



      
   </div>	 

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Assembly/" rel="tag"><i class="fa fa-tag"></i> Assembly</a>
          
            <a href="/tags/MIT-6-828/" rel="tag"><i class="fa fa-tag"></i> MIT 6.828</a>
          
            <a href="/tags/OS/" rel="tag"><i class="fa fa-tag"></i> OS</a>
          
            <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C</a>
          
            <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/05/Mit6-828-Fall-2018-Lab0/" rel="next" title="Mit6.828(Fall 2018) Lab0">
                <i class="fa fa-chevron-left"></i> Mit6.828(Fall 2018) Lab0
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/17/Mit6-828-Fall-2018-Shell/" rel="prev" title="Mit6.828(Fall 2018) Shell">
                Mit6.828(Fall 2018) Shell <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MDI2Ni8xNjc5Mw=="></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="HaotianMichael" />
          <p class="site-author-name" itemprop="name">HaotianMichael</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/haotianmichael" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.cnblogs.com/haotianmichael" target="_blank" title="Cnblogs">
                  
                    <i class="fa fa-fw fa-address-book"></i>
                  
                    
                      Cnblogs
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://gitlab.com/haotianmichael" target="_blank" title="GitLab">
                  
                    <i class="fa fa-fw fa-gitlab"></i>
                  
                    
                      GitLab
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab1"><span class="nav-number">1.</span> <span class="nav-text">Lab1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Before-Lab"><span class="nav-number">1.1.</span> <span class="nav-text">Before Lab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PC-Bootstrap"><span class="nav-number">1.2.</span> <span class="nav-text">PC Bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Getting-Started-with-x86-assembly"><span class="nav-number">1.2.1.</span> <span class="nav-text">Getting Started with x86 assembly</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-1"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Exercise 1</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Simulating-the-x86"><span class="nav-number">1.2.2.</span> <span class="nav-text">Simulating the x86</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-PC’s-Physical-Address-Space"><span class="nav-number">1.2.3.</span> <span class="nav-text">The PC’s Physical Address Space</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-ROM-BIOS"><span class="nav-number">1.2.4.</span> <span class="nav-text">The ROM BIOS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-2"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">Exercise 2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Boot-Loader"><span class="nav-number">1.3.</span> <span class="nav-text">The Boot Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Code"><span class="nav-number">1.3.1.</span> <span class="nav-text">Code</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分析boot-boot-S"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">分析boot/boot.S</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分析boot-main-c"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">分析boot/main.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-3"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">Exercise 3</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Loading-the-Kernel"><span class="nav-number">1.3.2.</span> <span class="nav-text">Loading the Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-4"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Exercise 4</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-5"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Exercise 5</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-6"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">Exercise 6</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Kernel"><span class="nav-number">1.4.</span> <span class="nav-text">The Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-virtual-memory-to-work-around-position-dependence"><span class="nav-number">1.4.1.</span> <span class="nav-text">Using virtual memory to work around position dependence</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-7"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Exercise 7</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Code-1"><span class="nav-number">1.4.2.</span> <span class="nav-text">Code</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分析kern-printf-c"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">分析kern/printf.c</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#分析函数vprintfmt"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">分析函数vprintfmt</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#分析函数cputchar"><span class="nav-number">1.4.2.1.2.</span> <span class="nav-text">分析函数cputchar</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Formatted-Printing-to-the-Console"><span class="nav-number">1.4.3.</span> <span class="nav-text">Formatted Printing to the Console</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-8"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Exercise 8</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Questions"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Questions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Stack"><span class="nav-number">1.4.4.</span> <span class="nav-text">The Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-9"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Exercise 9</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-10"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">Exercise 10</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-11"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Exercise 11</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-12"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">Exercise 12</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<div class="copyright" >
     
  <span class="author" itemprop="copyrightHolder">HaotianMichael</span>
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
 
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
