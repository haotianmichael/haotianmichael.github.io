<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>函数式编程（Ocaml） | CodeSaw</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/css/highlight.css">
  
  <meta name="description" content="Abstract  ​ 最近在实验室实习的过程中学到了很多有意思的东西，对Programming Languages也有了更深的了解，Ocaml是一门支持多范式的函数式编程语言。程序描述计算，但是又不仅仅是计算。Ocaml的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:  关于scripting/imperative/object-oriented/functional PL的基本概">
<meta name="keywords" content="PL,FP">
<meta property="og:type" content="article">
<meta property="og:title" content="函数式编程（Ocaml）">
<meta property="og:url" content="http://haotianmcihael.github.io/2021/04/18/函数式编程（Ocaml）/index.html">
<meta property="og:site_name" content="CodeSaw">
<meta property="og:description" content="Abstract  ​ 最近在实验室实习的过程中学到了很多有意思的东西，对Programming Languages也有了更深的了解，Ocaml是一门支持多范式的函数式编程语言。程序描述计算，但是又不仅仅是计算。Ocaml的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:  关于scripting/imperative/object-oriented/functional PL的基本概">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2021-12-31T10:03:53.726Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="函数式编程（Ocaml）">
<meta name="twitter:description" content="Abstract  ​ 最近在实验室实习的过程中学到了很多有意思的东西，对Programming Languages也有了更深的了解，Ocaml是一门支持多范式的函数式编程语言。程序描述计算，但是又不仅仅是计算。Ocaml的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:  关于scripting/imperative/object-oriented/functional PL的基本概"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">CodeSaw</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-函数式编程（Ocaml）" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      函数式编程（Ocaml）
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2021-04-18T09:48:24.000Z" itemprop="datePublished">2021-04-18</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <h3 id="abstract">Abstract</h3>
<blockquote>
<p>​ 最近在实验室实习的过程中学到了很多有意思的东西，对<code>Programming Languages</code>也有了更深的了解，<code>Ocaml</code>是一门支持多范式的函数式编程语言。<strong>程序描述计算，但是又不仅仅是计算</strong>。<code>Ocaml</code>的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:</p>
<ul>
<li>关于<code>scripting/imperative/object-oriented/functional PL</code>的基本概念
<ul>
<li><code>Higher-order Functions</code></li>
<li><code>State-Full vs State-Free Computation</code></li>
<li><code>Modelling Objects and Closures</code></li>
<li><code>Exceptions/Continuations to Defer Control</code></li>
<li><code>Polymorphism</code></li>
<li><code>Partial Evaluation/Lazy Programming/Modules</code></li>
</ul></li>
<li>关于<code>reason about programs</code>的方法
<ul>
<li><code>Type Checking</code></li>
<li><code>Induction</code></li>
<li><code>Operational Semantics</code></li>
<li><code>QuickCheck</code></li>
</ul></li>
<li>关于设计一门语言的基本规则</li>
</ul>
</blockquote>
<a id="more"></a>
<h3 id="fps-basic-concepts">FP's Basic Concepts</h3>
<blockquote>
<p><code>Ocaml is a statically typed functional programminng language</code>。函数式编程中，<code>function</code>永远是一等公民，程序中只有<code>expression</code>的概念，通过<code>functions</code>递归处理<code>values</code>来完成<code>computations</code>。<code>Ocaml</code>通过<code>pattern matching</code>模式匹配的方式来定义递归数据结构和函数，进而写出更简洁的程序。</p>
<p>在函数式中还有一个和<code>imperative PL.</code>中不同的概念称为<code>effect-free programming</code>。在命令式语言中，我们通过给<code>variables/fields</code>赋值来修改程序状态并将赋值行为的结果看成是<code>effects</code>。但是比如函数式就不会<code>explicitly</code>的分配内存，甚至没有<code>exception handling</code>来改变控制流状态——<strong>不支持<code>effect</code>被称为<code>pure functiional</code>比如<code>Haskell</code></strong>。<code>Ocaml</code>不是纯函数式语言。所以支持<code>effectful/state-full programming</code>和<code>pure FP</code>。</p>
<p>最后一个关键字就是<code>statically typed</code>静态类型。<code>Types statically approximate the runtime behaviour of an expression.</code>意思就是<code>static type checking</code>本身是在程序运行之前进行类型检查——通过<code>syntatic structure of expressions</code>。它可以保证通过静态类型检查的程序在运行时一定不会<code>core dump</code>。这样的<code>statically typed PL.</code>比如<code>Ocaml/Java/ML/Haskell/Scala等</code>也被称为是<code>type-safe</code>的。</p>
</blockquote>
<h4 id="expressions-names-values-and-types">Expressions, Names, Values and Types</h4>
<blockquote>
<p>在函数式中没有语句<code>statements</code>，最基本的<code>expression</code>就是<code>numbers/strings/booleans</code>。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="number">2</span> + <span class="number">3</span>;;</span><br><span class="line">&gt; - : <span class="built_in">int</span> = <span class="number">5</span></span><br><span class="line">&gt; # <span class="number">4.0</span> /. <span class="number">2.0</span>;;</span><br><span class="line">&gt; - : <span class="built_in">float</span> = <span class="number">2.0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>上面代码中的格式为<code>&lt;name&gt; : &lt;type&gt; = &lt;value&gt;</code> 。我们将<code>;;</code>之前的式子称为<code>expressions</code>，将整个计算过程称为<code>evaluation</code>，而将计算的结果称为<code>values</code>。</p>
<p>注意在<code>Ocaml</code>中基础运算符并没有被重载，故浮点运算都是在后面有一个<code>,</code>。这主要是因为<code>Ocaml</code>是静态类型的，不会在运行时去根据运算符参数来推导重载的<code>operators</code>。</p>
<p>通过类型检查的程序，其<code>evaluation</code>要么更新到一个新的<code>state</code>要么报一个<code>built-in runtime error</code>。比如:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="number">3</span> / <span class="number">0</span>;;</span><br><span class="line">&gt; <span class="type">Exception</span>: <span class="type">Division_by_zero</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="variables-bindings-and-functions">Variables, Bindings and Functions</h4>
<blockquote>
<p><code>Ocaml</code>是一个<code>call-by-value</code>的语言——<code>it binds values to variable names not expressions</code>。这里有一个<code>binding</code>的概念，区分于<code>assignment</code>。我们只是在<code>values</code>和<code>name</code>之间建立了“链接”——并没有新的<code>state</code>被创建——我理解和<code>imperative PL.</code>不同的应该是内存模型比如<code>C</code>中对局部变量是放在栈上的但是确实创建了内存。当然这种“链接”也是可以更新的。在<code>Ocaml</code>中用<code>let</code>表达式来建立一个绑定。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">let</span> x = <span class="number">3</span> * <span class="number">3</span>;;</span><br><span class="line">&gt; <span class="keyword">val</span> x : <span class="built_in">int</span> = <span class="number">9</span></span><br><span class="line">&gt; # <span class="keyword">let</span> x = <span class="number">42</span>;;</span><br><span class="line">&gt; <span class="keyword">val</span> x : <span class="built_in">int</span> = <span class="number">42</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>变量的作用域是根据<code>binding stack</code>来确定的。局部或者临时创建的<code>binding</code>都会被<code>push</code>进<code>binding stack</code>中，在不需要的时候会被<code>GC</code>清除。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">let</span> k = <span class="number">4</span>;;</span><br><span class="line">&gt; <span class="keyword">val</span> k : <span class="built_in">int</span> = <span class="number">4</span></span><br><span class="line">&gt; # <span class="keyword">let</span> k = <span class="number">3</span> <span class="keyword">in</span> k * k ;;</span><br><span class="line">&gt; - : <span class="built_in">int</span> = <span class="number">9</span></span><br><span class="line">&gt; # k;;</span><br><span class="line">&gt; - : <span class="built_in">int</span> = <span class="number">4</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这里有一个新的<code>let &lt;name&gt; = &lt;expression 1&gt; in &lt;expression 2&gt;</code>结构——将<code>expression1</code>的<code>value</code>绑定到<code>name</code>上，然后继续使用这个新的绑定对<code>expression 2</code>进行<code>evalutions</code>。</p>
<p>在函数式中<code>let</code>不仅可以绑定基本类型，还可以绑定函数。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> area : <span class="built_in">float</span> -&gt; <span class="built_in">float</span> = <span class="keyword">function</span> r -&gt; pi *. r *. r;;</span><br><span class="line">&gt; <span class="keyword">let</span> area : <span class="built_in">float</span> -&gt; <span class="built_in">float</span> = <span class="keyword">fun</span> r -&gt; <span class="number">3.14</span> *. r *. r;;</span><br><span class="line">&gt; <span class="keyword">let</span> area (r:<span class="built_in">float</span>) = pi *. r *. r;;</span><br><span class="line">&gt; <span class="keyword">let</span> a1 = area(<span class="number">2.0</span>);;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>上面的三种写法是等价的，都得到函数类型<code>val area : float -&gt; float = &lt;fun&gt;</code>。<strong>有意思的是函数作为一种绑定，也是在<code>binding stack</code>中的，所以它只能看到过去的绑定：</strong></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">let</span> (pi*<span class="built_in">float</span>) = <span class="number">3.0</span></span><br><span class="line">&gt; <span class="keyword">val</span> pi : <span class="built_in">float</span> = <span class="number">3.14</span></span><br><span class="line">&gt; # <span class="keyword">let</span> area (r:<span class="built_in">float</span>) = pi *. r *.r;;</span><br><span class="line">&gt; <span class="keyword">val</span> area : <span class="built_in">float</span> -&gt; <span class="built_in">float</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line">&gt; # <span class="keyword">let</span> a1 = area(<span class="number">2.0</span>);;</span><br><span class="line">&gt; <span class="keyword">val</span> a1 : <span class="built_in">float</span> = <span class="number">12.0</span></span><br><span class="line">&gt; # <span class="keyword">let</span> (pi*<span class="built_in">float</span>) = <span class="number">4.0</span></span><br><span class="line">&gt; <span class="keyword">val</span> pi : <span class="built_in">float</span> = <span class="number">4.0</span></span><br><span class="line">&gt; # <span class="keyword">let</span> a2 = area(<span class="number">2.0</span>);;</span><br><span class="line">&gt; <span class="keyword">val</span> a2 : <span class="built_in">float</span> = <span class="number">12.0</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>最后介绍一下递归函数。在<code>Ocaml</code>中递归函数使用<code>let rec</code>来声明。比如定义<code>factorial</code>:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">exception</span> <span class="type">Domain</span>;;</span><br><span class="line">&gt; # <span class="keyword">let</span> <span class="keyword">rec</span> fact n = </span><br><span class="line">&gt; 	<span class="keyword">if</span> n &lt; <span class="number">0</span> <span class="keyword">then</span> raise <span class="type">Domain</span></span><br><span class="line">&gt; 	<span class="keyword">else</span> <span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span></span><br><span class="line">&gt; 	<span class="keyword">else</span> n * fact(n - <span class="number">1</span>);;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>在函数式中所有的函数都可以被写成尾递归的形式然后进一步优化——这是因为尾递归函数的栈帧可以被优化掉。比如:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">let</span> fact_tr n = </span><br><span class="line">&gt; 	<span class="keyword">let</span> <span class="keyword">rec</span> f n acc = </span><br><span class="line">&gt; 		<span class="keyword">if</span> n = <span class="number">0</span> <span class="keyword">then</span> acc <span class="keyword">else</span> f (n - <span class="number">1</span>) (n * acc)</span><br><span class="line">&gt; 	<span class="keyword">in</span></span><br><span class="line">&gt; 		f n <span class="number">1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="data-types-and-pattern-matching">Data Types and Pattern Matching</h4>
<blockquote>
<p>这一节可以在<code>Ocaml</code>中定义自己的递归/非递归的数据类型。</p>
<p><code>Ocaml</code>使用<code>type</code>来定义<strong>有限无序的非递归集合</strong>，这里举一个扑克牌的例子:</p>
</blockquote>
<blockquote>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">type</span> suit = <span class="type">Clubs</span> | <span class="type">Spades</span> | <span class="type">Hearts</span> | <span class="type">Diamonds</span>;;</span><br><span class="line">&gt; <span class="keyword">type</span> suit = <span class="type">Clubs</span> | <span class="type">Spades</span> | <span class="type">Hearts</span> | <span class="type">Diamonds</span></span><br><span class="line">&gt; # <span class="keyword">type</span> rank = <span class="type">Two</span> | <span class="type">Three</span> | <span class="type">Four</span> | <span class="type">Five</span> | <span class="type">Six</span> | <span class="type">Seven</span> | <span class="type">Eight</span> | <span class="type">Nine</span> | <span class="type">Ten</span> | <span class="type">Jack</span> | <span class="type">Queen</span> | <span class="type">King</span> | <span class="type">Ace</span>;;</span><br><span class="line">&gt; # <span class="keyword">type</span> card = rank * suit;;</span><br><span class="line">&gt; <span class="keyword">type</span> card = rank * suit</span><br><span class="line">&gt; # <span class="keyword">type</span> hand = <span class="type">Empty</span> | <span class="type">Hand</span> <span class="keyword">of</span> card * hand;;</span><br><span class="line">&gt; <span class="keyword">type</span> hand = <span class="type">Empty</span> | <span class="type">Hand</span> <span class="keyword">of</span> card * hand</span><br><span class="line">&gt; # <span class="keyword">let</span> <span class="keyword">rec</span> dom (s1, s2) = <span class="keyword">match</span> (s1, s2) <span class="keyword">with</span> </span><br><span class="line">&gt; | (<span class="type">Spades</span>, _) -&gt; <span class="literal">true</span></span><br><span class="line">&gt; | (<span class="type">Hearts</span>, <span class="type">Diamonds</span>)  -&gt; <span class="literal">true</span></span><br><span class="line">&gt; | (s1, s2) -&gt; s1 = s2</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><code>Ocaml</code>使用<code>pattern matching</code>模式匹配来操作这些数据结构。这里有两个概念——<code>patterns</code>和<code>constructors</code>。每一个<code>pattern</code>由不同的<code>constructors</code>填充——这里的构造器指的是每一个和类型元素同名的构造器比如<code>Clubs</code>。<code>Ocaml</code>规定构造器首字母必须大写，且匹配是从上到下的顺序。</p>
<p>进一步的，为了简化代码而支持<code>inductively</code>的<code>deep pattern</code>构造形式如下:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">let</span> <span class="keyword">rec</span> add c1 c2 = <span class="keyword">match</span> c1 c2 <span class="keyword">with</span></span><br><span class="line">&gt;   | (<span class="type">Hearts</span>, v1), (<span class="type">Hearts</span>, v2) -&gt; v1 + v2</span><br><span class="line">&gt;   | _, _ -&gt; <span class="number">0</span>;;</span><br><span class="line">&gt; <span class="keyword">val</span> add : (<span class="symbol">'a</span> -&gt; (suit * <span class="built_in">int</span>) * (suit * <span class="built_in">int</span>)) -&gt; <span class="symbol">'a</span> -&gt; <span class="built_in">int</span> = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这里会发现构造了一个比较复杂的类型<code>('a -&gt; (suit*int)*(suit*int)) -&gt; 'a -&gt; int</code>。其中<code>type1 * type2</code>为一个<code>pair</code>，而`<code>a</code>为任意类型。</p>
<p>上述函数的基本类型推导过程为两个任意类型为输入参数，<code>int</code>为输出。其中任意类型为<code>(suit*int)*(suit*int)</code>的。</p>
<p>上面扑克牌的例子中<code>hand</code>定义一组<strong>无限递归集合</strong>。在<code>hand</code>类型中，<code>Empty</code>和<code>Hand</code>分别为两个<code>constructors</code>。<code>Empty</code>没有输入参数，而<code>Hand</code>以<code>a tuple of a card and another hand</code>的一个<code>tuple</code>为输入参数。看下面的实例化例子:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">let</span> hand0: hand = <span class="type">Empty</span></span><br><span class="line">&gt; <span class="keyword">let</span> hand1: hand = <span class="type">Hand</span>((<span class="type">Ace</span>, <span class="type">Hearts</span>), <span class="type">Empty</span>)</span><br><span class="line">&gt; <span class="keyword">let</span> hand2: hand = <span class="type">Hand</span>((<span class="type">Queen</span>, <span class="type">Diamonds</span>), hand1)</span><br><span class="line">&gt; <span class="keyword">let</span> hand3:hand = </span><br><span class="line">&gt; <span class="type">Hand</span>((<span class="type">Ace</span>, <span class="type">Spades</span>),</span><br><span class="line">&gt; 			<span class="type">Hand</span>((<span class="type">Ten</span>, <span class="type">Diamonds</span>), </span><br><span class="line">&gt; 					<span class="type">Hand</span>((<span class="type">Seven</span>, <span class="type">Clubs</span>),</span><br><span class="line">&gt; 							<span class="type">Hand</span>((<span class="type">Queen</span>, <span class="type">Spades</span>),</span><br><span class="line">&gt; 									<span class="type">Hand</span>((<span class="type">Eight</span>, <span class="type">Clubs</span>), <span class="type">Empty</span>)))));;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这个<code>hand</code>类型实际上就是一棵退化的二叉树（只能靠右生长）——叶子是<code>Empty</code>， 而<code>Hand</code>构造器使用两个参数来建树。</p>
<p>下面我们定义一个函数，这里函数的类型是<code>suit -&gt; hand -&gt; hand</code>，功能是给定一个<code>suit -&gt; hand</code>的输入，然后从<code>hand</code>中找有匹配到<code>suit</code>类型的<code>hand</code>然后返回。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">let</span> <span class="keyword">rec</span> extract (s:suit) (h:hand) = <span class="keyword">match</span> h <span class="keyword">with</span> </span><br><span class="line">&gt; 	| <span class="type">Empty</span> -&gt; <span class="type">Empty</span></span><br><span class="line">&gt; 	| <span class="type">Hand</span> ((_, s') <span class="keyword">as</span> c, h') -&gt;</span><br><span class="line">&gt; 		<span class="keyword">if</span> s = s' <span class="keyword">then</span> <span class="type">Hand</span>(c, extract s h')</span><br><span class="line">&gt; 		<span class="keyword">else</span> extract s h'</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>上一个函数中的<code>Empty</code>实际上就是一个终结符，意味着如果<code>hand</code>类型都不匹配的话就直接返回<code>Empty</code>。但是如果我要匹配一个<code>card</code>的话，没有匹配上该怎么返回呢？<code>Ocaml</code>引入一个<code>optional data type</code>。比如下面的函数:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; # <span class="keyword">type</span> <span class="symbol">'a</span> option = <span class="type">None</span> | <span class="type">Some</span> <span class="keyword">of</span> <span class="symbol">'a</span></span><br><span class="line">&gt; <span class="keyword">type</span> <span class="symbol">'a</span> option = <span class="type">None</span> | <span class="type">Some</span> <span class="keyword">of</span> <span class="symbol">'a</span></span><br><span class="line">&gt; # <span class="keyword">let</span> <span class="keyword">rec</span> find (r, h) = <span class="keyword">match</span> h <span class="keyword">with</span></span><br><span class="line">&gt; 	| <span class="type">Empty</span>  -&gt; <span class="type">None</span></span><br><span class="line">&gt; 	| <span class="type">Hand</span>((r', s'), h') -&gt; <span class="keyword">if</span> r = r' <span class="keyword">then</span> <span class="type">Some</span> s'</span><br><span class="line">&gt; 													<span class="keyword">else</span> find(r, h')</span><br><span class="line">&gt; <span class="keyword">val</span> find: rank * hand -&gt; suit option = &lt;<span class="keyword">fun</span>&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>其中<code>option type</code>表示由<code>Some</code>构造器实现的类型为`<code>a</code>的元素集合，是符合多态的任意类型。</p>
</blockquote>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/Ocaml/">Ocaml</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-link" href="/tags/FP/">FP</a>, <a class="article-tag-link" href="/tags/PL/">PL</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2021/05/02/NJU静态程序分析-0-Introduction/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          NJU静态程序分析(0-Introduction)
        
      </div>
    </a>
  
  
    <a href="/2021/02/16/Lisp语言和Emacs/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Lisp语言和Emacs
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->

</body>
</html>
