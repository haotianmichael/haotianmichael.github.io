<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>NJU静态程序分析(2-CHA-Analysis) | CodeSaw</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/css/highlight.css">
  
  <meta name="description" content="Abstract  根据safe-approximation，过程内数据流分析Intraprocedural对所有的函数调用method call做出过度保守的假设——即所有分析结果必须safe，而根据Lattice理论这种处理会使must和may分析都变的less precise。所以引入过程间数据流分析Interprocedural Analysis，通过Call Graph来实现过程间的数据">
<meta name="keywords" content="PL,Software-Analysis">
<meta property="og:type" content="article">
<meta property="og:title" content="NJU静态程序分析(2-CHA-Analysis)">
<meta property="og:url" content="http://haotianmcihael.github.io/2021/05/10/NJU静态程序分析-2-CHA-Analysis/index.html">
<meta property="og:site_name" content="CodeSaw">
<meta property="og:description" content="Abstract  根据safe-approximation，过程内数据流分析Intraprocedural对所有的函数调用method call做出过度保守的假设——即所有分析结果必须safe，而根据Lattice理论这种处理会使must和may分析都变的less precise。所以引入过程间数据流分析Interprocedural Analysis，通过Call Graph来实现过程间的数据">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://haotianmcihael.github.io/2021/05/10/NJU静态程序分析-2-CHA-Analysis/1.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2021/05/10/NJU静态程序分析-2-CHA-Analysis/2.png">
<meta property="og:image" content="http://haotianmcihael.github.io/2021/05/10/NJU静态程序分析-2-CHA-Analysis/3.png">
<meta property="og:updated_time" content="2022-03-06T10:36:45.810Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NJU静态程序分析(2-CHA-Analysis)">
<meta name="twitter:description" content="Abstract  根据safe-approximation，过程内数据流分析Intraprocedural对所有的函数调用method call做出过度保守的假设——即所有分析结果必须safe，而根据Lattice理论这种处理会使must和may分析都变的less precise。所以引入过程间数据流分析Interprocedural Analysis，通过Call Graph来实现过程间的数据">
<meta name="twitter:image" content="http://haotianmcihael.github.io/2021/05/10/NJU静态程序分析-2-CHA-Analysis/1.png"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">CodeSaw</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      <article id="post-NJU静态程序分析-2-CHA-Analysis" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      NJU静态程序分析(2-CHA-Analysis)
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2021-05-10T10:23:58.000Z" itemprop="datePublished">2021-05-10</time>

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <h3 id="abstract">Abstract</h3>
<blockquote>
<p>根据<code>safe-approximation</code>，过程内数据流分析<code>Intraprocedural</code>对所有的函数调用<code>method call</code>做出过度保守的假设——即所有分析结果必须<code>safe</code>，而根据<code>Lattice</code>理论这种处理会使<code>must</code>和<code>may</code>分析都变的<code>less precise</code>。所以引入<strong>过程间数据流分析</strong><code>Interprocedural Analysis</code>，通过<code>Call Graph</code>来实现过程间的数据流传递，从而进一步提高分析的精度。<strong>因此如何构造这些<code>call-graph</code>就是过程间分析的关键环节。</strong></p>
<p>For Better precision, we need Interprocedural Analysis：propagate data-flow information along <strong>interprocedural control-flow edges</strong> i.e., call and return edges</p>
<p><code>Class hierarchy analysis</code>是用来构造<code>Call Graph</code>的一种经典方法——也是过程间分析的基础。</p>
</blockquote>
<a id="more"></a>
<h3 id="cha">CHA</h3>
<blockquote>
<p>从下面开始我们开始研究包含函数调用的程序——调用图反映了程序中的调用关系<code>calling relationships</code>，确切的说就是<strong>一系列从调用点<code>call-sites</code>指向目标方法<code>callees</code>的边的集合</strong>，可以看出<code>Call Graph</code>是极其重要的程序信息。</p>
<p>如何构造<code>Call Graph</code>？鉴于<code>OOPLs</code>语言是目前软件领域绝对的领导者，因此本节课也主要针对<code>Java</code>来构造调用图。一共有四种构造算法:</p>
<ul>
<li>Class hierarchy analysis(CHA)</li>
<li>Rapid type analysis(RTA)</li>
<li>Variable type analysis(VTA)</li>
<li>Pointer analysis(k-CFA)</li>
</ul>
<p>它们的分析精度从上到下越来越准确，而分析时间也相应的越来越长，这里主要介绍第一种CHA。</p>
<h4 id="methods-callsinvocations-in-java">Methods Calls(invocations) in Java</h4>
<table>
<colgroup>
<col style="width: 12%">
<col style="width: 10%">
<col style="width: 46%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Static call</th>
<th>Special call</th>
<th>Virtual call</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Instruction</td>
<td>Invokestatic</td>
<td>Invokespecial</td>
<td>Invokeinterface/invokevirtual</td>
</tr>
<tr class="even">
<td>Receiver objects</td>
<td>⨉</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr class="odd">
<td>Target methods</td>
<td>Static methods</td>
<td>constructors/private instance methods/superclass instance methods</td>
<td>Other instance methods</td>
</tr>
<tr class="even">
<td>#Target methods</td>
<td>1</td>
<td>1</td>
<td>≥1(<font color="red">polymorphism</font>)</td>
</tr>
<tr class="odd">
<td>Determinacy</td>
<td>Compile-time</td>
<td>Compile-time</td>
<td>Run-time</td>
</tr>
</tbody>
</table>
<p>Java的函数调用主要分为三种类型。其中<code>static call</code>调用静态方法因此没有<code>instance</code>实例，而编译器在编译期就可以解析出函数地址。<code>special call</code>有三个目标函数——构造函数，私有成员函数以及父类函数，因为该调用的<code>receiver object</code>类型确定所以也可以再编译期确定。难点在于虚函数调用，<strong>所谓运行时绑定指的是只有在运行时才可以确定其目标函数（多态），</strong>因此构造调用图的关键就在于对虚函数调用完成构建。</p>
<h4 id="method-dispatch">Method Dispatch</h4>
<p>一个虚函数调用<font color="blue">o<sup>1</sup>.foo(...)<sup>2</sup></font>在运行时根据两点被解析：</p>
<ul>
<li><code>Receiver object</code>的类型，即变量o指向的对象类型</li>
<li>在<code>call site</code>的函数签名，即foo(...)</li>
</ul>
<p>关于对象类型，是变量指向的实际类型——比如<code>A x = new B()</code>和<code>B x = new B()</code>的<code>receiver objecte</code>类型都是<code>B</code>。关于函数签名<code>signatrue</code>的功能就是能唯一代表一个函数：</p>
<ul>
<li>Signatrue = <font color="red">class type</font> + <font color="blue">method name</font> + <font color="green">descriptor</font></li>
<li><font color="green">Descriptor</font> = <font color="green">return type</font> + <font color="green">parameter types</font></li>
</ul>
<p>比如<code>class C{T foo(P p, Q q, R r){...}}</code> 中函数foo的函数签名可以写成<code>C.foo(P, Q, R)</code>。</p>
<p>接着引入函数<font color="red">Dispatch</font>(c, m)来模拟运行时函数自动绑定的过程：</p>
<p><img src="1.png" width="50%" height="50%" alt=""></p>
<p>其中<code>c</code>是<code>receiver object</code>的类型，而<code>m</code>就是<code>call sites</code>的函数签名。<code>Dispatch</code>函数在<code>c</code>中寻找和函数签名<code>m</code>相符合的<strong>非抽象函数<code>non-abstract method</code></strong>，如果没有找到则去<code>c</code>的父类中继续找直到找到为止，该函数是CHA分析的核心。</p>
<h4 id="cha-1">CHA</h4>
<p><code>CHA</code>是Jeffrey Dean在ECOOP上提出来的一种优化算法<a href="https://www.researchgate.net/profile/David-Grove/publication/2509356_Optimization_of_Object-Oriented_Programs_Using_Static_Class_Hierarchy_Analysis/links/0912f50b6c1a600bb9000000/Optimization-of-Object-Oriented-Programs-Using-Static-Class-Hierarchy-Analysis.pdf?origin=publication_detail" target="_blank" rel="noopener">Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis</a>。</p>
<p><strong>该算法可以根据<code>receiver object</code>的声明类型（区别于实际类型）来解析虚函数调用。</strong>它需要整个程序的继承链作为信息基础，比如<code>A a = ...;  a.foo()</code>中该算法假设变量<code>a</code>可以指向<code>class  A</code>及其所有子类，据此解析出多个可能的目标方法。下面是CHA的算法:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Resolve</span>(cs) &#123;</span><br><span class="line">&gt; 	<span class="type">T</span> = &#123;&#125;</span><br><span class="line">&gt; 	m = method signature at cs</span><br><span class="line">&gt; 	<span class="keyword">if</span> cs is a static call <span class="keyword">then</span></span><br><span class="line">&gt; 		<span class="type">T</span> = &#123;m&#125;</span><br><span class="line">&gt; 	<span class="keyword">if</span> cs is special call <span class="keyword">then</span></span><br><span class="line">&gt; 		c_m = <span class="keyword">class</span> <span class="class"><span class="keyword">type</span> of m</span></span><br><span class="line">&gt; 		<span class="type">T</span> = &#123;<span class="type">Dispatch</span>(c_m, m)&#125;</span><br><span class="line">&gt; 	<span class="keyword">if</span> cs is a virtual call <span class="keyword">then</span></span><br><span class="line">&gt; 		c = declared <span class="class"><span class="keyword">type</span> of receiver variable at cs</span></span><br><span class="line">&gt; 		foreach c' that is a subclass <span class="keyword">of</span> c or c itself <span class="keyword">do</span></span><br><span class="line">&gt; 			add <span class="type">Dispatch</span>(c', m) to <span class="type">T</span></span><br><span class="line">&gt; 	return <span class="type">T</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这里对<code>Java</code>的三种调用类型都做了解析，参数<code>cs</code>是程序中的调用点——即每一种调用实际发生的地方。<code>static call</code>可以直接根据函数签名得到目标函数；对于<code>special call</code>由于进行<code>super-call</code>调用的时候需要进一步解析父类中的函数（还不能保证父类一定存在函数需要进一步上升）所以使用了<code>Dispatch</code>函数。</p>
<p><strong>虚函数调用只需要拿到在<code>call-site</code>处<code>receiver variable</code>的声明类型，然后对该类型以及该类型的所有子类对象做Dispatch解析即可。</strong></p>
<p>该算法只考虑调用点处<code>reveriver variable</code>的类型和它的继承链而忽略了其他数据流和控制流信息，因此速度上非常快，但是精度一般。故其主要应用就是IDE的补全上，满足速度快贴合需求但是精度也保持在一个很好的接受范围内。</p>
<h4 id="call-graph-construction">Call Graph Construction</h4>
<p>在CHA分析的基础上，我们可以设计出构造调用图<code>Call Graph</code>的完整算法，该算法应用<code>BFS</code>的思路从<code>entry</code>出发对每一个<code>method</code>，解析该函数在所有调用点<code>cs</code>的目标方法<code>Resolve(cs)</code>直到所有的<code>method</code>都完成解析。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">BuildCallGraph</span>(m_entry) &#123;</span><br><span class="line">&gt; 	<span class="type">WL</span> = [m_entry], <span class="type">CG</span> = &#123;&#125;, <span class="type">RM</span> = &#123;&#125;</span><br><span class="line">&gt; 	while <span class="type">WL</span> is not empty <span class="keyword">do</span></span><br><span class="line">&gt; 		remove m from <span class="type">WL</span></span><br><span class="line">&gt; 		<span class="keyword">if</span> m ∉ <span class="type">RM</span> <span class="keyword">then</span></span><br><span class="line">&gt; 			add m to <span class="type">RM</span></span><br><span class="line">&gt; 			foreach call-site cs <span class="keyword">in</span> th m <span class="keyword">do</span>     // <span class="type">Resolve</span> target methods via <span class="type">CHA</span></span><br><span class="line">&gt; 				<span class="type">T</span> = <span class="type">Resolve</span>(cs)</span><br><span class="line">&gt; 				foreach traget method m' <span class="keyword">in</span> <span class="type">T</span> <span class="keyword">do</span></span><br><span class="line">&gt; 					add cs ⟶ m' to <span class="type">CG</span>    // <span class="type">Add</span> call edges to call graph</span><br><span class="line">&gt; 					add m' to <span class="type">WL</span></span><br><span class="line">&gt; 		return <span class="type">CG</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>其中：</p>
<ul>
<li>WL包含即将被解析的<code>method</code></li>
<li>CG包含构建出来的调用边<code>call-edges</code>集合</li>
<li>RM包含已经解析完成的<code>method</code></li>
</ul>
</blockquote>
<h3 id="inter-procedural-control-flow-graph">Inter-procedural Control-Flow Graph</h3>
<blockquote>
<p>构建<code>Call Graph</code>的目的就是为了进一步构建<code>ICFG</code>，如果说<code>CFG</code>表示单个函数的结构，那<code>ICFG</code>表示的就是整个程序的结构。有了<code>ICFG</code>我们就可以进行过程间分析了，<code>ICFG</code>主要由两部分构成:</p>
<ul>
<li>程序中所有函数的CFG</li>
<li>两种新加的edges
<ul>
<li>Call edges: 从<code>call-site</code>指向<code>callees</code>的<code>entry</code></li>
<li>Return edges: 从<code>callees</code>的返回语句指向<code>return-site</code>(紧跟着<code>call-site</code>的语句)</li>
</ul></li>
</ul>
<p><img src="2.png" width="50%" height="50%" alt=""></p>
<p>而这两种新加的边信息就来自于<code>Call Graph</code>。对于整个程序的<code>ICFG</code>，只需要将函数调用语句单独作为一个<code>Basic Block</code>即可，其他的不变。</p>
<p>从上图中可以看到，数据流从<code>call-site</code>沿着<code>call edges</code>流向<code>callees</code>，接着从<code>callees</code>的返回语句流向<code>return-site</code>。<strong>而<code>call-site</code>和<code>return-site</code>之间还有一条边<code>call-to-return edge</code>是为了传递本地函数的数据流，</strong>以免这些信息跟着<code>call graph</code>绕远路。</p>
</blockquote>
<h3 id="inter-procedural-data-flow-analysis">Inter-procedural Data-Flow Analysis</h3>
<blockquote>
<p>在构建好<code>ICFG</code>之后，就可以进行过程间数据流分析了。</p>
<p>这里对比过程内<code>Intraprocedural</code>和<code>Interprocedural</code>两种分析：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><font color="red">Intra</font>procedural</th>
<th><font color="red">Inter</font>procedural</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Program representation</td>
<td>CFG</td>
<td>ICFG = CFGs + <font color="red">call &amp; return edges</font></td>
</tr>
<tr class="even">
<td>Transfer functions</td>
<td>Node transfer</td>
<td>Node transfer + <font color="red">edge transfer</font></td>
</tr>
</tbody>
</table>
<p>可以看到过程间分析比过程内分析多了一些<code>edge analysis</code>。从理论上看这些<code>edge analysis</code>完成了函数调用过程中的跨函数数据流比如参数，返回值的传递。</p>
<ul>
<li>Call edge transfer: 传递参数（从call-site到entry of callee）</li>
<li>Return edge transfer: 传递返回值(从return ofcallee到return-site)</li>
</ul>
<p>而过程间分析和过程内分析的<code>Transfer Function</code>相比，多了一条规则：</p>
<p>For each call node(call-site), kill data-flow value for the LHS variable. Its value will flow to return site along the return edges.</p>
<p>即要<code>kill</code>掉调用点语句的<strong>左值变量</strong>。</p>
<p><img src="3.png"" width="50%" height="50%" alt=""></p>
<p>因为左值的数据流会在<code>callee</code>中得到更新最终沿着<code>return edge</code>传递，而如果该值在<code>call-to-return edge</code>中继续传递下去，在<code>merge</code>的时候回损失精度比如常量传播中c<sub>1</sub> ⊓ c<sub>2</sub> = NAC。故拿常量传播来说的话，<code>Interprocedural constant propagation</code>要比<code>Intraprocedural constant propagation</code>更加精确。</p>
</blockquote>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/Java/">Java</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-link" href="/tags/PL/">PL</a>, <a class="article-tag-link" href="/tags/Software-Analysis/">Software-Analysis</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2021/05/14/NJU静态程序分析-3-Pointer-Analysis/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          NJU静态程序分析(3-Pointer-Analysis)
        
      </div>
    </a>
  
  
    <a href="/2021/05/04/NJU静态程序分析-1-Data-Flow-Analysis/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          NJU静态程序分析(1-Data Flow Analysis)
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->

</body>
</html>
