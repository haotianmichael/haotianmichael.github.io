<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeSaw</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haotianmcihael.github.io/"/>
  <updated>2022-03-16T10:24:50.818Z</updated>
  <id>http://haotianmcihael.github.io/</id>
  
  <author>
    <name>HaotianMichael</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT6.824(Spring 2021)-MapReduce</title>
    <link href="http://haotianmcihael.github.io/2022/01/03/MIT6-824-Spring-2021-MapReduce/"/>
    <id>http://haotianmcihael.github.io/2022/01/03/MIT6-824-Spring-2021-MapReduce/</id>
    <published>2022-01-03T14:29:59.000Z</published>
    <updated>2022-03-16T10:24:50.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>最近终于有时间研究一下MIT的<a href="https://pdos.csail.mit.edu/6.824/schedule.html" target="_blank" rel="noopener">神课</a><code>6.824</code>。</p><p>这门课教<code>Distributed System</code>，即多台物理隔离的计算机通过网络来协调，共同完成一致性任务，可以是计算任务，也可以是存储任务。</p><p><strong>分布式系统</strong>和单机相比，除了有很多高并发的<code>Partial Failures</code>，更多的是硬件老化，断电，网卡失灵等这种现实问题。因此设计低成本高性能系统以及处理并发和网络问题——<strong><code>Performance</code>性能和<code>Fault Tolerance</code>容错</strong>是这门课的核心。</p><p>课程共有20个<code>Lectures</code>和4个<code>labs</code>。和<code>6.828</code>一样重视实践——<strong>看论文，查资料，做<code>lab</code></strong>~简单粗暴。所以学习过程基本上就按照如下推进：</p><ul><li>提前看<code>Lecture</code>要求的<code>papers</code></li><li>听<a href="https://www.bilibili.com/video/BV1R7411t71W?spm_id_from=333.999.0.0" target="_blank" rel="noopener">对应</a>的<code>Lectures</code></li><li>查找<code>lab</code>相关的学习资料</li><li>做<code>lab</code></li></ul><p>之前做<code>6.828</code>的时候就发现我在做这种<strong>学习过程很长，思考内容又很深</strong>的课程训练时很容易钻牛角尖而让自己乱了节奏，思维如若不能放松下来效果肯定不会太好——希望这次能尽量调整过来。</p><a id="more"></a><h3 id="paper">Paper</h3><p>论文<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">MapReduce:Simplified Data Processing on Large Clusters</a>是关于Google已经淘汰掉的<strong>大规模数据集处理编程架构<code>MapReduce</code></strong>。当时的Google面临在多台机器上的大规模数据集处理比如计算<code>PageRank</code>或者对所有文件进行<code>grep</code>等。</p><p>而统一化编程模型可以很好的抽象掉因为大规模集群导致的<strong>并行，网络，容错</strong>等问题——将这些细节隐藏起来，只留一个供程序员使用的编程接口可以大大提高开发效率。而工业级<code>MapReduce</code>的本质就是一个<strong>利用普通机器组成的大规模计算集群进行并行，高容错，高性能的大数据处理函数框架。</strong></p><h4 id="理论模型">理论模型</h4><p>理论模型借鉴于<code>Lisp</code>语言中的<code>map/reduce</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">map</span><span class="params">(<span class="built_in">string</span> key, <span class="built_in">string</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//key:  文档名</span></span><br><span class="line"><span class="comment">//value: 文档内容</span></span><br><span class="line"><span class="keyword">for</span> each word w in value:</span><br><span class="line">EmitIntermediate(w, <span class="string">"1"</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reduce</span> <span class="params">(<span class="built_in">string</span> key, Iterator values)</span> </span>&#123;</span><br><span class="line"><span class="comment">//key: 一个单词</span></span><br><span class="line"><span class="comment">//value: 计数值列表</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> each v in value:</span><br><span class="line">result  += ParseInt(v);</span><br><span class="line">Emit(toString(result));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里两个函数模型的类型分别是:</p><ul><li>map: (k1, v1) —&gt; list(k2, v2)</li><li>reduce: (k2, list(v)) —&gt; list(v2)</li></ul><p>对于一个<code>map</code>操作，将<code>key</code>文档中的内容按照一定方式读取，并统计其中的<code>w</code>项的频率<code>value</code>并输出到一个中间文件上。而<code>reduce</code>从中间文件中读取并迭代其<code>lists</code>，将对应的<code>key</code>项统计。</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>这一模型可以很好的处理并行化操作——<strong>因为<code>map</code>的过程可以在多台机器上并行完成而没有依赖。<code>reduce</code>过程也是。但是整体<code>reduce</code>和<code>map</code>之间存在着顺序依赖关系即必须是相应的<code>map</code>操作结束才可以唤醒<code>reduce</code>操作。</strong></p><p>这样的话所有的依赖和协调过程都被隐藏在<code>map</code>和<code>reduce</code>函数的<strong>数据分发</strong>之间，而开发者可以完全不用考虑分布式细节而单独编写这两个函数以达到自己的目的。</p><h4 id="实现">实现</h4><p>从实现角度看系统的很多行为是由<code>MapReduce</code>内置的库完成的。这里有几个容易混淆的概念：</p><ul><li><code>user program</code>：用户程序，会被多次<code>fork</code>成为<code>master</code>和<code>worker</code><br></li><li><p><code>master</code>: 主节点，用来将<code>task</code>分配给相应的<code>worker</code>，记录工作节点的当前状态和声明周期</p></li><li><code>task</code>：<code>map</code>任务或者<code>reduce</code>任务，由相应的<code>worker</code>完成</li><li><code>worker</code>: 工作节点，用来完成相应的<code>task</code></li><li><p><code>user-defined map/reduce</code>: 开发者自定义的<code>map/reduce</code>函数</p></li></ul><p><img src="2.png" width="50%" height="50%" alt=""></p><h5 id="输入预处理">输入预处理</h5><p>首先库函数会将输入文件切分成<code>M</code>份，并在一个集群的若干台机器上启动程序的多个副本。副本中除了有一个作为主节点，其他都是工作节点。</p><p>主节点将M个map任务R个reduce任务分配给空闲的工作节点（理解<code>task</code>在被分配给<code>worker</code>后两者是一个意思）。</p><h5 id="map工作节点区分工作节点和用户函数">map工作节点（区分工作节点和用户函数）</h5><p>每一个被分配map的工作节点需要读取相应内容并解析出<code>key/value</code>对，<strong>并将这些作为参数提供给用户自定义的map函数，</strong>而函数输出的中间结果缓存在内存中。</p><p>缓存的中间<code>key/value</code>对会被划分为R块并写入本地磁盘，而这些数据对在磁盘中的相应位置会被传回主节点——由主节点再传给相应的reduce工作节点。</p><h5 id="reduce工作节点区分工作节点和用户函数">reduce工作节点（区分工作节点和用户函数）</h5><p>保证map操作结束后，主节点唤醒reduce工作节点并告知其中间输出的磁盘位置。reduce工作节点使用RPC调用获取这些中间数据。<strong>当reduce读取完所有的数据，需要按照key对其进行排序，是为了最后迭代器统计计数提供前置条件。</strong>最后reduce工作节点迭代排好序的中间数据，并将每一个中间key和它关联一组中间value传递给用户定义的reduce函数。</p><h5 id="shuffle过程核心状态机">shuffle过程（核心状态机）</h5><p>整个map和reduce之间的数据shuffle是系统分布式的核心，关键就是map生成的中间文件及其命名。</p><p><img src="3.png" width="50%" height="50%" alt=""></p><p>如上图，假设有5个map工作节点和3个reduce工作节点。</p><ul><li>map工作节点的输出分为3类，分别由<code>R0</code>，<code>R1</code>和<code>R2</code>处理，<strong>当map的解析函数一致时，相同的key一定被分到了同一个中间文件中。</strong>即<code>0-0.txt</code>、<code>1-0.txt</code>和<code>0-2.txt</code>三个文件中<code>key</code>类型的交集是空集。</li><li><code>md5(key)%R</code>计算map最终输出落入到哪个中间文件</li><li>中间文件命名：map任务编号-reduce任务编号</li></ul><p>因此5个map操作结束后会生成5*3的中间文件矩阵。</p><ul><li>map结束后，3个reduce工作节点通过RPC分别获取矩阵的每一列文件数据</li></ul><p>比如R0调用<code>0-0.txt、1-0.txt、2-0.txt、3-0.txt、4-0.txt</code>。因为同一列中类型相同，所以只需要内部排序。</p><p>所谓<code>shuffle</code>就是map/reduce对中间文件的行列操作，其结果是将中间文件进一步处理成为<code>&lt;value, list&lt;key&gt;&gt;</code>作为用户定义reduce函数的输入进行计数统计。</p><h5 id="最终输出">最终输出</h5><p>reduce工节点处理完计数后，将结果输出到磁盘上作为下一次<code>MapReduce</code>的输入。</p><h4 id="工业级处理">工业级处理</h4><p>在框架实现的过程中出现了很多的细节。Google在将<code>MapReduce</code>工业化落地的过程中也将这些影响系统<strong>性能</strong>和<strong>可靠性</strong>的主要因素进行了优化——而一个优秀的系统本身就是在实践中不断迭代出来的，这里简单概括一下，不做详细讨论。</p><h5 id="容错">容错</h5><p><strong>分布式容错的本质就是如何在不可靠的硬件上构建可靠的软件。</strong>因为是大规模集群，所以很难避免<code>Partial Failure</code>——从实现角度看就是各个节点的容错。</p><ul><li>主节点：主节点奔溃之后会coredump到一个恢复文件中，重启后可以从最近的恢复点重新执行MapReduce</li><li>工作节点：奔溃后一般都要将当前的task重新分配到一个节点完成<ul><li>map：输出是一个中间文件所以符合原子提交即后面的任务会将文件覆盖</li><li>reduce：其输出是一个持久性的文件所以需要重命名一个新的文件防止冲突</li></ul></li></ul><h5 id="加速">加速</h5><p>当出现大规模的机器节点时，很多性能问题会成为优化的方向。比如进一步优化网络和磁盘性能。</p><ul><li>局部性：在分布式系统中，输入文件传到map节点，map中间文件传到reduce节点都需要网络带宽。可以考虑将map直接分配到本地磁盘上等操作增加并行性。</li><li>任务粒度：M个map节点，R个reduce节点。分配太多节点导致网络带宽不够，分配太少导致并行度不够。</li><li>负载均衡：不同的工作节点性能也不同，如果系统卡在最后几个节点导致负载过高花费时间过长，就会让整个系统处于不平衡的状态。</li></ul><h3 id="lecture12">Lecture1~2</h3><h4 id="go语言环境配置">go语言环境配置</h4><p>作为一个<code>VIM</code>重度用户我已经不用IDE很多年了。就自行配置了<code>Vim-Go</code>开发环境。</p><h5 id="go安装配置">Go安装配置</h5><p>我用<code>MacOs Catalina</code>环境，下载安装就不说了。主要关注<code>Go</code>环境变量，需要写入相应的<code>SHELL</code>配置文件中，我的在<code>.zshrc</code>中：</p><ul><li><code>GOROOT</code>: Go语言的安装目录，一般是<code>/usr/local/go</code></li><li><code>GOPATH</code>: 工作区即写代码的目录，一般分为三个子目录：<ul><li><code>src</code><br></li><li><code>bin</code></li><li><code>pkg</code></li></ul></li><li><code>GOBIN</code>: 存放GO语言可执行文件的目录（这里的可执行文件主要指通过<code>go get</code>下载并编译好的库，供直接调用的）</li><li><code>PATH</code>: 需要将当前的可执行文件目录放到PATH下面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意&quot;&quot;的使用</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=~/go/golib:~/go/goproject    #这里设置了两个工作区</span><br><span class="line">export GOBIN=~/go/gobin</span><br><span class="line">export PATH=&quot;$GOROOT/bin:$GOBIN:$PATH&quot;</span><br></pre></td></tr></table></figure><h5 id="镜像">镜像</h5><p>因为Github和Go官网不太好用，所以使用镜像来下载需要的库比较方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Mac/Linux环境下</span><br><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><h5 id="二进制工具">二进制工具</h5><p><code>vim-go</code>是一个开发<code>go</code>的<code>vim</code>插件。我使用<code>vundle</code>包管理工具来管理<code>vim</code>插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如何使用vundle自行Google</span><br><span class="line">Plugin &apos;fatih/vim-go&apos;</span><br></pre></td></tr></table></figure><p>因为这个插件启动还需要一些和二进制工具，具体的列表可打开<code>&quot;~/.vim/bundle/vim-go/plugin/go.vim&quot;</code>如下：</p><p><img src="4.png" width="50%" height="50%" alt=""></p><p>常规做法是在<code>vim</code>命令行模式下面直接执行<code>:GoInstallBinaries</code>来自动安装。如果没有安装代理的话尽管有镜像还是很容易出错，所以我的做法是一个一个从官网上<code>go get</code>然后<code>go insatll</code>手动安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/go-delve/delve/cmmd/dlv     #从官网上直接下载二进制工具</span><br><span class="line">$ go install github.com/go-delve/delve/cmmd/dlv@laatest   #使用go install手动安装</span><br></pre></td></tr></table></figure><p>如果按照前面的方式配置好了环境变量，那这些二进制工具就会被安装在<code>~/go/gobin</code>目录下。验证方式就是打开<code>vim</code>之后不会有插件报错信息。</p><h3 id="lab1">Lab1</h3><h3 id="to-conclude">To conclude</h3><p>在学习过程用到的资料列举如下:</p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/" target="_blank" rel="noopener">MIT6.824中文翻译</a></p><p><a href="https://go-zh.org/doc/" target="_blank" rel="noopener">Go文档</a></p><p><a href="https://book.itsfun.top/gopl-zh/" target="_blank" rel="noopener">Go语言圣经</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;最近终于有时间研究一下MIT的&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;神课&lt;/a&gt;&lt;code&gt;6.824&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这门课教&lt;code&gt;Distributed System&lt;/code&gt;，即多台物理隔离的计算机通过网络来协调，共同完成一致性任务，可以是计算任务，也可以是存储任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式系统&lt;/strong&gt;和单机相比，除了有很多高并发的&lt;code&gt;Partial Failures&lt;/code&gt;，更多的是硬件老化，断电，网卡失灵等这种现实问题。因此设计低成本高性能系统以及处理并发和网络问题——&lt;strong&gt;&lt;code&gt;Performance&lt;/code&gt;性能和&lt;code&gt;Fault Tolerance&lt;/code&gt;容错&lt;/strong&gt;是这门课的核心。&lt;/p&gt;
&lt;p&gt;课程共有20个&lt;code&gt;Lectures&lt;/code&gt;和4个&lt;code&gt;labs&lt;/code&gt;。和&lt;code&gt;6.828&lt;/code&gt;一样重视实践——&lt;strong&gt;看论文，查资料，做&lt;code&gt;lab&lt;/code&gt;&lt;/strong&gt;~简单粗暴。所以学习过程基本上就按照如下推进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提前看&lt;code&gt;Lecture&lt;/code&gt;要求的&lt;code&gt;papers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;听&lt;a href=&quot;https://www.bilibili.com/video/BV1R7411t71W?spm_id_from=333.999.0.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应&lt;/a&gt;的&lt;code&gt;Lectures&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查找&lt;code&gt;lab&lt;/code&gt;相关的学习资料&lt;/li&gt;
&lt;li&gt;做&lt;code&gt;lab&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前做&lt;code&gt;6.828&lt;/code&gt;的时候就发现我在做这种&lt;strong&gt;学习过程很长，思考内容又很深&lt;/strong&gt;的课程训练时很容易钻牛角尖而让自己乱了节奏，思维如若不能放松下来效果肯定不会太好——希望这次能尽量调整过来。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://haotianmcihael.github.io/categories/Golang/"/>
    
    
      <category term="Distributed System" scheme="http://haotianmcihael.github.io/tags/Distributed-System/"/>
    
      <category term="MapReduce" scheme="http://haotianmcihael.github.io/tags/MapReduce/"/>
    
      <category term="MIT6.824" scheme="http://haotianmcihael.github.io/tags/MIT6-824/"/>
    
  </entry>
  
  <entry>
    <title>Type system, a Sketchy view.</title>
    <link href="http://haotianmcihael.github.io/2021/06/16/Type-system-a-Sketchy-view/"/>
    <id>http://haotianmcihael.github.io/2021/06/16/Type-system-a-Sketchy-view/</id>
    <published>2021-06-15T18:02:32.000Z</published>
    <updated>2022-03-16T10:35:29.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p><code>Type system</code>的基本目的是防止在程序运行时发生<code>execution error</code>。这种<code>Informal statement</code>即非形式化描述有很多内涵：首先该如何严格定义<code>execution error</code>；其次在这种定义下，描述<code>absence of execution error</code>也是<code>Type syatem</code>很<code>nontrivial</code>的性质——当一套编程语言的所有运行时行为都能确保这种性质的话，我们就说该语言是<code>type sound</code>的。事实证明为了更加没有歧义的描述编程语言的<code>type soundness</code>，需要做大量的分析和证明。因此针对<code>Type system</code>的分类，描述和研究过程逐渐演变成为一套<code>formal discipline</code>即形式化体系。 <span class="math display">\[\frac{\Gamma_{1} \vdash \Im_{1}  ...  \Gamma_{n} \vdash \Im_{n}}{\Gamma \vdash \Im}\]</span></p><p><code>The formalization of Type system</code>需要一套精确的符号和定义系统，以便对这些形式属性进行严格的证明以确保其正确性。但是应该务实，直觉主义——即形式化的目的不能以牺牲<code>Type system</code>的易用性和流畅性为代价。这样的设计不仅可以避免各式各样的运行时陷阱，而且可以促进语言设计的<code>regularity</code>和<code>orthogonality</code>。</p><p>一个<strong>严格正确</strong>的<code>Type system</code>可以对一门语言定义的各个重要性质进行<strong>完整</strong>的判断。而非形式化的描述甚至做不到完整概括语言的<code>type structure</code>则更谈不上实现上的唯一性。比如不同的编译器对于同一套语言<code>Type system</code>的实现往往不尽相同，甚至有一些<code>type unsound</code>的语言定义导致一段代码明明通过<code>typechecker</code>的检查但在运行时奔溃掉。理想情况下我们说<code>formal Type system</code>应该是所有<code>typed programming languages</code>内核定义的一部分。这样的话，<code>typechecking</code>算法就可以严格按照精确的类型<code>spec</code>执行，从某种程度上该语言可以看成是<code>Type sound</code>的。</p><a id="more"></a><h3 id="introduction">Introduction</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Type system&lt;/code&gt;的基本目的是防止在程序运行时发生&lt;code&gt;execution error&lt;/code&gt;。这种&lt;code&gt;Informal statement&lt;/code&gt;即非形式化描述有很多内涵：首先该如何严格定义&lt;code&gt;execution error&lt;/code&gt;；其次在这种定义下，描述&lt;code&gt;absence of execution error&lt;/code&gt;也是&lt;code&gt;Type syatem&lt;/code&gt;很&lt;code&gt;nontrivial&lt;/code&gt;的性质——当一套编程语言的所有运行时行为都能确保这种性质的话，我们就说该语言是&lt;code&gt;type sound&lt;/code&gt;的。事实证明为了更加没有歧义的描述编程语言的&lt;code&gt;type soundness&lt;/code&gt;，需要做大量的分析和证明。因此针对&lt;code&gt;Type system&lt;/code&gt;的分类，描述和研究过程逐渐演变成为一套&lt;code&gt;formal discipline&lt;/code&gt;即形式化体系。 &lt;span class=&quot;math display&quot;&gt;\[
\frac{\Gamma_{1} \vdash \Im_{1}  ...  \Gamma_{n} \vdash \Im_{n}}{\Gamma \vdash \Im}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;The formalization of Type system&lt;/code&gt;需要一套精确的符号和定义系统，以便对这些形式属性进行严格的证明以确保其正确性。但是应该务实，直觉主义——即形式化的目的不能以牺牲&lt;code&gt;Type system&lt;/code&gt;的易用性和流畅性为代价。这样的设计不仅可以避免各式各样的运行时陷阱，而且可以促进语言设计的&lt;code&gt;regularity&lt;/code&gt;和&lt;code&gt;orthogonality&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一个&lt;strong&gt;严格正确&lt;/strong&gt;的&lt;code&gt;Type system&lt;/code&gt;可以对一门语言定义的各个重要性质进行&lt;strong&gt;完整&lt;/strong&gt;的判断。而非形式化的描述甚至做不到完整概括语言的&lt;code&gt;type structure&lt;/code&gt;则更谈不上实现上的唯一性。比如不同的编译器对于同一套语言&lt;code&gt;Type system&lt;/code&gt;的实现往往不尽相同，甚至有一些&lt;code&gt;type unsound&lt;/code&gt;的语言定义导致一段代码明明通过&lt;code&gt;typechecker&lt;/code&gt;的检查但在运行时奔溃掉。理想情况下我们说&lt;code&gt;formal Type system&lt;/code&gt;应该是所有&lt;code&gt;typed programming languages&lt;/code&gt;内核定义的一部分。这样的话，&lt;code&gt;typechecking&lt;/code&gt;算法就可以严格按照精确的类型&lt;code&gt;spec&lt;/code&gt;执行，从某种程度上该语言可以看成是&lt;code&gt;Type sound&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
      <category term="𝛌" scheme="http://haotianmcihael.github.io/categories/%F0%9D%9B%8C/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Type System" scheme="http://haotianmcihael.github.io/tags/Type-System/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(5-IFDS-And-Soundiness)</title>
    <link href="http://haotianmcihael.github.io/2021/06/06/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-5-IFDS/"/>
    <id>http://haotianmcihael.github.io/2021/06/06/NJU静态程序分析-5-IFDS/</id>
    <published>2021-06-06T15:54:46.000Z</published>
    <updated>2022-03-16T09:57:13.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abastract">Abastract</h3><p>在<code>IFDS</code>出现之前，经典<code>intra-procedural analysis</code>框架(<font color="red">D</font>,<font color="green">L</font>,<font color="blue">F</font>)对于程序分析问题的研究还停留在①多项式时间处理<code>specific individual problem</code>比如<code>constant propagation/pointer analysis</code>②多项式时间处理<code>locally separable proble</code>（经典<code>bit-vector/gen-kill</code>问题——<code>reaching definitions,available expressions,live variabl</code>的过程间分析）③对普遍分析问题提供<strong>非多项式时间</strong>的算法方案。</p><p>随着<code>POPL'1995</code>发表的<a href="http://web.cs.ucla.edu/~harryxu/courses/253/sp2013/papers/popl95.pdf" target="_blank" rel="noopener">Precise Interprocedural Dataflow Analysis via Graph Reachability</a>通过将一类<code>inter-procedural analysis</code>问题转化为<code>a special kind of graph-reachability problem</code>图可达性问题——<font color="red"><code>IFDS</code></font>框架横空出世。<strong><code>IFDS</code>除了针对<code>separable problems</code>，还针对包括<code>truly-live variables,copy constant propagation,possibly-uninitialized variablestruly-live variables</code>在内的<code>non-separable problems</code>等一大类普遍性分析问题都提供了多项式时间的精确解决手段。</strong>由于<code>IFDS</code>本身的约束，作者在<code>Theoretical Computer Science'1996</code>上还发表过一篇<a href="https://pdf.sciencedirectassets.com/271538/1-s2.0-S0304397500X00448/1-s2.0-0304397596000722/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJIMEYCIQDHEEjOJdEm0cLtUB%2BHaJKZnI%2BPN5tMP4ElOR%2FgbYtzIgIhAJLujFNrXghpU6i4dLJlbR4WmRz%2FBokVzMrouNR8thheKvoDCEMQBBoMMDU5MDAzNTQ2ODY1IgwWTLJMo41Prpn%2F%2FEgq1wPGTtVLFsiVIF9uO3Jqe%2Fc7DNIZ2aCoMKASRnKPldZG3DL%2Fkla1b4JCb1utfraGJZeeG8LZFHTKpNPPAfY8Ax4cYe2D2fM1efeJUEv%2FGD2v21Ge7INGhUegLgtSJXoz%2FTGqXHronY0wS56U4dQHPyuDJ9pJYu8tQi5bCN93m1E%2BvoIrIoPK1IBlinh9LCUHfggCjlfJcrUWdkz6FvAO9pGlBB2bSWVrDJQZhf6k8%2FEA5%2BXg3GaNvYrHvzSnNokhfIAooqmnr9POzK6%2B3%2Fx0h%2Bs4dh9hNMSBVThSuNZlmYyRaRKHAukdzlgx7Lu9cQrKYEbMA9sr6UbY1CBGWM0IkEQ7hmxoPj3%2BkLlagNcZRd2FVg7zQcCPjdYrEeuUM6FicieZyU64gwrF%2Fl2Jq9GQPaZpYcndiEruIB8ggW%2F6moNCZs2IDLW40fNnp3Hm32GGMPuJDgPa9Yg7iD9Rfrr7uPhjSB8oKcpFqUKwmYqMn4W6pM74elsDHPsbw%2FsaqXNJCU42md6tfWSTBmByS3IQHgs6NpJWs3QckjVDmQYfTXv%2FgpMfrR%2FVnq7q6gGUgGrsgttCWa9VagHvZlUoLrIsFwlkjVjx7LNyflLfYyQBjsMjVKKQ7qw9kLMwrfi2kQY6pAGC4F0%2Bu4eJObfe5rQlGYJgI2OFVr6PyiBiTn4XcTtHOC2fbkj4Rre9Pj4QydLxF0oSXJqJCXkBJhzxpC9ouKJpDzYffbmPkpIA6rzdujGyRGluGCeiM2cOu7JtFEx1nvPsB%2BLlMN8JJBJQL3QWxnV36yu6ycImjADRWzn2Oe1Hn59BdoZO9nzL8zTLFHgS9jRZeYlTJQnh6FZe4I4upbqHwxemIw%3D%3D&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Date=20220313T104326Z&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Expires=300&amp;X-Amz-Credential=ASIAQ3PHCVTY3WOOQG6M%2F20220313%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Signature=d189220faa10689b60977d689048eeee379847ff107227365fec1a7742463d7d&amp;hash=c12a21daeaec6fe0aaf5b9fb5ec0259bf755743c2eea8ab65f566cece9ee2d36&amp;host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&amp;pii=0304397596000722&amp;tid=spdf-17632b09-bb7d-4bc0-9605-080c373f0575&amp;sid=d0b19308547fc443ae8b53f5ca290b286a01gxrqa&amp;type=client&amp;ua=50040252510d525a5a05&amp;rr=6eb42b298d006da7" target="_blank" rel="noopener">Precise interprocedural dataflow analysis with applications to constant propagation</a>提出<code>IDE</code>框架来处理<code>interprocedural constant propagation</code>等<code>IFDS</code>框架处理不了的<code>non-distributive</code>问题。这两篇论文为程序分析领域引入新的血液。</p><p>近年<code>Sparse Value IFDS,Disk-Assisted IFDS</code>等课题一直是学术界的研究热点。在工业界比如<a href="https://linkspringer.53yu.com/content/pdf/10.1007%2F978-3-030-17465-1.pdf" target="_blank" rel="noopener">phasar</a>等程序分析工具中<code>IFDS/IDE</code>也有具体<a href="https://github.com/secure-software-engineering/phasar" target="_blank" rel="noopener">实现</a>。</p><a id="more"></a><h3 id="cfl-reachability">CFL-Reachability</h3><p>首先介绍图可达性的概念。</p><h4 id="feasible-and-realizable-paths">Feasible and Realizable Paths</h4><p>过程间数据流分析真正用于工程落地之后的复杂度往往是很高的，即<code>ICFG</code>的边出现路劲爆炸导致分析速度变慢。究其根本原因，是因为在这些<code>edges</code>中有一些属于不可达边——<code>Infeasible paths</code>。</p><p>Paths in CFG that do not correspond to actual executions is Infeasible paths.</p><p>如果我们能够尽可能的防止<code>CFG</code>被<code>Infeasible paths</code>所污染，让分析流图边的更加简洁，势必大大提升分析速度。<strong>但是实际情况下这种<code>infeasible paths</code>往往无法判定。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo(int age) &#123;    //age只会是Positive，所以一条分支肯定不会被执行</span><br><span class="line">if(age &gt;= 0) </span><br><span class="line">r = age;</span><br><span class="line">else </span><br><span class="line">r = -1;  //但是程序在静态时该条路径无法判定其可执行性</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="realizable-paths">Realizable Paths</h5><p>The paths in which &quot;returns&quot; are matched with corresponding &quot;calls&quot;.</p><p>如果一条调用边，其return-edge可以正确匹配到其call-edge，则称这条边是<code>realizable</code>的。<strong>既然<code>infeasible</code>不可判定，便引入其子集——因为<code>realizable paths</code>可能不会被执行到，但是<code>unrealizable paths</code>则一定不会被执行到，而<code>unrealizable paths</code>则是可判定的。</strong></p><p><img src="1.png" width="50%" height="50%" alt=""></p><p><strong>寻找这样的<code>realizable paths</code>来是<code>IFDS</code>顺利执行的前提，</strong>下面引入一种系统的方式识别<code>realizable paths</code>——<code>CFL-Reachability</code>。</p><h4 id="cfl-reachabiligy">CFL-Reachabiligy</h4><p>A path is considered to connect two nodes A and B, or<font color="red"> B is reachable from A</font>. Only if the concatenation of the labels on the edges of the path is a word in a specified <font color="red">context-free language</font>.</p><p>对于A和B两个<code>node</code>之间有一条<code>path</code>（一系列<code>edge</code>组成的，换句话说B可达A）并且这条<code>path</code>上的所有<code>edge</code>的<code>labels</code>构成的单词是<strong>由事先规定的context-free language定义好的合法单词的话，</strong>就说<font color="red">B is CFL-Reachable from A.</font></p><h5 id="context-free-grammer">context-free grammer</h5><p>上下文无关语言<code>context-free language</code>指的是由上下文无关文法<code>context-free grammer</code>产生的语言。</p><p>上下文无关文法是一种形式语言用于描述某种语法，它的主要形式就是：S ⟶ 𝞪. 这是一种产生式。S代表非终结符而𝞪代表一系列终结符或者空格。比如CFG的文法如下的话：</p><ul><li>S ⟶ aSb</li><li>S ⟶ ℇ</li></ul><p>这里的𝞪就是<code>aSb/ℇ</code>，上下文无关<code>context-free</code>的意思就是说在<strong>任何出现S的地方</strong>都可以使用<code>aSb/ℇ</code>来替换。</p><h5 id="partially-balanced-parenthesis-problem">Partially Balanced-Parenthesis Problem</h5><p>将寻找<code>realizable paths</code>抽象成为典型的括号匹配问题。这里的<code>Partially</code>指的是)<sub>i</sub>一定会有一个(<sub>i</sub>匹配，换句话讲就是说对于每一个<code>return-edge</code>都有会有一个<code>call-edge</code>匹配，但是每一个<code>call-edge</code>却不一定有返回值（比如<code>realizable but not infeasiable paths</code>）。<strong>问题的整个建模过程为：对<code>control-flow graph</code>上的所有<code>edge</code>都加上一个<code>label</code>，对于一个<code>call</code>语句<code>i</code>，其<code>call-edge</code>被标记为(<sub>i</sub>其<code>return-edge</code>被标记为)<sub>i</sub>，而其余所有的<code>edge</code>都被标记为<code>e</code>。</strong></p><p>A path is a realizable path if thee path' word is in the language L(realizable).比如</p><ul><li><font color="green">(<sub>1</sub>(<sub>2 </sub>e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub></font></li><li><font color="green">(<sub>1</sub>(<sub>2 </sub>e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub>(<sub>4</sub></font></li><li><font color="green">(<sub>1</sub>(<sub>2 </sub>e e e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub>(<sub>4</sub></font></li><li><font color="blue">e e</font><font color="green">(<sub>1</sub>(<sub>2 </sub>e e e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub>(<sub>4</sub></font> <font color="blue">e</font></li></ul><p>则根据括号匹配设计的上下文无关文法如下：</p><p><font color="blue">realizable</font> ⟶ <font color="green">mathched</font> <font color="blue">realizable</font></p><p>​ ⟶ <font color="red">(<sub>i</sub></font> <font color="blue">realizable</font></p><p>​ ⟶ <font color="blue">ℇ</font></p><p><font color="green">mathched</font> ⟶ <font color="red">(<sub>i</sub></font> <font color="green">mathched</font> <font color="red">)<sub>i</sub></font></p><p>​ ⟶ <font color="blue">e</font></p><p>​ ⟶ <font color="blue">ℇ</font></p><p>​ ⟶ <font color="green">mathched matched</font></p><p><img src="2.png" width="50%" height="50%" alt=""></p><h3 id="ifds">IFDS</h3><p><code>IFDS</code>是<code>Interprocedural，Finite，Distributive，Subset Problems</code>的简称。总结来就说：IFDS is for interprocedural data flow analysis with <font color="red">distributive</font> flow functions over <font color="red">finite</font> domains.</p><p><code>IFDS</code>将一大类数据流分析问题转化成为了图可达性问题进行处理，相比较于迭代数据流框架提供了多项式时间的精确处理。但是<code>IFDS</code>必须在一定的约束下才可以：</p><p>很多普遍的数据流分析问题都是<code>subset problem</code>——集合的<code>union/intersection</code>等；而<code>Interprocedural</code>指的是全程序分析；<strong>而该分析问题还有必须有一个<code>distributive flow function</code>并且其<code>domains</code>还是<code>finite</code>才可以用<code>IFDS</code>来处理。</strong></p><p>就比如<code>constant propagation</code>就不可以用<code>IFDS</code>处理，因为其<code>domains</code>是理论上所有的常数所以是<code>Infinite</code>，而且该分析本身也不是<code>Distributive</code>。</p><h4 id="overview-of-ifds">Overview of IFDS</h4><h5 id="mrp">MRP</h5><p>跟<code>Intra-procedural analysis</code>使用<code>meet-over-all-paths</code>来衡量分析的精度一样，<code>IFDS</code>也使用<code>meet-over-all-realizable-paths</code>来衡量其分析精度。</p><p>根据MOP<sub>n</sub> = ⊔<font color="green">(p∊Paths(start, n))</font>pf<sub>p</sub>(⊥)的定义，对于每一个<code>node</code>点n，MOP<sub>n</sub>表示在<code>CFG</code>上的<code>start</code>点到<code>node</code>点n所有的<code>paths</code>的<code>union/intersection</code>操作。</p><p>而根据MRP<sub>n</sub> = ⊔<font color="green">(p∊RPaths(start, n))</font>pf<sub>p</sub>(⊥)的定义，对于每一个<code>node</code>点n，MRP<sub>n</sub>表示在<code>CFG</code>上的<code>start</code>点到<code>node</code>点n所有的<font color="red">realizable paths（这些paths的label构成的word符合<code>realizalble</code>语言的上下文无关文法）</font>的<code>union/intersection</code>操作。</p><p>根据两个精度计算方式的定义可以看出，MRP<sub>n</sub>对那些<code>unrealizable paths</code>进行了剪枝优化，因此其结果也比MOP<sub>n</sub>更精确——MRP<sub>n</sub> ≼ MOP<sub>n</sub>。</p><h5 id="algorithm">Algorithm</h5><p>首先从总体上概括一下<code>IFDS</code>的算法框架：</p><p>输入：程序<code>P</code>，数据流分析问题<code>Q</code></p><ul><li>为程序<code>P</code>建立<code>superGraph G*</code>，并根据分析问题<code>Q</code>为<code>G*</code>的每一个<code>edge</code>定义<code>flow functions（使用𝛌表达式）</code>(可以对比<code>intra-procedural analysis</code>为每一个<code>node</code>建立<code>flow functinos</code>)</li><li>通过将<code>flow functions</code>转化为<code>representation relations</code>（一种子图）的形式来建立程序<code>P</code>的<code>exploded supergraph G#</code></li><li>最后在<code>G#</code>上应用<code>tabulations algorithm</code>就可以将程序<code>Q</code>的分析问题当做图可达性问题从而求解（找到<code>MRP solutions</code>）</li></ul><p><font color="purple">Let n be a program point, data fact d ∊ MRP<sub>n</sub>, iff there is a realizable path in G# from &lt;S<sub>main</sub>, 0&gt; to &lt;n, d&gt;.</font></p><p><img src="3.png" width="50%" height="50%" alt=""></p><h4 id="supergraph-and-flow-functions">SuperGraph and Flow Functions</h4><h5 id="supergraph">SuperGraph</h5><p>引入<code>supergraph G* = (N*, E*)</code>， 对于过程间数据流分析，每一个<code>procedure</code>都是一个控制流图<code>G</code>，每一个<code>G</code>都有一个自己的<code>start node</code><font color="blue">s<sub>p </sub></font>和<code>exit node</code><font color="blue">e<sub>p</sub></font>。<code>IFDS</code>框架处理的全程序的<code>superGraph G*</code>就是这些控制流图的集合{G<sub>1</sub>, G<sub>2</sub>....}。</p><p>过程间分析最重要的<code>procedure call</code>则需要一个<code>node</code>点<font color="red">Call<sub>p</sub></font>和一个<code>node</code>点 <font color="red">Ret<sub>p</sub></font>。<code>G*</code>对于每一个<code>procedure call</code>都需要三条边：</p><ul><li><code>intra-procedural call-to-return-site edge</code>：<font color="red">Call<sub>p </sub></font> ⟶ <font color="red">Ret<sub>p</sub></font></li><li><code>inter-procedural call-to-start edge</code>: <font color="red">Call<sub>p </sub></font> ⟶ <font color="blue">s<sub>p </sub></font></li><li><code>inter-procedural exit-to-return-site edge</code>: <font color="blue">e<sub>p</sub></font> ⟶ <font color="red">Ret<sub>p</sub></font></li></ul><h5 id="flow-functions">Flow Functions</h5><p>设计<code>flow function</code>是根据具体的程序分析问题，使用<code>𝛌-expression</code>表示的。</p><h4 id="exploded-supergraph-and-tabulation-algorithm">Exploded Supergraph and Tabulation Algorithm</h4><h5 id="exploded-supergraph">Exploded SuperGraph</h5><p>通过将<code>flow function</code>转换成为<code>representation relations</code>子图来建造<code>exploded superGraph G#</code>。</p><p>每一个<code>flow function</code>被一个<code>2(D + 1)</code>个<code>node</code>组成的<code>Graph</code>代表，<font color="blue">其中<code>D</code>表示的是一个<code>dataflow facts</code>的<strong>有限集合</strong>。</font></p><p><img src="4.png" width="50%" height="50%" alt=""></p><p>这里的<code>representation relation</code>R<sub>f</sub> ⊆ (D ⋃ 0) X (D ⋃ 0)，符合如下规则：</p><ul><li>{0, 0} <code>Edge</code>: <font color="red">0 ⟶ 0</font></li><li>{(0, y)|y∊f(∅)} <code>Edge:</code> <font color="red">0 ⟶ d<sub>1</sub></font></li><li>{(x, y)| y∉f(∅) and y∊f({x})} <code>Edge</code>: <font color="red">d<sub>1</sub> ⟶ d<sub>2</sub></font></li></ul><p>其中<code>0</code>和<code>0</code>之间自动连一条边；如果在没有输入的情况下输出为<code>y</code>则自动连一条<code>0</code>到d<sub>1</sub>的边；如果输入为<code>x</code>而输出是<code>f</code>并且输入为∅的时候的输出不为<code>y</code>，则需要在两个<code>dataflow facts</code>之间连一条边。</p><p>在将<code>superGraph G*</code>转化为<code>exploded superGraph G#</code>的过程中：和传统数据流分析不一样的是——其中的<code>edge</code>代表了一个<code>flow functino</code>。所以在转化时候<code>G*</code>的每一个<code>node</code>都被转化成为<code>D+1</code>个<code>nodes</code>，而一条<code>edge</code>分别连接的两个<code>D+1</code>个<code>nodes</code>（故一个<code>flow function</code>被转化为<code>2(D+1)个node</code>组成的子图）共同被转化成为<code>representation relation</code>子图。</p><h5 id="edge-00">Edge 0⟶0</h5><p>对于一个特定的数据流分析问题，它有<code>D</code>个<code>data facts</code>。但是在构造<code>exploded superGraph</code>的时候为什么一个<code>node</code>需要转换成为<code>D + 1</code>个<code>nodes</code>呢？</p><p>回顾一下传统的数据流分析，如果想要确定一个<code>program point</code>是否还保持一个<code>data fact</code>比如<code>definition</code>是否是<code>reachable</code>的，我们需要判断从程序入口到该<code>program point</code>的流动中该<code>data fact</code>是否会传播到该点。</p><p><img src="5.png" width="50%" height="50%" alt=""></p><p>即OUT[p] = f4○f3○f2○f1(IN[n1])。准确的说<strong>Data facts are propagated via the composition of flow functions.</strong>——这里最重要的是一个<strong>composition</strong>的概念，实际上对于<code>IFDS</code>框架来说，如何在如图可达性问题中实现这种连接，否则会导致整个分析的结果无法沿着<code>edge</code>进行传播，而<code>Glue Edge:0⟶0</code>便解决了这个问题。</p><h5 id="tabulation-algorithm">Tabulation Algorithm</h5><p>最后一步在构建好<code>G#</code>之后，最终在其上应用<code>Tabulation</code>算法来寻找从&lt;S<sub>main</sub>, 0&gt;开始的所有<code>realizable paths</code>来决定该分析问题的所有<code>MRP solutions</code>。</p><p>理解一下整个算法的核心：</p><p><font color="purple">Let n be a program point, data fact d ∊ MRP<sub>n</sub>, iff there is a realizable path in G# from &lt;S<sub>main</sub>, 0&gt; to &lt;n, d&gt;.</font></p><p>首先解释&lt;S,d&gt;指的是在<code>program point</code>点S的一个<code>data fact</code>即<code>d</code>。如果对于一个<code>program point</code>点<code>n</code>，如果在<code>G#</code>上可以从&lt;S<sub>main</sub>, 0&gt;到&lt;<font color="red">n</font>,<font color="blue">d</font>&gt;有一条<code>realizable path</code>——则就说<code>data fact d</code>在<code>program point n</code>这一点是holds的。</p><p>关于该算法的核心暂时不深入理解。比如这里的<code>summary</code>思想也是为了处理同一个方法被冗余处理。</p><h4 id="distributivity">Distributivity</h4><p>这里我们了解一下<code>IFDS</code>的可分配性<code>Distributivity</code>：</p><ul><li>F(X ^ Y) = F(X) ^ F(Y)</li></ul><p>而根据定义，对于处理<code>constant propagation</code>来说比如<code>z = x + y</code>，需要同时考虑两个输入，<strong>而<code>IFDS</code>一次只能处理一个输入:F(x)^F(y)。本质上每一个<code>representation relation</code>只能处理如果<code>x</code>存在则...，但是无法处理如果<code>x and y</code>同时存在则...。</strong>故常量传播是不可分配的。</p><p>In IFDS, each data fact(circle) and its propagation(edges) could be handled independently, and doing so will affect the correctness of the final results.</p><p>就是说其<code>data fact</code>和<code>edge</code>都是可以分开处理，到最后一步才进行<code>union/intersection</code>——即可分配性。而<code>Pointer analysis</code>因为需要处理别名<code>alias</code>信息，这样的话需要考虑多个输入信息——故其本质上也不是可分配性的。</p><h3 id="soundiness">Soundiness</h3><p>虽然所有的程序分析算法都在强调其可以捕捉到所有的程序运行时行为。但是学术界和工业界的理论和工具在实际应用中都会产生<code>unsound</code>的结果。<strong>这是因为编程语言本身会有一些<code>Hard Feature</code>导致程序分析无法进行。</strong></p><ul><li>Java: Reflection，native code，dynamic class loading ...</li><li>C/C++: Pointer arithmetic, function pointer...</li></ul><p>这些特性使得程序分析精度受损。故学术界引入一个新词<code>Soundiness</code>表示：</p><p>A soundy analysis typically means that the analysis is mostly sound, with well-identified unsound treatments to hard/specific language features.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abastract&quot;&gt;Abastract&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;IFDS&lt;/code&gt;出现之前，经典&lt;code&gt;intra-procedural analysis&lt;/code&gt;框架(&lt;font color=&quot;red&quot;&gt;D&lt;/font&gt;,&lt;font color=&quot;green&quot;&gt;L&lt;/font&gt;,&lt;font color=&quot;blue&quot;&gt;F&lt;/font&gt;)对于程序分析问题的研究还停留在①多项式时间处理&lt;code&gt;specific individual problem&lt;/code&gt;比如&lt;code&gt;constant propagation/pointer analysis&lt;/code&gt;②多项式时间处理&lt;code&gt;locally separable proble&lt;/code&gt;（经典&lt;code&gt;bit-vector/gen-kill&lt;/code&gt;问题——&lt;code&gt;reaching definitions,available expressions,live variabl&lt;/code&gt;的过程间分析）③对普遍分析问题提供&lt;strong&gt;非多项式时间&lt;/strong&gt;的算法方案。&lt;/p&gt;
&lt;p&gt;随着&lt;code&gt;POPL&#39;1995&lt;/code&gt;发表的&lt;a href=&quot;http://web.cs.ucla.edu/~harryxu/courses/253/sp2013/papers/popl95.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Precise Interprocedural Dataflow Analysis via Graph Reachability&lt;/a&gt;通过将一类&lt;code&gt;inter-procedural analysis&lt;/code&gt;问题转化为&lt;code&gt;a special kind of graph-reachability problem&lt;/code&gt;图可达性问题——&lt;font color=&quot;red&quot;&gt;&lt;code&gt;IFDS&lt;/code&gt;&lt;/font&gt;框架横空出世。&lt;strong&gt;&lt;code&gt;IFDS&lt;/code&gt;除了针对&lt;code&gt;separable problems&lt;/code&gt;，还针对包括&lt;code&gt;truly-live variables,copy constant propagation,possibly-uninitialized variablestruly-live variables&lt;/code&gt;在内的&lt;code&gt;non-separable problems&lt;/code&gt;等一大类普遍性分析问题都提供了多项式时间的精确解决手段。&lt;/strong&gt;由于&lt;code&gt;IFDS&lt;/code&gt;本身的约束，作者在&lt;code&gt;Theoretical Computer Science&#39;1996&lt;/code&gt;上还发表过一篇&lt;a href=&quot;https://pdf.sciencedirectassets.com/271538/1-s2.0-S0304397500X00448/1-s2.0-0304397596000722/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJIMEYCIQDHEEjOJdEm0cLtUB%2BHaJKZnI%2BPN5tMP4ElOR%2FgbYtzIgIhAJLujFNrXghpU6i4dLJlbR4WmRz%2FBokVzMrouNR8thheKvoDCEMQBBoMMDU5MDAzNTQ2ODY1IgwWTLJMo41Prpn%2F%2FEgq1wPGTtVLFsiVIF9uO3Jqe%2Fc7DNIZ2aCoMKASRnKPldZG3DL%2Fkla1b4JCb1utfraGJZeeG8LZFHTKpNPPAfY8Ax4cYe2D2fM1efeJUEv%2FGD2v21Ge7INGhUegLgtSJXoz%2FTGqXHronY0wS56U4dQHPyuDJ9pJYu8tQi5bCN93m1E%2BvoIrIoPK1IBlinh9LCUHfggCjlfJcrUWdkz6FvAO9pGlBB2bSWVrDJQZhf6k8%2FEA5%2BXg3GaNvYrHvzSnNokhfIAooqmnr9POzK6%2B3%2Fx0h%2Bs4dh9hNMSBVThSuNZlmYyRaRKHAukdzlgx7Lu9cQrKYEbMA9sr6UbY1CBGWM0IkEQ7hmxoPj3%2BkLlagNcZRd2FVg7zQcCPjdYrEeuUM6FicieZyU64gwrF%2Fl2Jq9GQPaZpYcndiEruIB8ggW%2F6moNCZs2IDLW40fNnp3Hm32GGMPuJDgPa9Yg7iD9Rfrr7uPhjSB8oKcpFqUKwmYqMn4W6pM74elsDHPsbw%2FsaqXNJCU42md6tfWSTBmByS3IQHgs6NpJWs3QckjVDmQYfTXv%2FgpMfrR%2FVnq7q6gGUgGrsgttCWa9VagHvZlUoLrIsFwlkjVjx7LNyflLfYyQBjsMjVKKQ7qw9kLMwrfi2kQY6pAGC4F0%2Bu4eJObfe5rQlGYJgI2OFVr6PyiBiTn4XcTtHOC2fbkj4Rre9Pj4QydLxF0oSXJqJCXkBJhzxpC9ouKJpDzYffbmPkpIA6rzdujGyRGluGCeiM2cOu7JtFEx1nvPsB%2BLlMN8JJBJQL3QWxnV36yu6ycImjADRWzn2Oe1Hn59BdoZO9nzL8zTLFHgS9jRZeYlTJQnh6FZe4I4upbqHwxemIw%3D%3D&amp;amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Date=20220313T104326Z&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Expires=300&amp;amp;X-Amz-Credential=ASIAQ3PHCVTY3WOOQG6M%2F20220313%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Signature=d189220faa10689b60977d689048eeee379847ff107227365fec1a7742463d7d&amp;amp;hash=c12a21daeaec6fe0aaf5b9fb5ec0259bf755743c2eea8ab65f566cece9ee2d36&amp;amp;host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&amp;amp;pii=0304397596000722&amp;amp;tid=spdf-17632b09-bb7d-4bc0-9605-080c373f0575&amp;amp;sid=d0b19308547fc443ae8b53f5ca290b286a01gxrqa&amp;amp;type=client&amp;amp;ua=50040252510d525a5a05&amp;amp;rr=6eb42b298d006da7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Precise interprocedural dataflow analysis with applications to constant propagation&lt;/a&gt;提出&lt;code&gt;IDE&lt;/code&gt;框架来处理&lt;code&gt;interprocedural constant propagation&lt;/code&gt;等&lt;code&gt;IFDS&lt;/code&gt;框架处理不了的&lt;code&gt;non-distributive&lt;/code&gt;问题。这两篇论文为程序分析领域引入新的血液。&lt;/p&gt;
&lt;p&gt;近年&lt;code&gt;Sparse Value IFDS,Disk-Assisted IFDS&lt;/code&gt;等课题一直是学术界的研究热点。在工业界比如&lt;a href=&quot;https://linkspringer.53yu.com/content/pdf/10.1007%2F978-3-030-17465-1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;phasar&lt;/a&gt;等程序分析工具中&lt;code&gt;IFDS/IDE&lt;/code&gt;也有具体&lt;a href=&quot;https://github.com/secure-software-engineering/phasar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;实现&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(4-Taint-Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/06/03/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-4-Taint-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/06/03/NJU静态程序分析-4-Taint-Analysis/</id>
    <published>2021-06-02T16:33:35.000Z</published>
    <updated>2022-03-16T09:59:27.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>同符号执行一样，<code>Taint-Analysis</code>也是分析代码安全漏洞，检测攻击方式的重要手段。对于<code>Web</code>应用程序中存在着的大量安全漏洞,如跨站脚本攻击，<code>SQL</code>注入等~污点分析都可以进行有效地检测。而污点传播技术是当前<code>Taint-Analysis</code>领域的重要课题，<strong>通过和静态程序分析技术相结合，在不运行代码且不修改代码的前提下通过分析程序变量之间的相互依赖关系以此获得更高效，更精确的分析结果。</strong></p><p>Taint analysis tracks how tainted data flow through the program and observes if they can flow to locations of interest(call sinks).</p><p>比如通过利用静态指针分析算法完成简化的显式流<code>explicit flow</code>分析，不讨论<a href="https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" target="_blank" rel="noopener">路径爆炸</a>和其他动态漏洞分析技术。</p><a id="more"></a><h3 id="information-flow-security">Information Flow Security</h3><p>当服务器和客户机在网络上进行通信的时候就会存在<code>Information Flow</code>，从而产生了相应的安全问题——Prevent unwanted information flow。如何防止客户端的信息不被流入到黑客手中，目前主流有两种途径：</p><h4 id="access-control">Access Control</h4><p>通过使用<strong>权限</strong>的方式来控制程序是否可以访问敏感数据，主要是通过管理<strong>如何获取数据</strong>的方式来完成数据保护，但是它仅仅可以保证获取时的保护，但是获取到数据之后呢？</p><h4 id="information-flow-security-1">Information Flow Security</h4><p><font color="red">信息流安全</font>是一种<code>end to end</code>的数据保护方式，它追踪信息流是如何在程序中流动的来确保程序能更安全的处理敏感数据，主要是通过管<strong>如何传播数据</strong>的方式来完成数据保护。</p><p>这两种方式共同作用，才可以真正保证敏感数据的安全。</p><p>下面介绍信息流的概念:如果在变量<code>x</code>中的信息被传入到了变量<code>y</code>中，那么在<code>x——&gt;y</code>之间就有信息流。而实现信息流安全实际上还需要两种方式：</p><h5 id="security-levels">security levels</h5><p>通过将信息流分为不同的等级来控制数据的获取权限，最基本的模型就是<code>two-level policy</code>，分为<code>H</code>和<code>L</code>两个级别，<code>H</code>指的是安全等级高的敏感信息，<code>L</code>指的是敏感信息低的可公开信息。比如</p><ul><li><code>h = getPassword();</code> h为<code>H</code></li><li><code>Broadcast(l);</code> l为<code>L</code></li></ul><p>对于更复杂的数据模型，安全等级实际上可以按照<code>lattice</code>来进行建模。</p><h5 id="information-flow-policy">information flow policy</h5><p>在不同等级的信息流之间采取不一样的安全策略。比如<strong>Noninterference policy</strong>规定高级别的信息流数据不可以影响(should not interfere with)低级别的信息流。<strong>换句话讲，机器的操作不能使得信息流从高级别的数据传播到低级别的数据中。</strong></p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>这种安全策略需要使得信息流只能沿着<code>lattice</code>的<code>upwards</code>方向进行传播。可以是<code>H——&gt;H、L——&gt;L、L——&gt;H</code>但是不可以是<code>H——&gt;L</code>。</p><h3 id="confidentiality-and-integrity">Confidentiality and Integrity</h3><p><strong>保密性</strong>和<strong>完整性</strong>从另一个视角解读了安全策略<code>information flow policy</code>如何从本质上保证信息流安全。</p><p>对于已经分级好的信息，高级别的信息不可以流到低级别的信息中可以看成是为了保密性，防止数据泄露。而低级别的信息也不能流到高级别的信息中可以看成是为了保护数据的完整性。保密性已经介绍过了，这里介绍一下完整性。</p><h4 id="integrity">Integrity</h4><p>完整性需要保证一些无关紧要的信息流无法污染，破坏重要的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = readInput();  //untrusted</span><br><span class="line">cmd = &quot;...&quot; + x;</span><br><span class="line">execute(cmd);    //critical (trusted)</span><br></pre></td></tr></table></figure><p>比如一些常见的注入错误基本上都是因为破坏了数据的完整性才导致安全问题：</p><ul><li>Command injection</li><li>SQL injection</li><li>XSS attacks</li></ul><p><strong>对于已经分好级别的数据来说，保证安全就是需要在从高级别数据向低级别的信息流中防止泄露的同时，还需要在从低级别数据向高级别数据的信息流中防止污染。确保做到根据不同的信息流向应用不同的信息流安全策略。</strong></p><p>从更加广泛的角度来看的话，信息里安全需要保证的是信息的正确性，完整性以及数据的一致性：</p><ul><li>正确性：高级别的数据防止被污染</li><li>完整性：数据得到正确存储</li><li>一致性：保证在读写上数据能保持一致</li></ul><h3 id="explicit-flows-and-convert-channels">Explicit Flows and Convert Channels</h3><p>这里引入两个安全领域常见的概念，显式<code>explicit</code>和隐式<code>implicit</code>。</p><p>对于一些基本的信息流传播都是显式的比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xh = Yh;</span><br><span class="line">Xl = Yh;</span><br><span class="line">Xl = Yl + Zh</span><br></pre></td></tr></table></figure><p>可以看到数据都是直接通过赋值或者引用这些显式的修改语句直接进行传播的，成为显示流。而对于下面这些情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">secret = getSecret();</span><br><span class="line">if(secret &lt; 0)&#123;</span><br><span class="line">public = 1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">public = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况属于隐式流——即数据的传播都是通过一些被敏感数据控制的<code>if/while</code>语句来完成的。在上面的例子中，public是低级别数据可以直接被观测到，而secret是高级别的敏感数据，但是我们通过观测到public的值是否为1还是0就可以判断出高级别数据的最终值，这就是隐式流传播。</p><p><strong>隐式流的数据是通过程序的控制流信息进行传播的。</strong>也是安全领域最难以处理的一类安全问题。</p><h3 id="taint-analysis">Taint Analysis</h3><p>污点分析是信息流安全领域最常见的检测手段。污点分析将数据分为两种：</p><ul><li><code>tainted data</code>: 整个分析需要关注到的污点数据</li><li><code>other data</code>: 其他数据</li></ul><p>污点数据的来源被成为<code>sources</code>，从实现角度污点数据通常来自于函数的返回值，即在指针分析需要处理的<code>Call</code>语句。</p><p>Taint analysis tracks how tainted data flow through the program and observes if they can flow to locations of interest(called sinks).</p><p>污点分析就是通过追踪从<code>sources</code>发出的污点数据是如何在数据流上传播的，并观察这些污点数据是否会流到敏感源中(sinks)。不难看出，<strong>污点分析既可以检测高级别的数据是否被泄露——保密性，也可以检测低级别数据是否造成污染——完整性。</strong></p><p>而究其本质，污点分析就是在问：污点数据是否可以流到敏感源中——而这和指针分析的目的不谋而合，<strong>即污点分析/指针分析的目的都是为了追踪污点数据/抽象对象是如何在程序中传播的</strong>：</p><ul><li>Can tainted data flow to a sink?</li><li>Which tainted data a pointer (at a sink)can point to?</li></ul><h4 id="domains-and-notations">Domains and Notations</h4><p>如何使用指针分析来对污点分析进行建模，只需完成<code>tainted data</code>⟶<code>object</code>,<code>sources</code>⟶ <code>allocation sites</code>这两个映射。</p><ul><li><font color="red">Variables</font>: x, y ∊ V<br></li><li>Fields: f, g ∊ F</li><li>Objects: o<sub>i</sub>，o<sub>j</sub> ∊ O</li><li>Tainted data: t<sub>i</sub>，t<sub>j</sub> ∊ T ⊂ O 污点数据就是在调用点产生的对象中被特殊标记的部分</li><li><font color="red">Instance fiedls</font>: o<sub>i</sub>.f, o<sub>j</sub>.g ∊ O x F</li><li><font color="red">Pointers</font>: Pointer = V ⋃ (O x F)</li><li>Points-to relations: pt: Pointer ⟶ 𝓟(O)</li></ul><p>其中t<sub>i</sub>代表了从<code>call-site</code>调用点<code>i</code>产生的污点数据。𝓟(O)代表了O的幂集，<code>pt(p)</code>代表了指针变量<code>p</code>的指向集合。</p><h4 id="taint-analysis-input-outputs">Taint Analysis: Input &amp; Outputs</h4><p>污点分析的输入为<code>sources</code>——一系列返回值产生污点数据的函数集合，<code>Sinks</code>——一些敏感函数的集合，一旦污点数据流入这些函数将会触发安全问题。</p><p>污点分析的输出是<code>TaintFlows</code>:污点数据和Sinks函数的pairs集合。<strong>比如&lt;t<sub>i</sub>, m&gt;表示从<code>call-sites</code>调用点<code>i</code>产生的<code>tainted-data</code>可能会流入<code>sink-method</code></strong>。</p><h4 id="call">Call</h4><p>整个污点分析需要处理的规则和指针分析大体一致，而对于调用语句<code>Call</code>的处理需要完成两种——<code>sources</code>和<code>sinks</code>的处理，分别用于产生污点数据和产生污点信息流。</p><h5 id="sources">Sources</h5><p><img src="2.png" width="50%" height="50%" alt=""></p><p>规则的前提是如果调用边集合<code>CG</code>中存在从<code>l</code>到<code>m</code>的一条调用边——<code>l⟶m</code>，而<code>m</code>恰好是<code>sources</code>函数集合中的元素，则需要将该调用语句的指针变量集合<code>pt(r)</code>加上一条污点数据t<sub>i</sub>。</p><h5 id="sinks">Sinks</h5><p><img src="3.png" width="50%" height="50%" alt=""></p><p>该规则的前提是如果调用边集合<code>CG</code>中存在一条调用边——<code>l⟶m</code>，而<code>m</code>恰好属于<code>sinks</code>函数集合中的元素，而在<code>m</code>的参数中还存在着污点数据集合中的元素t<sub>j</sub>，则会产生一条<code>TaintFlows</code>从t<sub>j</sub>到<code>m</code>函数即&lt;t<sub>j</sub>,m&gt;。</p><p>污点分析的学习至此结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;同符号执行一样，&lt;code&gt;Taint-Analysis&lt;/code&gt;也是分析代码安全漏洞，检测攻击方式的重要手段。对于&lt;code&gt;Web&lt;/code&gt;应用程序中存在着的大量安全漏洞,如跨站脚本攻击，&lt;code&gt;SQL&lt;/code&gt;注入等~污点分析都可以进行有效地检测。而污点传播技术是当前&lt;code&gt;Taint-Analysis&lt;/code&gt;领域的重要课题，&lt;strong&gt;通过和静态程序分析技术相结合，在不运行代码且不修改代码的前提下通过分析程序变量之间的相互依赖关系以此获得更高效，更精确的分析结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Taint analysis tracks how tainted data flow through the program and observes if they can flow to locations of interest(call sinks).&lt;/p&gt;
&lt;p&gt;比如通过利用静态指针分析算法完成简化的显式流&lt;code&gt;explicit flow&lt;/code&gt;分析，不讨论&lt;a href=&quot;https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;路径爆炸&lt;/a&gt;和其他动态漏洞分析技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(3-Pointer-Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/05/14/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-3-Pointer-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/05/14/NJU静态程序分析-3-Pointer-Analysis/</id>
    <published>2021-05-13T17:34:59.000Z</published>
    <updated>2022-03-16T10:08:39.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>过程间分析需要基于程序的<code>Call Graph</code>来完成。由于<code>CHA Analysis</code>过度追求速度造成误报——而<code>false positive</code>对于常量传播这样的<code>must</code>分析来说是不可接受的。因此指针分析在<code>POPL'1980</code>被第一次提出<a href="https://static.aminer.org/pdf/PDF/000/546/844/interprocedural_data_flow_analysis_in_the_presence_of_pointers_procedure.pdf" target="_blank" rel="noopener">Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure Variables, and Label Variables</a>。</p><p>Pointer Analysis computes an over-approximation of the set of which memory-locations(objects) a pointer can point to.</p><p>指针分析除了可以构建<code>Call Graph</code>等程序基本信息之外，还可以用于编译优化，程序鲁棒性和安全等各个领域，是最基础的静态分析算法之一——比如流行的别名分析<code>Alias Analysis</code>就是从指针分析中派生出来的:Alias information can be derived from points-to relations.在指针分析的输出指向关系中是否有两个指针可以指向同一个对象。</p><a id="more"></a><h3 id="introduction">Introduction</h3><p>指针分析是一种<code>may</code>分析，输入时整个程序，分析结果的输出是类似于map的一系列指向关系<code>Points-to relations</code>。</p><p><img src="1.png" width="50%" height="50%" alt=""></p><h4 id="keyfactors">KeyFactors</h4><p>作为一项比较复杂的技术，指针分析框架的<strong>精度</strong>和<strong>速度</strong>取决于四个很主要的因素：</p><table><colgroup><col style="width: 15%"><col style="width: 34%"><col style="width: 49%"></colgroup><thead><tr class="header"><th>Factor</th><th>Problem</th><th>Choice</th></tr></thead><tbody><tr class="odd"><td>Heap abtraction</td><td>How to model heap memory?</td><td><font color="red">Allocation-site</font>/Storeless</td></tr><tr class="even"><td>Context sensitivity</td><td>How to model calling contexts?</td><td><font color="red">Context-sensitive/Context-insensitive</font></td></tr><tr class="odd"><td>Flow sensitivity</td><td>How to model control flow?</td><td>Flow-sensitive/<font color-red="">Flow-insensitive</font></td></tr><tr class="even"><td>Analysis scope</td><td>Which parts of program should be analyzed?</td><td><font color="red">Whole-program</font>/Demand-driven</td></tr></tbody></table><h5 id="heap-abstraction">Heap Abstraction</h5><p>如何抽象堆操作，比如循环和递归会在动态运行时创建很多的堆对象，如何将这些<code>unbounded</code>的操作进一步简化抽象成<code>finite</code>的静态分析对象。</p><p><img src="2.png" width="50%" height="50%" alt=""></p><p>学术界有两个流派来完成堆抽象：<code>Store based model</code>和<code>Storeless model</code>。本节课介绍第一个流派下面的<code>Allocation sites</code>方法来对所有堆对象完成建模——<code>One abstract object per allocation site</code>。<strong>即每一个分配点<code>new</code>的堆对象都抽象到一个<code>object</code>中。</strong></p><h5 id="context-sensitivity">Context Sensitivity</h5><p>在函数调用的时候会产生上下文<code>context</code>。<strong>一个<code>method</code>被调用多次的话如何对每一次的上下文进行抽象。</strong>关于上下文抽象也有两种流派:</p><ul><li><code>Context-sensitive</code>: 对每一次调用都区别对待，具体调用具体分析</li><li><code>Context-insensitive</code>: 对一个<code>method</code>的所有调用都merge到一起，一次性处理</li></ul><p>上下文敏感是提高静态分析效率非常有效的工具之一，是这门课需要讨论的重点。</p><h5 id="flow-sensitivity">Flow Sensitivity</h5><p>如何对控制流抽象，也有两种流派：</p><ul><li><code>Flow-sensitive</code>: 确保程序的执行顺序<code>execution order</code>，维护每一个程序点的<code>points-to relations</code>表</li><li><code>Flow-insensitive</code>:忽略执行顺序，维护整个程序的指向表</li></ul><p>目前学术界还没有直接研究表明<code>flow sensitivity</code>相比于<code>flow insensitivity</code>对<code>Java</code>这样的OOP语言会有多少优势。</p><h5 id="analysis-scope">Analysis Scope</h5><p>在进行指针分析的时候，如何选取需要分析的程序段？</p><ul><li>Whole-program</li><li>Demand-driven</li></ul><p>是直接分析整套程序还是以需求为驱动进行特定程序片段的分析。实际上如果需求很多的话，单独分析的复杂度和直接进行整套程序分析的复杂度不相上下。</p><h4 id="concerned-statements">Concerned Statements</h4><p>上述的<code>Key Factors</code>是具有全局性质的-<strong>即针对整个指针算法框架</strong>，那在实现上-<strong>即针对<code>Java</code>编程语言的具体指针分析框架</strong>来说，更细粒度的<code>Concerned Statements</code>会是什么呢？</p><h5 id="pointers-in-java">Pointers in Java</h5><p>首先需要总结一下<code>Java</code>中所有可以用作指针的声明。</p><ul><li><code>Local variable：x</code></li><li><code>Static field: C.f</code></li><li><code>Instance field: x.f</code></li><li><code>Array element: array[i]</code></li></ul><p>共有4中具体的指针类型——<code>static field</code>是一种全局变量。数组元素在分析时可以忽略掉索引，看成是可以指向任何数组元素<strong>field</strong>的指针类型<code>array.arr</code>，因此也被看成是一种<code>Instance field</code>。<font color="red">综上来看，针对Java语言的指针分析主要处理<code>Local variable</code>和<code>instance field</code>两种指针类型。</font></p><h5 id="pointer-affecting-statements">Pointer-Affecting Statements</h5><p>明确了指针分析研究对象<strong><code>Pointers</code>的具体类型</strong>之后，继续思考全程序的指针分析如何更具体的完成实现？就语句本身来说例如<code>if/for/break</code>这样的控制流并不会对指针分析的结果造成影，我们需要关注真正的<font color="red">pointer-affecting statements</font>如下：</p><ul><li><code>New:      x = new T()</code></li><li><code>Assign:    x = y</code></li><li><code>Store:  x.f = y</code></li><li><code>Load:  y = x.f</code></li><li><code>Call:    r = x.k(a, ...)</code> 重点关注<code>virtual calls</code></li></ul><h3 id="foundations">Foundations</h3><h4 id="rules">Rules</h4><h5 id="domains-and-notations">Domains and Notations</h5><p>指针分析是一种以指向关系作为传递信息的数据流分析。所以其理论也需要引入域和某些符号解释：</p><ul><li><font color="red">Variable</font>: x, y ∊ V</li><li>Fields: f,g ∊ F</li><li>Objects: o<sub>i</sub>,o<sub>j </sub>∊ O (Allocation sites)</li><li><font color="red">Instance fields</font>: o<sub>i</sub>.f, o<sub>j</sub>.g ∊ O⨉F</li><li><font color="red">Pointers</font>: Pointer = V⋃(O⨉F)</li></ul><p>其中Variable表示程序中的所有变量指针类型。Object和Fields分别指的是程序中分配堆对象的创建点和抽象堆对象中的域——对象和域组合起来的Instance Fields也表示程序中一种指针。<strong>Pointers指的是程序中所有的<code>variable</code>和<code>instance field</code>——<code>V ⋃ (O x F)</code>。</strong></p><p>最后引入<strong>指向关系<code>pt</code>(其本身就是一种映射， 代表指针可能指向的对象的集合)</strong>：</p><ul><li><p><font color="blue">Points-to relations</font>: <code>pt: Pointer ⟶ 𝓟(O)</code></p><ul><li><p><code>𝓟(O)</code>表示对象O的<code>powerset</code></p></li><li><p><code>pt(p)</code>表示指针p的<strong>指向关系集合</strong></p></li></ul></li></ul><p><strong>理解上，指针指向对象——指针p的值域就是<code>V ⋃ (O x F)</code>，对象o的值域就是<code>𝓟(allocation sites)</code>。<code>p⟶o ≡ o∊pt(p)</code>即指针p指向对象o等价于对象o属于指针p的指向关系集合。</strong></p><p>在此基础上，引入如何处理<code>Pointer-Affecting Statements</code>的形式化Rules：</p><p><img src="3.png" width="50%" height="50%" alt=""></p><p>分数上面是前提<code>premise</code>而下面是结论<code>conclusion</code>。</p><ul><li><p>New: <code>New</code>规则中的o<sub>i</sub> 表示一个<code>Allocation site</code>在这一点创建出来的对象，那么指针分析如何处理一个<code>New</code>语句——<strong>即执行完这条语句后让x指向o<sub>i</sub>即o<sub>i</sub> ∊ pt(x)</strong>。</p></li><li><p>Assign: 如果o<sub>i</sub>属于y的指向集，<strong>那在执行完这条语句后o<sub>i</sub>则需要加入到x的指向集中。</strong></p></li><li><p>Store: 将新对象保存到该对象的一个域f——如果x指向o<sub>i</sub>而y指向o<sub>j</sub>，<strong>那执行完这条语句之后o<sub>i</sub>.f需要指向o<sub>j</sub>。</strong></p></li><li><p>Load: 将某个对象的域f加载到新对象中——如果x指向o<sub>i</sub>而o<sub>i</sub>的域f指向o<sub>j</sub>，<strong>那执行完后将o<sub>j</sub>加入到y的指针集当中。</strong></p></li></ul><h4 id="how-to-implement-pointer-analysis">How to Implement Pointer Analysis</h4><p>在确定好Domain和Rules之后开始明确如何实现<strong>全程序的指针分析算法</strong>。</p><p>Essentially，pointer analysis is to <font color="red">propagate</font> points-to information among pointers(variables &amp; fields).</p><p><strong>在两种指针(<code>variable</code>和<code>fields</code>)之间根据<code>Pointer-Affecting Statements</code>建立和传递指向关系<code>points-to</code>。</strong>从另一个角度来说指针分析就是在解决指针之间的<code>inclusion constraints</code>即对于<code>x = y</code>语句指针x一定包含指针y的所有指向信息。<strong>而关键的是当<code>pt(x)</code>更新时，这些改变也需要传递给x的其他相关指针</strong>。</p><p>而在实现上，我们用<code>Graph</code>来连接相关联的指针，当<code>pt(x)</code>更新时，将更新的数据流（数据流分析根据Domain不同而不同，指向关系也是一种数据流信息）传递给<code>x</code>的后继元素，这个图就是<code>Pointer Flow Graph</code>。</p><h5 id="pointer-flow-graphpfg">Pointer Flow Graph(PFG)</h5><p>一个程序的<code>PFG</code>是一种表示<code>points-to</code>信息如何在<code>pointers</code>之间流动的有向图，图中的节点代表了<code>V ⋃ (O ⨉ F)</code>——变量或者<strong>抽象对象</strong>(因为PFG是静态分析建立的，所以是抽象的堆对象)的域，边代表了对象在指针之间的流动关系<code>Pointer ⨉ Pointer</code>——比如<code>x⟶y</code>代表了指针x的指向对象集合<font color="red">可能(指针分析是<code>may</code>分析)会流动到</font>y的指向集合。</p><p>PFG中的节点就是程序中的各种指针，而边是根据指针分析的Rules建立的。</p><p><img src="4.png" width="50%" height="50%" alt=""></p><p>有了PFG，指针分析问题就可以看成是在PFG上求其<strong>传递闭包</strong>的问题，比如PFG中a点到b点是可达的，那a中的数据流信息就可以直接流到b节点上。</p><p>综上，指针分析的思路主要有两部分：创建PFG——&gt;在PFG上传递指向信息。而难点在于这两者是互相依赖的。为什么创建PFG也会依赖指向信息呢？</p><p><img src="5.png" width="50%" height="50%" alt=""></p><p>因为在处理<code>instance fields</code>的指向关系的时候，前提是需要知道这些<code>field</code>的<code>object</code>的指向信息——由<code>allocation sites</code>更新得到。<strong>因此<code>PFG</code>本身也是随着指针分析的过程动态更新的。</strong></p><h4 id="algorithm">Algorithm</h4><p>本节具体实现数据流分析算法，首先是使用到的数据结构：</p><ul><li><code>S</code>: 输入程序的语句集合</li><li><code>WL</code>: work list存储了需要处理的指向关系pair，<strong>其中每一项<code>&lt;n,𝓟(O)&gt;*</code>意味着在<code>𝓟(O)</code>中的信息需要传递给<code>n</code>的指向关系集合<code>pt(n)</code>中</strong>，用</li><li><code>PFG</code>: 有向图，表示成为边的集合，其中<code>s⟶t</code>表示<code>s</code>的指向关系流向<code>t</code>的指向关系</li><li><code>Hybrid-Set</code>: 用来存在<code>pt(s)</code>，即当元素小于16时用<code>HashSet</code>大于16时用<code>BitVector</code></li></ul><h5 id="main-algorithm">Main Algorithm</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Solve(S) &#123;</span><br><span class="line">  WL = [], PFG = &#123;&#125;</span><br><span class="line">  foreach i: x=new T() ∊ S do          //处理New语句</span><br><span class="line">    add &lt;x, &#123;O_i&#125;&gt; to WL              </span><br><span class="line"></span><br><span class="line">  foreach x=y ∊ S do       //处理Assign语句</span><br><span class="line">    AddEdge(y, x)</span><br><span class="line"></span><br><span class="line">   while WL is not empty do</span><br><span class="line">     remove &lt;n, pts&gt; from WL</span><br><span class="line">     𝚫 = pts - pt(n)</span><br><span class="line">     Propagate(n, 𝚫)     </span><br><span class="line">     if n represents a variable x then</span><br><span class="line">       foreach o_i ∊ 𝚫 do </span><br><span class="line">         foreach x.f=y ∊ S do</span><br><span class="line">           AddEdge(y, o_i.f)     //处理Store语句 </span><br><span class="line">         foreach y=x.f ∊ S do    </span><br><span class="line">           AddEdge(o_i.f, y)    //处理Load语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddEdge(s, t) &#123;   //构建PFG</span><br><span class="line">  if s⟶t ∉ PFG then      </span><br><span class="line">    add s⟶t to PFG</span><br><span class="line">    if pt(s) is not empty then</span><br><span class="line">      add &lt;t, pt(s)&gt; to WL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Propagate(n, pts) &#123;    //更新pt(x)</span><br><span class="line">  if pts is not empty then</span><br><span class="line">    pt(n) ⋃= pts //核心： 传递数据流</span><br><span class="line">    foreach n⟶s ∊ PFG do </span><br><span class="line">      add &lt;s, pts&gt; to WL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="addedge">AddEdge</h5><p>首先每一条<code>New</code>语句生成一条指向关系完成对<code>WL</code>的初始化。这套算法的输入语句<code>S</code>是流不敏感<code>insensitive</code>的，即处理过程不会关注语句顺序。</p><p><code>AddEdge</code>函数主要是通过处理<code>Assign</code>语句构建<code>PFG</code>。每一条<code>s⟶t</code>都对应着图上一条边，根据指针分析的<code>inclusion constraints</code>原理将<code>&lt;t, pt(s)&gt;</code>加入<code>WL</code>中实现把指针<code>s</code>的指向集合加到指针<code>t</code>中。</p><h5 id="propagate">Propagate</h5><p>在构建完最基础的的<code>PFG</code>之后，算法进入<code>While</code>循环开始迭代处理<code>WL</code>中的指向关系。取出一项<code>&lt;n, pts&gt;</code>，<strong>过滤掉指针<code>s</code>指向关系中指针<code>n</code>已经存在的抽象对象即𝚫=pts-pt(n)——主要是为了避免更多的冗余操作已达到<code>Differential Propagation</code></strong></p><p>然后开始<code>Propagate</code>函数，<font color="red">这个函数是真正修改了指针的指向关系即完成数据流的传递，换句话讲指针分析的过程就是在迭代过程中不断向<code>pts</code>中加入新的数据流</font>。而进入到函数内的𝚫是真正需要传递给<code>n</code>的指向集合，接着又根据<code>inclusion constraints</code>需要把指针<code>n</code>刚更新过的指向集合加到其在<code>PFG</code>上的后继中，故遍历整个图找到所有的后继节点<code>s</code>并把<code>&lt;s, pts&gt;</code>加到<code>WL</code>中等待下一轮更新。</p><h5 id="differential-propagation">Differential Propagation</h5><p><strong>查分传播</strong>是为了避免处理冗余的指针信息。这是因为在<code>PFG</code>上任意点的指向集合信息<code>pt(n)</code>一定已经传播到了其后继元素，没有必要在传播一次。在整个算法中一共有两处查分传播，分别是在<code>𝚫=pts-pt(n)</code>语句以及处理<code>Store/Load</code>语句的代码片段<code>foreach O_i ∊ 𝚫 do</code>。</p><p>首先<code>Store/Load</code>语句映射到<code>PFG</code>上的操作正好相反：</p><ul><li><code>Store：x.f=y</code> o<sub>i</sub>.f ⟵ y</li><li><code>Load: y=x.f</code> y⟵ o<sub>i</sub>.f</li></ul><p>关键是需要知道指针<code>x</code>指向的抽象对象<code>o_i</code>然后继续操作。而<code>foreach o_i∊𝚫 do</code>正好清除掉指针<code>x</code>以前的指向信息而保留了这次迭代中<strong>新加入</strong>的抽象对象。</p><p><img src="6.png" width="50%" height="50%" alt=""></p><p>就<code>Store/Load</code>语句本身而言也是通过<code>AddEdge</code>的方式来更新<code>PFG</code>的，但这里要注意的是<strong>因为有可能两个变量会指向相同的抽象对象o<sub>i</sub>，即虽然o<sub>i</sub>对于x来说是新加入的指向信息，但是有可能在前几次迭代中有<code>z.f=y</code>中的指针<code>z</code>也指向抽象对象o<sub>i</sub>，<font color="red">即因为指针o<sub>i</sub>.f中o<sub>i</sub>是一个对象——有可能会被多个指针指向，因此这里的<code>AddEdge</code>操作不能保证一定会引入新的<code>PFG</code>边</font></strong>。</p><h5 id="fixed-point">Fixed Point</h5><p>算法符合不动点原理——<code>WL</code>的功能就是向<code>pt</code>中添加信息，而核心<code>pt(n) ⋃ =pts</code>之后如果直接检查合并前后<code>pt</code>集合是否有变化也以判断达到不动点。</p><h4 id="how-to-deal-with-method-calls">How To Deal With Method Calls</h4><p>全程序的指针分析算法还需要处理方法调用。和所有过程间分析一样，<code>Inter-procedural pointer analysis</code>也需要建立<code>call graph</code>。不过相比于<code>CHA analysis</code>仅仅通过<code>receiver object</code>的声明类型来构建调用图不同，指针分析还使用指向信息<code>points-to relations</code>来使得<code>call graph</code>的构建更加精确。比如<code>void foo(A a) {... b = a.bar();...}</code>中<strong><code>points-to relations</code>和<code>Call Graph</code>都是在指针分析的过程中动态更新的，比如想要建立<code>pt(a)</code>需要知道函数<code>foo</code>的调用边，而如果想要给<code>a.bar()</code>建立调用边则也需要<code>pt(a)</code>，这种方法被称为<code>on-the-fly call graph construction</code></strong>。</p><ul><li><code>CHA</code>: 基于<code>a</code>声明类型解析<code>call targets</code></li><li><code>pointer analysis</code>: 基于<code>pt(a)</code>解析<code>call targets</code></li></ul><h5 id="rule-call">Rule: Call</h5><p>首先引入指针分析处理方法调用Rules的形式化描述：</p><p><img src="7.png" width="50%" height="50%" alt=""></p><p>指针分析器在遇到了<code>r = x.k(a1, ...)</code>调用语句的时候，肯定会模拟编译器的运行时行为并解析：</p><ul><li>o<sub>i</sub>∊pt(<font color="blue">x</font>),m=Dispatch(o<sub>i</sub>,k) ⟶ o<sub>i</sub>∊pt(<font color="blue">m<sub>this</sub></font>)，其中x是<code>caller</code>变量</li><li>o<sub>u</sub>∊pt(<font color="blue">a<sub>j</sub></font>) ⟶ o<sub>u</sub>∊pt(<font color="blue">m<sub>pj</sub></font>)，其中a<sub>j</sub>是形参</li><li>o<sub>v</sub>∊pt(<font color="blue">m<sub>ret</sub></font>)⟶o<sub>v</sub>∊pt(<font color="blue">m<sub>r</sub></font>)，其中m<sub>ret</sub>是返回值</li></ul><p>为了解释的更清楚，下面对规则进行了进一步的解释：</p><ul><li>根据<code>pt(x)</code>得到被调用方法<code>k</code>的<code>receiver object</code>即o<sub>i</sub>，然后调用<code>Dispatch(O_i, k)</code>解析出<code>target method</code>即<code>m</code><br></li><li>将目标函数<code>m</code>的<code>this</code>指针指向变量<code>x</code>实际指向的对象即o<sub>i</sub></li><li>将形参<code>m_pj</code>的指针指向实参变量指向的对象集合<code>pt(aj)</code>，<font color="red">并将形参变量和对应实参变量之间加上<code>PFG</code>边(a1⟶m_p<sub>j</sub>)</font></li><li>将调用语句的<code>LHS</code>指向目标函数<code>m</code>的返回值变量指向的对象结婚<code>m_ret</code>，<font color="red">并将这两个变量之间加上<code>PFG</code>的边(r⟵m<sub>ret</sub>)</font></li></ul><p>主要需要关注的是<code>receiver object</code>，<code>target method</code>，<code>arguments</code>和<code>return value</code>。</p><p><img src="8.png" width="50%" height="50%" alt=""></p><p>而这里对形参和实参之间，返回值和左值之间连上<code>PFG</code>的边而没有给目标方法和调用者之间加边的原因是<strong>因为<code>caller</code>变量<code>x</code>有可能有多个指向对象<code>pt(x)</code>，而对于<code>Dispatch</code>函数来说，只要<code>receiver object</code>确定那<code>target method</code>也是确定的。如果我们需要保证OOP语言中所有函数的<code>this</code>指针都指向唯一正确的<code>receiver object</code>即o<sub>i</sub>，前提就是保证不能让其他虚假的<code>pt(x)</code>信息直接流入<code>this</code>指针——</strong>如果贸然给<code>x</code>和目标方法的<code>this</code>指针之间加上<code>PFG</code>只会导致引入虚假<code>spurious</code>信息。</p><h5 id="algorithm-1">Algorithm</h5><p>在过程间指针分析中，调用图的构建和指向关系的构建都是同步动态更新的，引入<code>reachable</code>可达的概念：即从<code>main</code>函数开始，将真正调用到的函数依次纳入可达方法集合中，所有的分析只从这些集合中完成。首先介绍算法中使用到的数据结构：</p><ul><li><code>S</code>: 可达语句<code>reachable statements</code>的集合</li><li><code>S_m</code>: 函数<code>m</code>中的语句集合</li><li><code>RM</code>: 可达函数集合</li><li><code>CG</code>: 调用边<code>Call Graph</code>集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Solve(m_entry) &#123;</span><br><span class="line">WL = &#123;&#125;, PFG = &#123;&#125;, RM = &#123;&#125;, CG = &#123;&#125;</span><br><span class="line">AddReachable(m_entry)</span><br><span class="line">while(WL is not empty) &#123;</span><br><span class="line">remove &lt;n, pts&gt; from WL</span><br><span class="line">𝚫 = pts - pt(n)</span><br><span class="line">Propagate(n, 𝚫)</span><br><span class="line">if n represents a variable x &#123;</span><br><span class="line">foreach o_i∊𝚫 do</span><br><span class="line">foreach x.f=y∊S do</span><br><span class="line">        AddEdge(y, o_i.f)</span><br><span class="line">        foreach y=x.f∊S do</span><br><span class="line">        AddEdge(o_i.f, y)</span><br><span class="line">        ProcessCall(x, o_i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddReachable(m) &#123;</span><br><span class="line">if m∉RM then</span><br><span class="line">add m to RM</span><br><span class="line">S ⋃= S_m</span><br><span class="line">foreach i:x=new T()∊S_m do</span><br><span class="line">add &lt;x, &#123;o_i&#125;&gt; toWL</span><br><span class="line">foreach x=y∊S_m do</span><br><span class="line">AddEdge(y, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessCall(x, o_i) &#123;</span><br><span class="line">foreach l:r=x.k(a1,...an)∊S do</span><br><span class="line">m = Dispatch(o_i,k)</span><br><span class="line">add &lt;m_this,&#123;o_i&#125;&gt; to WL</span><br><span class="line">if l⟶m∉CG then</span><br><span class="line">add l⟶m to CG</span><br><span class="line">AddReachable(m)</span><br><span class="line">foreach parameter p_i of m do</span><br><span class="line">AddEdge(a_i, p_i)</span><br><span class="line">AddEdge(m_ret, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="addreachable">AddReachable</h6><p>这个函数的功能就是将被调用的方法加入<code>RM</code>，并将对应的语句加入到<code>S</code>中。<code>AddReachable</code>函数在整个算法一共两个地方被调用——一个是初始化将<code>main</code>函数首先加入，其次就是在每一次有新的<code>Call Graph edge</code>被创建的时候。函数本身还需要处理当前<code>Reachable Method</code>中的<code>New/Assign</code>语句。<strong>这是因为<code>Load/Store/Call</code>语句的分析都是根据指向信息的变化（比如<code>x.f=y</code>如果<code>x</code>又指向了一个新对象）来更新处理的，但是<code>New/Assign</code>不需要任何信息就可以独立完成分析。</strong>这也是<code>Differential</code>的目的。</p><h6 id="processcall">ProcessCall</h6><p>该函数处理方法调用的<code>Rules</code>。<strong>整个函数执行的前提就是该函数的<code>receiver object</code>即<code>x</code>有新的指向关系o<sub>i,j,k...</sub>被加入到𝚫时，</strong>这两个参数被传入到函数中开始执行。</p><p>首先使用<code>Dispatch</code>函数解析出来<code>target method</code>即<code>m</code>变量。通过把&lt;m<sub>this</sub>,{o<sub>i</sub>}&gt;加入到<code>WL</code>中来完成将目标函数<code>m</code>的<code>this</code>指针指向变量<code>x</code>实际指向对象即o<sub>i</sub>。</p><p>接下来添加<code>Call Graph</code>，这里之所以要有<code>if</code>语句判断该条调用边存在性即<code>Differential</code>，是因为<strong>有可能之前有和o<sub>i</sub>相同类型的对象o<sub>j</sub>已经触发了<code>ProcessCall</code>函数执行并加上调用边——因为整个<code>While</code>循环继续执行的前提就是<code>pt(x)</code>被更新，那更新前后的o<sub>i,j,k...</sub>完全有可能是同一个类型。</strong></p><p>添加完调用边之后，最后添加参数和返回值。整个算法的输出是<code>Points-to relations</code>和<code>Call Graph</code>。至此上下文不敏感的全程序指针分析算法就介绍完了。</p><h3 id="context-sensitivity-1">Context Sensitivity</h3><p>上下文敏感是提升指针分析精度（尤其是针对<code>Java</code>语言的指针分析）最有效的技术，也是指针分析领域近年来研究的热点。</p><h4 id="introduction-1">Introduction</h4><p>在程序动态运行的过程中，一个<code>method</code>可能会在不同的<code>context</code>下被调用多次。而在不同的上下文中<code>method</code>的指针可能会指向不同的<code>object</code>。<strong><code>Context Insensitivity .aka. C.I.</code>导致这些不同上下文的<code>objects</code>通过返回值都被传递到程序的其他分支中进而产生虚假数据流信息。</strong>比如程序中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = id(n1);</span><br><span class="line">y = id(n2);</span><br><span class="line">int i = x.get();</span><br><span class="line">Number id(Number n) &#123;</span><br><span class="line">return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数<code>id</code>被调用两次，故形式参数<code>n</code>被传入两条<code>PFG</code>边——分别是实参<code>n1</code>和<code>n2</code>，而这两个指针对象又分别指向不同的o<sub>i</sub>和o<sub>j</sub>，<strong>导致返回值<code>n</code>的指向关系集合<code>pt(n)</code>里增加了o<sub>i</sub>和o<sub>j</sub>。</strong>而<code>n</code>和<code>x</code>,<code>y</code>又各自连着<code>PFG</code>故导致<code>pt(x)/pt(y)</code>的指向关系也是o<sub>i</sub>和o<sub>j</sub>——如果是过程间的常量传播则最终分析的结果就是<code>x/y = NAC</code>，很明显丧失了精度。</p><p>Context sensitivity models calling contextx by <font color="red">distinguishing </font>different data flows of different contextx to improve precision.</p><p>下面讨论开展上下文敏感的指针分析算法所需要考虑的几个方面：</p><h5 id="call-site-sensitivity">Call-site sensitivity</h5><p><code>Context sensitivity .aka. C.S.</code>用来区别不同上下文的方式中最常见的是<code>call-site sensitivity</code>——每一个上下文都抽象成本次方法调用的<strong>动态运行时调用栈</strong>即一系列<code>call-sites</code>组成的列表(随着调用层次深入<code>c</code>的长度会增加，区别于用<code>l</code>行号代表当前调用点)，比如上面一段代码中的<code>id</code>方法共有两个<code>context</code>分别是<code>[1]</code>和<code>[2]</code>。从实现的角度来看，<code>Cloning-Based Context Sensitivity</code>是实现<code>C.S.</code>最直接的方式——同一个<code>method</code>的多次调用都根据各自的<code>context</code>区分成不同的<code>Cloning-Based</code>版本，<code>method</code>中的调用也随着各自的<code>Cloning-Based</code>区分出来——<code>one clone per context</code>。</p><p><img src="9.png" width="50%" height="50%" alt=""></p><h5 id="context-sensitive-heap">Context-Sensitive Heap</h5><p>从更细粒度的角度看，OOP是<code>heap-intensive</code>的语言——所有的对象都是建立在堆区<code>by new</code>。在实际设计中，上下文敏感的指针分析算法还需要考虑到堆敏感的问题——这是因为所有的语句其实都有自己的作用域，OOP的作用域就是函数。<strong>创建新对象的<code>new</code>语句就是一个<code>allocation site</code>，而当<code>new</code>语句出现在一个函数中恰巧该函数又被多次调用的时候，同一个<code>allocation site</code>会在不同的上下文背景下建立各自的对象</strong>，所以同一个方法中的堆对象也需要根据不同的<code>heap context</code>来进行区分。最直接的方式就是直接继承其所在<code>method</code>的上下文并从更加细粒度的角度处理指针分析算法：</p><p><img src="10.png" width="50%" height="50%" alt=""></p><h4 id="rules-1">Rules</h4><p>下面引入上下文敏感指针分析的<code>Rules</code>：</p><h5 id="domains-and-notations-1">Domains and Notations</h5><p>在上下文敏感分析中，程序中的所有元素（变量，方法，对象）都加上了上下文。首先引入上下文的集合<code>C</code>,</p><ul><li>c,c',c'' ∊ C</li></ul><p>而程序中的方法，变量和对象都和<code>context</code>做了<code>product</code>：</p><ul><li><font color="red">Context-sensitive methods</font>: <font color="red">c:</font>m ∊ <font color="red">C</font> x M</li><li><font color="red">Context-sensitive variables</font>: <font color="red">c:</font>x, <font color="red">c':</font>y ∊ <font color="red">C</font> x V</li><li><font color="red">Context-sensitive objects</font>: <font color="red">c:</font>o<sub>i</sub>, <font color="red">c':</font>o<sub>j</sub> ∊ <font color="red">C</font> x O</li><li>Fields: f, g ∊ F</li><li>Instance fields: <font color="red">c:</font>o<sub>i</sub>.f, <font color="red">c':</font>o<sub>j</sub>.g ∊ <font color="red">C</font> x O x F</li></ul><p>最后，引入这些程序中的两种上下文敏感的指针类型：</p><ul><li><font color="red">Context-sensitive pointers</font>: CSPointer = (<font color="red">C</font> x V) ⋃ (<font color="red">C</font> x O x F)</li></ul><p>以及指向关系集合：</p><ul><li>Points-to relations: pt: CSPointer ⟶ 𝓟(<font color="red">C</font> x O)</li></ul><h5 id="regular-rules">Regular Rules</h5><p>这些规则和之前针对<code>Java</code>语言的数据流分析框架规则基本一样，只是元素都加上了不同的上下文以区分，重点需要关注这些语句中的<font color="green">指针变量</font>和<font color="blue">堆对象</font>是否都在同一个<code>context</code>中：</p><p><img src="11.png" width="50%" height="50%" alt=""></p><p><code>new</code>语句中<code>x</code>和分配的堆对象o<sub>i</sub>同属于一个上下文，那是因为指针变量的初始化堆内存一定是在一个作用域中。<code>assign</code>语句中会发现只有<code>x = y</code>是在一个<code>context</code>中，而其两个指针变量共同指向的堆内存部分<code>pt(y)</code>却<strong>共同</strong>在另一个<code>context</code>中这是因为有参数传递的可能。<code>Store/Load</code>语句中<code>x</code>和<code>y</code>在同一个上下文中但是它们的指向对象却<strong>分别</strong>在不同的<code>context</code>下。</p><h5 id="call-rule">Call Rule</h5><p>上下文敏感的规则中最重要的就是<code>Call</code>规则，它主导并传递了不同的数据流使得精度提升成为可能。</p><p><img src="12.png" width="50%" height="50%" alt=""></p><p>假设用<code>c</code>代表当前所在方法也就是调用者<code>Caller</code>的上下文，而用c<sup>t</sup>代表被调用者<code>Callee</code>的上下文。首先得到指针变量<code>x</code>的<code>receiver object</code>即o<sub>i</sub>，该堆对象有可能是在不同的上下文中因此和其指针的上下文不同。其次使用o<sub>i </sub>和方法签名<code>k</code>作为参数，<code>Dispatch</code>出真正的<code>target method</code>。最后使用和<code>call-site</code>相关的信息：<code>call-site</code>，当前上下文<code>c</code>以及所指向的堆对象<code>c':o_i</code>作为参数使用函数<code>Select</code>来取得该<code>target method</code>的上下文c<sup>t</sup>。<strong>需要注意的就是<font color="red">o<sub>i,j,k...</sub> = pt(x)&lt;</font>中的o<sub>i,j,k...</sub>和<code>x</code>两者之间的上下文是没有直接关系的，所以严格讲这两个的<code>c</code>都应该是不同的。</strong></p><p><img src="13.png" width="50%" height="50%" alt=""></p><p>这时候基本上所有<code>Cloning-Based</code>的程序元素都取得了，就和上下文不敏感指针分析处理<code>Call</code>的规则基本一致。</p><h4 id="algorithm-2">Algorithm</h4><p>上下文敏感的算法和上下文不敏感的指针分析算法整体上框架是一样的。<strong>构建上下文敏感的指针流图并通过PFG with C.S.传递指向信息。</strong>只是这些PFG的节点和边为了更高的精度被加上了新的约束——上下文信息，从而变成了<code>context-sensitive variable/abstract object</code>的指针类型。</p><ul><li><code>Node: CSPointer = (C x V) ⋃ (C x O x F)</code></li><li><code>Edges:CSPointer x CSPointer</code></li></ul><p>PFG中的每一个节点都被上下文<code>c</code>区分开，每一条边都有了更细粒度的解释：</p><ul><li><code>x = y</code>: c:x ⟵ c:y</li><li><code>x.f = y</code>: c':o<sub>i</sub>.f ⟵ c:y</li><li><code>y = x.f</code>: c:y ⟵ c':o<sub>i</sub>.f</li></ul><p>下面就是上下文敏感的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Solve(m_entry) &#123;</span><br><span class="line">  WL=&#123;&#125;, PFG=&#123;&#125;, S=&#123;&#125;, RM=&#123;&#125;, CG=&#123;&#125;</span><br><span class="line">  AddReachable([]:m_entry)     //上下文敏感函数</span><br><span class="line">  while WL is not empty do</span><br><span class="line">    remove &lt;n, pts&gt; from WL</span><br><span class="line">    𝚫 = pts - pt(n)</span><br><span class="line">    Propagate(n, 𝚫)</span><br><span class="line">    if n represents a variable c:x then   //上下文敏感的指针变量</span><br><span class="line">        foreach c&apos;:o_i ∊ 𝚫 do     //上下文敏感的堆对象</span><br><span class="line">        foreach x.f = y ∊ S do</span><br><span class="line">              AddEdge(c:y, c&apos;:o_i.f)  //对上下文敏感的指针和堆对象加PFG边</span><br><span class="line">            foreach y = x.f ∊ S do</span><br><span class="line">              AddEdge(c&apos;:o_i.f, c:y)</span><br><span class="line">            ProcessCall(c:x, c&apos;:o_i)    //处理上下文敏感的方法调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddReachable(c:m) &#123;</span><br><span class="line">  if c:m ∉ RM then</span><br><span class="line">    add c:m to RM</span><br><span class="line">    S ⋃= S_m</span><br><span class="line">    foreach i:x = new T() ∊ S_m do</span><br><span class="line">      add&lt;c:x, &#123;c:o_i&#125;&gt; to WL   //修改PFG</span><br><span class="line">    foreach x = y ∊ S_m do</span><br><span class="line">      AddEdge(c:y, c:x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessCall(c:x, c&apos;:o_i)&#123;</span><br><span class="line">     foreach l: r = x.k(a1, ..., an)∊S do</span><br><span class="line">        m = Dispatch(o_i, k)</span><br><span class="line">        ct = Select(c, l, c&apos;:o_i)   // 核心： 选择target method的上下文ct</span><br><span class="line">        add &lt;ct:m_this, &#123;c&apos;:o_i&#125;&gt; to WL   //this指针和堆对象加PFG</span><br><span class="line">          if c:l ⟶ ct:m to CG      //添加调用边</span><br><span class="line">            add c:l ⟶ ct:m to CG</span><br><span class="line">              AddReachable(ct:m)   </span><br><span class="line">              foreach parameter p_i of m do //处理参数</span><br><span class="line">              AddEdge(c:a_i, ct:p_i)</span><br><span class="line">             AddEdge(ct:m_ret, c:r)   //处理返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="variants">Variants</h4><p>上述算法中引入了一个新的<strong>函数<code>Select(c, l, c':o_i)</code>——在<code>caller</code>函数中利用相关信息获取当前<code>callee</code>的上下文。</strong>该信息包括调用者上下文<code>caller context</code>，调用点<code>call-ste</code>，堆上下文敏感的对象<code>receiver object with heap context</code>。</p><p><img src="14.png" width="50%" height="50%" alt=""></p><p>介绍三个版本的<code>Select</code>函数。</p><h5 id="call-site-sensitivity-1">Call-site sensitivity</h5><p>该版本的<code>context</code>由一系列<code>call-site</code>（在代码中由行号来表示）组成的列表。<strong><code>callee-context</code>是在每次调用点将当前的行号append到<code>caller-context</code>上</strong>——本质上是在模拟调用栈：</p><ul><li>Select(c, l, ...) = [<font color="red">l', ..., l''</font>, l], where c = [<font color="red">l', ..., l''</font>]</li></ul><p>这个列表的长度可以规定，故又称为<code>k-CFA</code>。而这种抽象在递归程序中会导致出现无数个<code>callee-context</code>,又比如在实际工程项目中调用栈很深的情况下上下文过于冗长：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;   //context:[]</span><br><span class="line">...</span><br><span class="line">a.foo();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;   //context:[3]</span><br><span class="line">...</span><br><span class="line">b.bar();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar()&#123;   //Context:[3,9], [3,9,15], [3,9,15,15...]  无数个</span><br><span class="line">...</span><br><span class="line">bar();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>k-Limiting Context</code>通过对上下文的长度进行了限制保证了不会过度增长。一般情况下长度≤3。而且<code>method context</code>和<code>heap context</code>使用不同的长度保证不会互相有影响。</p><h5 id="object-sensitivity">Object sensitivity</h5><p>该版本的<code>context</code>是由一系列抽象对象<code>abstract objects</code>（由其<code>allocations site</code>表示）组成的。</p><ul><li>Select(,,c':o<sub>i</sub>) = [<font color="red">o<sub>j</sub>,...,o<sub>k</sub></font>,o<sub>i</sub>] where c'=[<font color="red">o<sub>j</sub>,...,o<sub>k</sub></font>]</li></ul><p>这里一个有意思的点就是不管是<code>Object</code>还是<code>Call-site</code>都有自己的局限性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">B f;</span><br><span class="line">void set(B b)&#123;</span><br><span class="line">this.doSet(b);</span><br><span class="line">&#125;</span><br><span class="line">void doSet(B p)&#123;</span><br><span class="line">this.f = p;</span><br><span class="line">&#125;</span><br><span class="line">B get()&#123;</span><br><span class="line">return this.f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a1 = new A();</span><br><span class="line">a2 = new A();</span><br><span class="line">b1 = new B();</span><br><span class="line">b2 = new B();</span><br><span class="line">a1.set(b1);</span><br><span class="line">a2.set(b2);</span><br><span class="line">x = a1.get();</span><br></pre></td></tr></table></figure><p>则使用<code>1-call-site</code>敏感来完成时，会发现因为<code>set</code>中套用了<code>doSet</code>函数而导致<code>c:b1</code>和<code>c':b2</code>都指向了<code>c'':doSet_this</code>函数，从而引入虚假信息。而使用<code>1-object</code>则因为<code>doSet</code>函数分别在两个堆对象下所以更精确。</p><p>下面的代码下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line">static void main() &#123;</span><br><span class="line">C c = new C();</span><br><span class="line">c.m()</span><br><span class="line">&#125;</span><br><span class="line">Number id(Number n) &#123;</span><br><span class="line">return n;</span><br><span class="line">&#125;</span><br><span class="line">void m() &#123;</span><br><span class="line">Number n1, n2, x, y;</span><br><span class="line">n1 = new One();</span><br><span class="line">n2 = new Two();</span><br><span class="line">x = this.id(n1);</span><br><span class="line">y = this.id(n2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>1-object</code>的时候因为这里两次调用<code>id</code>函数都是在<code>c</code>对象下的因此导致<code>c:n1</code>和<code>c':n2</code>都指向<code>c_this</code>函数从而引入虚假信息，而<code>1-call-site</code>则因为是两个<code>call-site</code>因此更加精确。</p><p>故本质上很多时候指针分析本质和语言的性质有非常密切的关系。</p><h5 id="type-sensitivity">Type sensitivity</h5><p>该版本的<code>context</code>使用一系列<code>InType</code>组成，不深入了。</p><p>至此指针分析的学习结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;过程间分析需要基于程序的&lt;code&gt;Call Graph&lt;/code&gt;来完成。由于&lt;code&gt;CHA Analysis&lt;/code&gt;过度追求速度造成误报——而&lt;code&gt;false positive&lt;/code&gt;对于常量传播这样的&lt;code&gt;must&lt;/code&gt;分析来说是不可接受的。因此指针分析在&lt;code&gt;POPL&#39;1980&lt;/code&gt;被第一次提出&lt;a href=&quot;https://static.aminer.org/pdf/PDF/000/546/844/interprocedural_data_flow_analysis_in_the_presence_of_pointers_procedure.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure Variables, and Label Variables&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Pointer Analysis computes an over-approximation of the set of which memory-locations(objects) a pointer can point to.&lt;/p&gt;
&lt;p&gt;指针分析除了可以构建&lt;code&gt;Call Graph&lt;/code&gt;等程序基本信息之外，还可以用于编译优化，程序鲁棒性和安全等各个领域，是最基础的静态分析算法之一——比如流行的别名分析&lt;code&gt;Alias Analysis&lt;/code&gt;就是从指针分析中派生出来的:Alias information can be derived from points-to relations.在指针分析的输出指向关系中是否有两个指针可以指向同一个对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(2-CHA-Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/05/10/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-2-CHA-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/05/10/NJU静态程序分析-2-CHA-Analysis/</id>
    <published>2021-05-10T10:23:58.000Z</published>
    <updated>2022-03-16T10:12:10.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>根据<code>safe-approximation</code>，过程内数据流分析<code>Intraprocedural</code>对所有的函数调用<code>method call</code>做出过度保守的假设——即所有分析结果必须<code>safe</code>，而根据<code>Lattice</code>理论这种处理会使<code>must</code>和<code>may</code>分析都变的<code>less precise</code>。所以引入<strong>过程间数据流分析</strong><code>Interprocedural Analysis</code>，通过<code>Call Graph</code>来实现过程间的数据流传递，从而进一步提高分析的精度。<strong>因此如何构造这些<code>call-graph</code>就是过程间分析的关键环节。</strong></p><p>For Better precision, we need Interprocedural Analysis：propagate data-flow information along <strong>interprocedural control-flow edges</strong> i.e., call and return edges</p><p><code>Class hierarchy analysis</code>是用来构造<code>Call Graph</code>的一种经典方法——也是过程间分析的基础。</p><a id="more"></a><h3 id="cha">CHA</h3><p>从下面开始我们开始研究包含函数调用的程序——调用图反映了程序中的调用关系<code>calling relationships</code>，确切的说就是<strong>一系列从调用点<code>call-sites</code>指向目标方法<code>callees</code>的边的集合</strong>，可以看出<code>Call Graph</code>是极其重要的程序信息。</p><p>如何构造<code>Call Graph</code>？鉴于<code>OOPLs</code>语言是目前软件领域绝对的领导者，因此本节课也主要针对<code>Java</code>来构造调用图。一共有四种构造算法:</p><ul><li>Class hierarchy analysis(CHA)</li><li>Rapid type analysis(RTA)</li><li>Variable type analysis(VTA)</li><li>Pointer analysis(k-CFA)</li></ul><p>它们的分析精度从上到下越来越准确，而分析时间也相应的越来越长，这里主要介绍第一种CHA。</p><h4 id="methods-callsinvocations-in-java">Methods Calls(invocations) in Java</h4><table><colgroup><col style="width: 12%"><col style="width: 10%"><col style="width: 46%"><col style="width: 30%"></colgroup><thead><tr class="header"><th></th><th>Static call</th><th>Special call</th><th>Virtual call</th></tr></thead><tbody><tr class="odd"><td>Instruction</td><td>Invokestatic</td><td>Invokespecial</td><td>Invokeinterface/invokevirtual</td></tr><tr class="even"><td>Receiver objects</td><td>⨉</td><td>✓</td><td>✓</td></tr><tr class="odd"><td>Target methods</td><td>Static methods</td><td>constructors/private instance methods/superclass instance methods</td><td>Other instance methods</td></tr><tr class="even"><td>#Target methods</td><td>1</td><td>1</td><td>≥1(<font color="red">polymorphism</font>)</td></tr><tr class="odd"><td>Determinacy</td><td>Compile-time</td><td>Compile-time</td><td>Run-time</td></tr></tbody></table><p>Java的函数调用主要分为三种类型。其中<code>static call</code>调用静态方法因此没有<code>instance</code>实例，而编译器在编译期就可以解析出函数地址。<code>special call</code>有三个目标函数——构造函数，私有成员函数以及父类函数，因为该调用的<code>receiver object</code>类型确定所以也可以再编译期确定。难点在于虚函数调用，<strong>所谓运行时绑定指的是只有在运行时才可以确定其目标函数（多态），</strong>因此构造调用图的关键就在于对虚函数调用完成构建。</p><h4 id="method-dispatch">Method Dispatch</h4><p>一个虚函数调用<font color="blue">o<sup>1</sup>.foo(...)<sup>2</sup></font>在运行时根据两点被解析：</p><ul><li><code>Receiver object</code>的类型，即变量o指向的对象类型</li><li>在<code>call site</code>的函数签名，即foo(...)</li></ul><p>关于对象类型，是变量指向的实际类型——比如<code>A x = new B()</code>和<code>B x = new B()</code>的<code>receiver objecte</code>类型都是<code>B</code>。关于函数签名<code>signatrue</code>的功能就是能唯一代表一个函数：</p><ul><li>Signatrue = <font color="red">class type</font> + <font color="blue">method name</font> + <font color="green">descriptor</font></li><li><font color="green">Descriptor</font> = <font color="green">return type</font> + <font color="green">parameter types</font></li></ul><p>比如<code>class C{T foo(P p, Q q, R r){...}}</code> 中函数foo的函数签名可以写成<code>C.foo(P, Q, R)</code>。</p><p>接着引入函数<font color="red">Dispatch</font>(c, m)来模拟运行时函数自动绑定的过程：</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>其中<code>c</code>是<code>receiver object</code>的类型，而<code>m</code>就是<code>call sites</code>的函数签名。<code>Dispatch</code>函数在<code>c</code>中寻找和函数签名<code>m</code>相符合的<strong>非抽象函数<code>non-abstract method</code></strong>，如果没有找到则去<code>c</code>的父类中继续找直到找到为止，该函数是CHA分析的核心。</p><h4 id="cha-1">CHA</h4><p><code>CHA</code>是Jeffrey Dean在ECOOP上提出来的一种优化算法<a href="https://www.researchgate.net/profile/David-Grove/publication/2509356_Optimization_of_Object-Oriented_Programs_Using_Static_Class_Hierarchy_Analysis/links/0912f50b6c1a600bb9000000/Optimization-of-Object-Oriented-Programs-Using-Static-Class-Hierarchy-Analysis.pdf?origin=publication_detail" target="_blank" rel="noopener">Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis</a>。</p><p><strong>该算法可以根据<code>receiver object</code>的声明类型（区别于实际类型）来解析虚函数调用。</strong>它需要整个程序的继承链作为信息基础，比如<code>A a = ...;  a.foo()</code>中该算法假设变量<code>a</code>可以指向<code>class  A</code>及其所有子类，据此解析出多个可能的目标方法。下面是CHA的算法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Resolve(cs) &#123;</span><br><span class="line">T = &#123;&#125;</span><br><span class="line">m = method signature at cs</span><br><span class="line">if cs is a static call then</span><br><span class="line">T = &#123;m&#125;</span><br><span class="line">if cs is special call then</span><br><span class="line">c_m = class type of m</span><br><span class="line">T = &#123;Dispatch(c_m, m)&#125;</span><br><span class="line">if cs is a virtual call then</span><br><span class="line">c = declared type of receiver variable at cs</span><br><span class="line">foreach c&apos; that is a subclass of c or c itself do</span><br><span class="line">add Dispatch(c&apos;, m) to T</span><br><span class="line">return T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对<code>Java</code>的三种调用类型都做了解析，参数<code>cs</code>是程序中的调用点——即每一种调用实际发生的地方。<code>static call</code>可以直接根据函数签名得到目标函数；对于<code>special call</code>由于进行<code>super-call</code>调用的时候需要进一步解析父类中的函数（还不能保证父类一定存在函数需要进一步上升）所以使用了<code>Dispatch</code>函数。</p><p><strong>虚函数调用只需要拿到在<code>call-site</code>处<code>receiver variable</code>的声明类型，然后对该类型以及该类型的所有子类对象做Dispatch解析即可。</strong></p><p>该算法只考虑调用点处<code>reveriver variable</code>的类型和它的继承链而忽略了其他数据流和控制流信息，因此速度上非常快，但是精度一般。故其主要应用就是IDE的补全上，满足速度快贴合需求但是精度也保持在一个很好的接受范围内。</p><h4 id="call-graph-construction">Call Graph Construction</h4><p>在CHA分析的基础上，我们可以设计出构造调用图<code>Call Graph</code>的完整算法，该算法应用<code>BFS</code>的思路从<code>entry</code>出发对每一个<code>method</code>，解析该函数在所有调用点<code>cs</code>的目标方法<code>Resolve(cs)</code>直到所有的<code>method</code>都完成解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BuildCallGraph(m_entry) &#123;</span><br><span class="line">WL = [m_entry], CG = &#123;&#125;, RM = &#123;&#125;</span><br><span class="line">while WL is not empty do</span><br><span class="line">remove m from WL</span><br><span class="line">if m ∉ RM then</span><br><span class="line">add m to RM</span><br><span class="line">foreach call-site cs in th m do     // Resolve target methods via CHA</span><br><span class="line">T = Resolve(cs)</span><br><span class="line">foreach traget method m&apos; in T do</span><br><span class="line">add cs ⟶ m&apos; to CG    // Add call edges to call graph</span><br><span class="line">add m&apos; to WL</span><br><span class="line">return CG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>WL包含即将被解析的<code>method</code></li><li>CG包含构建出来的调用边<code>call-edges</code>集合</li><li>RM包含已经解析完成的<code>method</code></li></ul><h3 id="inter-procedural-control-flow-graph">Inter-procedural Control-Flow Graph</h3><p>构建<code>Call Graph</code>的目的就是为了进一步构建<code>ICFG</code>，如果说<code>CFG</code>表示单个函数的结构，那<code>ICFG</code>表示的就是整个程序的结构。有了<code>ICFG</code>我们就可以进行过程间分析了，<code>ICFG</code>主要由两部分构成:</p><ul><li>程序中所有函数的CFG</li><li>两种新加的edges<ul><li>Call edges: 从<code>call-site</code>指向<code>callees</code>的<code>entry</code></li><li>Return edges: 从<code>callees</code>的返回语句指向<code>return-site</code>(紧跟着<code>call-site</code>的语句)</li></ul></li></ul><p><img src="2.png" width="50%" height="50%" alt=""></p><p>而这两种新加的边信息就来自于<code>Call Graph</code>。对于整个程序的<code>ICFG</code>，只需要将函数调用语句单独作为一个<code>Basic Block</code>即可，其他的不变。</p><p>从上图中可以看到，数据流从<code>call-site</code>沿着<code>call edges</code>流向<code>callees</code>，接着从<code>callees</code>的返回语句流向<code>return-site</code>。<strong>而<code>call-site</code>和<code>return-site</code>之间还有一条边<code>call-to-return edge</code>是为了传递本地函数的数据流，</strong>以免这些信息跟着<code>call graph</code>绕远路。</p><h3 id="inter-procedural-data-flow-analysis">Inter-procedural Data-Flow Analysis</h3><p>在构建好<code>ICFG</code>之后，就可以进行过程间数据流分析了。</p><p>这里对比过程内<code>Intraprocedural</code>和<code>Interprocedural</code>两种分析：</p><table><thead><tr class="header"><th></th><th><font color="red">Intra</font>procedural</th><th><font color="red">Inter</font>procedural</th></tr></thead><tbody><tr class="odd"><td>Program representation</td><td>CFG</td><td>ICFG = CFGs + <font color="red">call &amp; return edges</font></td></tr><tr class="even"><td>Transfer functions</td><td>Node transfer</td><td>Node transfer + <font color="red">edge transfer</font></td></tr></tbody></table><p>可以看到过程间分析比过程内分析多了一些<code>edge analysis</code>。从理论上看这些<code>edge analysis</code>完成了函数调用过程中的跨函数数据流比如参数，返回值的传递。</p><ul><li>Call edge transfer: 传递参数（从call-site到entry of callee）</li><li>Return edge transfer: 传递返回值(从return ofcallee到return-site)</li></ul><p>而过程间分析和过程内分析的<code>Transfer Function</code>相比，多了一条规则：</p><p>For each call node(call-site), kill data-flow value for the LHS variable. Its value will flow to return site along the return edges.</p><p>即要<code>kill</code>掉调用点语句的<strong>左值变量</strong>。</p><p><img src="3.png"" width="50%" height="50%" alt=""></p><p>因为左值的数据流会在<code>callee</code>中得到更新最终沿着<code>return edge</code>传递，而如果该值在<code>call-to-return edge</code>中继续传递下去，在<code>merge</code>的时候回损失精度比如常量传播中c<sub>1</sub> ⊓ c<sub>2</sub> = NAC。故拿常量传播来说的话，<code>Interprocedural constant propagation</code>要比<code>Intraprocedural constant propagation</code>更加精确。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;根据&lt;code&gt;safe-approximation&lt;/code&gt;，过程内数据流分析&lt;code&gt;Intraprocedural&lt;/code&gt;对所有的函数调用&lt;code&gt;method call&lt;/code&gt;做出过度保守的假设——即所有分析结果必须&lt;code&gt;safe&lt;/code&gt;，而根据&lt;code&gt;Lattice&lt;/code&gt;理论这种处理会使&lt;code&gt;must&lt;/code&gt;和&lt;code&gt;may&lt;/code&gt;分析都变的&lt;code&gt;less precise&lt;/code&gt;。所以引入&lt;strong&gt;过程间数据流分析&lt;/strong&gt;&lt;code&gt;Interprocedural Analysis&lt;/code&gt;，通过&lt;code&gt;Call Graph&lt;/code&gt;来实现过程间的数据流传递，从而进一步提高分析的精度。&lt;strong&gt;因此如何构造这些&lt;code&gt;call-graph&lt;/code&gt;就是过程间分析的关键环节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For Better precision, we need Interprocedural Analysis：propagate data-flow information along &lt;strong&gt;interprocedural control-flow edges&lt;/strong&gt; i.e., call and return edges&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class hierarchy analysis&lt;/code&gt;是用来构造&lt;code&gt;Call Graph&lt;/code&gt;的一种经典方法——也是过程间分析的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(1-Data Flow Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/05/04/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-1-Data-Flow-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/05/04/NJU静态程序分析-1-Data-Flow-Analysis/</id>
    <published>2021-05-03T16:12:53.000Z</published>
    <updated>2022-03-16T10:20:48.443Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>编译器中大部分机器无关的全局优化是基于<code>Data-flow Analysis</code>实现的。数据流分析技术从代码中收集程序语义相关的信息，是程序分析的基础。</p><p><strong>In each data-flow analysis application, we associate with every program point a data-flow value that represents an abstraction of the set of all possible program states that can be observed for that point.</strong></p><p>在工业界的<a href="https://www.zhihu.com/question/41959902" target="_blank" rel="noopener">主流编译器</a>中，<code>C</code>系的<code>LLVM</code>，<code>Java</code>系的<code>HotSpot</code>都是基于<code>SSA</code>做数据流分析而不是传统的<code>lattice</code>。南大这节课中是基于<code>Lattice</code>来讲解过程内<code>Intra-procedural</code>，无别名<code>no aliases</code>的经典数据流分析框架。</p><a id="more"></a><h3 id="applications">Applications</h3><h4 id="overview">Overview</h4><h5 id="cfg">CFG</h5><p>分析框架都是建立在<code>control-flow-graph</code>上的，这是一种<code>IR</code>——由<code>basic-blocks</code>通过<code>control-flows</code>连接而成，可以分别看成是<code>CFG</code>的<code>nodes</code>和<code>edges</code>。 如何通过源码（单个函数）生成<code>CFG</code>见课件。</p><p><img src="1.png" width="50%" height="50%" alt=""></p><h5 id="abstract-1">Abstract</h5><p>数据流分析用来描述所谓<strong>数据</strong>如何在<strong>CFG</strong>中流动。这里的<code>data</code>指的是程序语义信息的一种<code>abstraction</code>，<code>CFG</code>中的<code>nodes</code>和<code>edges</code>分别映射<code>transfer-function</code>和<code>control-flow handling</code>。所以整个分析是建立在一套成熟的理论框架之上的。</p><ul><li><code>data(application-specific)</code>: 不同的数据流分析应用会有不同的抽象值<code>value</code>，比如分析变量数值时：<code>+;-;0;UND;UNKNOW;</code><ul><li><code>domain</code>: 抽象数据流的值域即所有<code>value</code>定义的集合</li></ul></li><li><code>transfer-functions</code>:不同的程序会有不同的<code>CFG</code>表示，进一步需要深刻<code>CFG</code>中<code>statements</code>，<code>basic-blocks</code>在被映射成<code>transfer-functions</code>时的区别和联系</li><li><code>control-flows</code>:控制流基本上只有三个——顺序，汇聚以及分流</li></ul><h5 id="safety-analysis">safety analysis</h5><p>大部分的分析框架要求分析结果是<code>Sound</code>的即<code>over-approximation</code>。而实际上并非所有如此——这里正式将所有分析分成两类：<code>may analysis</code>和<code>must analysis</code>。</p><ul><li><code>may analysis</code>: 要求分析结果中必须全部包含所有正确答案，换个角度理解就是<strong>不放过任何一个动态运行时的可能出错的行为</strong>——一旦发现就要报错，即<code>over</code>的概念</li><li><code>must analysis</code>: 要求分析结果一定是正确的，即不能有误报，即<code>under</code>的概念</li></ul><p>而<code>over</code>和<code>under</code>在不同的应用中都代表了各自最<code>safe</code>的结果，因此所有的静态程序分析可以总结成：<code>abstraction</code>和<code>safe-approximation</code>两个阶段，不同的数据流分析有不同的<code>abstraction</code>和<code>safe-approximation strategies</code>即不同的<code>transfer-functions</code>和<code>control-flow handlings</code>。</p><h4 id="preliminaries">Preliminaries</h4><h5 id="input-and-output-states">Input and Output States</h5><p>所有的操作对象都是在一个<code>CFG</code>中。</p><p><code>statements</code> 是<code>CFG</code>中的执行的最小单位——每一条<code>statements</code>的执行都会改变程序的状态。</p><p><strong>每一个<code>statements</code>前后都有自己的<code>program point</code>分别代表<code>input/output state</code>，记作<code>IN[S_i]/OUT[S_i]</code>。又因为一个<code>basic-blocks</code>中的所有<code>statements</code>可以结合在一起（因为BB内部只能顺序执行）故每个<code>basic-blocks</code>开始和结束也有自己的<code>program point</code>，记作<code>IN[B_i]/OUT[B_i]</code>。</strong></p><p><code>control flow</code>表示了各个<code>basic-blocks</code>的执行顺序关系。分为三种：顺序，汇聚和分流</p><p><img src="2.png" width="50%" height="50%" alt=""></p><ul><li>顺序：<code>IN[s2] = OUT[s1]</code></li><li>汇聚: <code>IN[s2] = OUT[s1] ^ OUT[s3]</code><ul><li>操作符<code>^</code>指的是<code>meet operator</code>，不同的算法有不同操作比如并集，交集等</li></ul></li><li>分流: <code>IN[s2] = IN[s3] = OUT[s1]</code></li></ul><p><strong>需要关注的是每个BB或者Statement的<code>program point</code>，数据流分析会给每个<code>program point</code>一个<code>data-flow value</code>来抽象出当前位置程序的部分语义信息，再进一步利用各种<code>safe-approximation-directed constraints</code>以达到分析目的，这里的<code>constraints</code>具体指的是不同的<code>transfer functions</code>和<code>control flow handlings</code>。</strong></p><h5 id="notations-for-transfer-functions-constraints">Notations for Transfer Functions' Constraints</h5><ul><li>Forward Analysis： OUT[s] = F_s(IN[s]),其中F_s就是针对具体输入的<code>Transfer Function</code>，前向分析是从输入推导输出</li></ul><p><img src="3.png" width="50%" height="50%" alt=""></p><ul><li>Backward Analysis：IN[s] = F_s(OUT[s]),后向分析是从输出推导输入</li></ul><p><img src="4.png" width="50%" height="50%" alt=""></p><h5 id="notations-for-control-flows-constraints">Notations for Control Flows' Constraints</h5><h6 id="control-flow-within-a-bb">control flow within a BB</h6><p>在一个BB内部，<code>IN[S_(i+1)] = OUT[S_(i)], for all i = 1, 2,...n-1</code>——这个很好理解，一个BB中的<code>statements</code>只能顺序执行故只会有一个输入输出。</p><h6 id="control-flow-among-bbs">control flow among BBs</h6><p>对于一个<code>basic block</code>来说：<code>IN[B] = IN[S_1];   OUT[B] = OUT[S_n]</code>。 而BB之间的执行不仅仅是顺序关系。还有汇聚和分流的执行顺序。</p><p>首先是汇聚：<code>OUT[B] = F_b(IN[B])</code>，其中<code>F_b = F_sn * ...* F_s2 * F_s1</code>也就是一个BB的的<code>Transfer Function</code>由内部<code>statements</code>各自的<code>transfer function</code>组成，<code>IN[B] = ^ OUT[P]</code>，表示所有汇聚的输出的并集都成为下一个的输入，这里的<code>^</code>就是表示并集的<code>meet operator</code>而<code>P</code>表示<code>B</code>的所有前驱<code>basic blocks</code>。</p><p><img src="5.png" width="50%" height="50%" alt=""></p><p>其次是分流：<code>IN[B] = F_b(OUT[B])</code>;<code>OUT[B] = ^IN[S]</code>这里表示<code>B</code>的输出都成为所有<code>S</code>的输入，<code>S</code>是<code>B</code>的所有后继。</p><p><img src="6.png" width="50%" height="50%" alt=""></p><p>有了前面的基础，下面先介绍三种经典的数据流分析算法：</p><h4 id="reaching-definitions-analysis">Reaching Definitions Analysis</h4><h5 id="定义">定义</h5><p>A definition d at <strong>program point</strong> p reaches a point q if <strong>there is</strong> a path from p to q such that d is not &quot;killed&quot; along that path.(A definition of a variable is a statement that assigns a value to v).</p><p><img src="7.png" width="50%" height="50%" alt=""></p><p>首先<strong><code>definition</code>-定义</strong>指的是对变量<code>v</code>进行赋值的语句。一般来讲<strong>定义</strong>都是从一个<code>program point</code>上完成的。</p><p>在p点上的，一个对变量<code>v</code>的<code>definition</code>能<code>reach</code>到某一个新的点q，取决于在控制流上是否<strong>存在</strong>一条从p到q的路径，同时在这条路径上该变量<code>v</code>不会被重新定义，就说是这个<code>definition</code>可以reach到q点。</p><h5 id="分析类型">分析类型</h5><p>从定义的<code>there is</code>可以看出，这是一个<code>may analysis</code>——即控制流上从p到q的所有路径而言，只需要有一条路径没有被重新定义，那这两个<code>program point</code>之间就是<code>Reached</code>的。并且还知道这是一个<code>forward analysis</code>——因为是前面的<code>program point</code>上的<code>definition</code>可以<code>reach</code>到后面的<code>program point</code>。</p><h5 id="应用">应用</h5><p>该分析可以用来<strong>检查未定义的变量</strong>。对于所有需要检测的变量，在<code>CFG</code>的<code>entry</code>入口处都赋值为<code>dummy definition</code>——实际上就是一个<code>undefined</code>的标签，如果变量<code>v</code>的可以<strong>到达</strong>某一个使用点，那这个变量就有可能是未定义前使用。</p><h5 id="细节">细节</h5><h6 id="data-flow-valuesfact">Data Flow Values/Fact</h6><p>首先数据流分析需要对分析的对象进行抽象，<strong>这里使用<code>BitVector</code>来表示一个<code>CFG</code>（即一段过程内程序中）上所有变量的<code>definition</code>。</strong>（注意关注对象<code>definition</code>不是变量本身，而是定义这个变量的所有<code>program point</code>。）</p><h6 id="transfer-function">Transfer Function</h6><p>根据<code>IN</code>求出每一个<code>statemetns/basic blocks</code>的<code>OUT</code>的。由该分析的目的可以得出：<code>OUT[B] = gen_B ∪ (IN[B] - kill_B)</code>，即对于每一个<code>program point</code>来说，其<code>OUT</code>就是在该点处新增加的对变量的<code>definitions</code>除掉别处这些变量的<code>definitions</code>。</p><h6 id="control-flow">Control Flow</h6><p>根据上一个<code>statements/basic blocks</code>的<code>OUT</code>求出下一个的<code>IN</code>。因为作为<code>may</code>分析，其不放过任何一个运行时的行为，所以针对所有留到该<code>IN</code>的<code>OUT</code>都要接收。即<code>IN[B] = ∪_p(p是B所有的前驱结点)OUT[P]</code>。</p><h5 id="算法">算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INPUT: CFG(kill_B and gen_B computed for each basic blocks B)</span></span><br><span class="line"><span class="comment">OUTOUT: IN[B] and OUT[B] for each basic block B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">OUT[entry] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (each basic block B\entry)</span><br><span class="line">OUT[B] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(changes to ant OUT occur) </span><br><span class="line"><span class="keyword">for</span>(each basic blocks B\entry) &#123;</span><br><span class="line">   IN[B] = ∪_OUT[P];</span><br><span class="line">   OUT[B] = gen_B ∪ (IN[B] - kill_B);      </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是非常典型的<strong>不动点算法</strong>，如果我们简化模型仅仅只是关注每一个<code>basic blocks</code>的<code>IN</code>和<code>OUT</code>,会发现对于有限的<code>definition</code>集合，在经过多次迭代之后，正向的增加<code>gen/survivors</code>一定会导致<code>OUT</code>达到一个定值。</p><h4 id="live-variables-analysis">Live Variables Analysis</h4><h5 id="定义-1">定义</h5><p>Live variables analysis tells whether the value of variable v at program point p <strong>could be used </strong>along some path in CFG starting at p. If so, v is live at p; otherwise, v is dead at p.</p><p><img src="8.png" width="50%" height="50%" alt=""></p><p>分析<strong>变量<code>v</code>在一个<code>program point</code>-p上是否是活跃的</strong>，取决于是否存在一条从p点开始一直到程序执行结束的路径，该路径中有使用过<code>v</code>的地方，<strong>并且从p点到使用点期间<code>v</code>不可以被重新定义</strong>——则说明该变量<code>v</code>在p点是活跃的。</p><h5 id="分析类型-1">分析类型</h5><p>根据定义可以知道这是一个<code>may</code>分析，该变量只要有使用点则分析结果就是活跃的。又因为分析的过程是从后往前的故该分析也是一个<code>backward analysis</code>。</p><h5 id="应用-1">应用</h5><p>该分析可以用来完成<strong>寄存器分配</strong>。比如在执行到程序的某一点需要将操作数加载到其中一个寄存器中——而这时候所有的<code>registers</code>都满了。如何选择合适的寄存器呢？如果选择的是一个<code>dead</code>不活跃的寄存器值（未来不会被用到），那就可以直接替换掉。而如果这个寄存器中的变量值是活跃的，那后面再次使用到的时候就需要把它再次从内存读到寄存器，浪费了资源。</p><h5 id="细节-1">细节</h5><h6 id="data-flow-valuefact">Data Flow Value/Fact</h6><p>该分析关注的对象，<strong>就是变量本身</strong>，使用<code>BitVector</code>表示。</p><h6 id="transfer-function-1">Transfer Function</h6><p><code>IN[B] = use_B ∪ (OUT[B] - def_B)</code>。这里的<code>use_B</code>指的是<strong>所有在重新定义之前变量的使用点，</strong>通过<code>backward</code>的思路来分析，对于一个<code>basic block</code>，给出其<code>OUT</code>来得到其<code>IN</code>需要关注在BB中变量是否是满足活跃的前提要求的。</p><p><img src="9.png" width="50%" height="50%" alt=""></p><h6 id="control-flow-1">Control Flow</h6><p>因为作为<code>may</code>分析，其不放过任何一个运行时的行为，所以针对所有留到该<code>IN</code>的<code>OUT</code>都要接收。即<code>IN[B] = ∪_s(s是B所有的前驱结点)OUT[s]</code>。</p><h5 id="算法-1">算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INPUT: CFG(def_B and use_B computed for each basic blocks B)</span></span><br><span class="line"><span class="comment">OUTOUT: IN[B] and OUT[B] for each basic block B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IN[<span class="built_in">exit</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (each basic block B\<span class="built_in">exit</span>)</span><br><span class="line">IN[B] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(changes to ant IN occur) </span><br><span class="line"><span class="keyword">for</span>(each basic blocks B\<span class="built_in">exit</span>) &#123;</span><br><span class="line">OUT[B] = ∪_IN[S];</span><br><span class="line">OUT[B] = use_B ∪ (OUT[B] - def_B);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将两个算法的<code>Transfer Func</code>放到一起对比：</p><ul><li>RDA: <code>OUT[B] = gen_B ∪ (IN[B] - kill_B)</code></li><li>LVA: <code>IN[B] = use_B ∪ (OUT[B] - def_B)</code></li></ul><p>会发现很多的数据流分析算法都是<code>GEN/KILL Problem</code>，统计一下公式就是<code>OUT = gen ∪ (IN - kill)</code>。</p><h4 id="available-expressions-analysis">Available Expressions Analysis</h4><h5 id="定义-2">定义</h5><p>An expression x op y is available at program point p if (1) <strong>all paths </strong>from the entry to p must pass through the evaluation of x op y, and (2) <strong>after the last evaluation of x op y, there is no redefinition of x or y</strong>.</p><p><img src="10.png" width="50%" height="50%" alt=""></p><p>在<code>CFG</code>上的所有的复合型表达式都会被拆成三地址码。<strong>判断一个<code>expression</code>-<code>x op y</code>在p点是<code>available</code>的</strong>，取决于从<code>entry</code>到<code>p</code>点所有的路径都必须有该表达式的<code>evaluation</code>求值，并且在最后一个求值之后不能对<code>x/y</code>重新赋值，即就说这个表达式在p点事<code>available</code>的。</p><h5 id="分析类型-2">分析类型</h5><p>必须保证所有的<code>path</code>都有<code>evaluation of expression</code>分析结果才是<code>available</code>。因此这是一个<code>must</code>分析，即不能有误报但可以有漏报，比如下图中的情况，假设<code>x = 3</code>前后都成立那么实际上这个表达式也是可以被优化的，但是根据该<code>must</code>分析的定义这个分析结果是<code>not avaliable</code>的。</p><p><img src="11.png" width="50%" height="50%" alt=""></p><h5 id="应用-2">应用</h5><p>该分析可以用来进行<strong>公共子表达式删除</strong>，即用<code>the last evaluation of available expression</code>直接替换该表达式，从而优化代码。</p><h5 id="细节-2">细节</h5><h6 id="data-flow-valuefact-1">Data Flow Value/Fact</h6><p>顾名思义就是程序中所有的<code>expression</code>。</p><h6 id="transfer-function-2">Transfer Function</h6><p>根据定义<code>OUT[B] = gen_B ∪ (IN[B] - kill_B)</code>，对于所有的输入的表达式，产生的新表达式并且删除掉在其变量被重新赋值的表达式。</p><h6 id="control-flow-2">Control Flow</h6><p>因为是<code>must</code>分析对于所有的情况都要考虑，所以<code>IN[B] = ∩(p:predecessors of B)OUT[p]</code>。</p><h5 id="算法-2">算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INPUT: CFG(kill_B and gen_B computed for each basic blocks B)</span></span><br><span class="line"><span class="comment">OUTOUT: IN[B] and OUT[B] for each basic block B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">out[entry] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (each basic block B\entry)</span><br><span class="line">OUT[B] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(changes to ant OUT occur) </span><br><span class="line"><span class="keyword">for</span>(each basic blocks B\entry) &#123;</span><br><span class="line">IN[B] = ∪_IN[P];</span><br><span class="line">OUT[B] = gen_B ∪ (OUT[B] - kill_B);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于这三种分析来说，如何理解<code>may/must</code>，<code>false positive/false negative</code>和在所有<code>CFG</code>上程序的运行时行为之间的关系是很关键的问题。</strong></p><h3 id="foundations">Foundations</h3><h4 id="mathematics-prerequisite">Mathematics Prerequisite</h4><h5 id="partial-order">Partial Order</h5><p>定义<code>poset</code>偏序集<code>(P, ≼)</code>表示一个集合<code>p</code>，符号<code>≼</code>定义在该集合的<code>partial ordering</code>有如下性质：</p><ul><li><em>Reflexivity</em>. ∀ x∊P, x≼x<br></li><li><em>Antisymmetry.</em> ∀ x,y∊P, x≼y ∧ y≼x ⟹ x=y.</li><li><em>Transitivity</em>. ∀ x,y,z∊P, x≼y ∧ y≼z ⟹ x≼z.</li></ul><p>如何理解偏序-<code>partial ordering</code>？<strong>在集合<code>p</code>中定义了一种<code>order</code>，但并不是所有两个元素之间都必须满足这种<code>order</code>——即集合中两个元素之间可以是<code>incomparable</code>的</strong>。比如<code>power set</code>是非常典型的<code>poset</code>。</p><p><img src="12.png" width="50%" height="50%" alt=""></p><h5 id="upper-and-lower-bounds">Upper and Lower Bounds</h5><p>给定偏序集<code>(P, ≼)</code>以及该集合的一个子集<code>S ⊆ P</code>。我们使用集合<code>P</code>中的<strong>一个元素<code>u ∊ P</code></strong>来定义<strong>集合<code>S</code>的<code>upper bound</code>和<code>lower bound</code>:</strong></p><ul><li>∀x∊S, x≼u ⟹ u∊P is an <em>upper bounds</em> of S</li><li>∀x∊S, l≼x ⟹ l∊P is an <em>lower bound</em> of S</li></ul><p>在此基础上，我们进一步定义<strong>集合<code>S</code>的<code>least upper bound(lub or join)</code>简写为<code>⊔S</code>，以及<code>greatest lower bound(glb or meet)</code>简写为<code>⊓S</code>:</strong></p><ul><li>for every <em>upper bound</em> of S, say u: <code>⊔S ≼ u</code></li><li>for every <em>lower bound</em> of S, say l:<code>l ≼ ⊓S</code></li></ul><p>根据<code>⊔S/⊓S</code>的定义，如果集合<code>S</code>中只有两个元素<code>a and b</code>。那么：</p><ul><li><code>⊔S</code> ≡ <code>a ⊔ b</code>(a和b的并集)</li><li><code>⊓S</code> ≡ <code>a ⊓ b</code>（a和b的交集）</li></ul><p><strong>不是所有的偏序集都有<code>⊓S/⊔S</code>，但是如果一个偏序集同时有<code>⊔S/⊓S</code>的话，那该偏序集就是唯一的。</strong></p><h5 id="lattic">Lattic</h5><p>对于一个偏序集<code>P</code>，如果集合中<strong>任意两个元素（构成的子集S）</strong><code>a</code>和<code>b</code>，它们的<code>a⊔b</code>和<code>a⊓b</code>都存在，则这个偏序集就是一个<code>lattice</code>。</p><ul><li>Given poset (P, ≼), ∀a,b∊P, if ∃ a⊔b, ∃ a⊓b ∃ then P is calles a lattice</li></ul><p>在此基础上，如果这个偏序集P中的任意两个元素只有<code>a⊔b</code>或者<code>a⊓b</code>中的一个，则这个偏序集分别称为<code>join semilattice</code>和<code>meet semilattice</code>。</p><h5 id="complete-lattice">Complete Lattice</h5><p>对于一个偏序集<code>P</code>，如果集合中<strong>任意一个子集S</strong>都存在<code>⊔S</code>和<code>⊓S</code>，则这个偏序集便称为<code>complete lattice</code>。<strong>全格和格的区别主要在于，格对其子集的要求是只需要有两个元素而全格对子集元素的数量没有限制。</strong></p><p>在此基础上，对于一个<code>complete lattice</code>，都有存在：</p><ul><li>a greatest element ⊤ = ⊔P called <font color="red">top</font></li><li>a least element ⊥ = ⊓P called <font color="blue">bottom</font></li></ul><p><strong>每一个<code>finite lattice</code>都是一个<code>complete lattice</code>。但是一个<code>complete lattice</code>却不一定是<code>finite lattice</code></strong>。</p><h5 id="product-lattice">Product Lattice</h5><p>给定多个<code>lattice</code>-<code>Li = (Pi, ≼i)</code>的笛卡尔积构成的一个新的<code>lattice，</code>如果这些<code>lattice</code>每一个都有<code>lub</code>和<code>glb</code>的话<strong>(这里没有说明子集S的个数主要是因为它可以是只有两个元素的普通<code>lattice</code>也可以是包括任意元素的<code>complete lattice</code>，换句话说如果一个<code>product lattice</code>是<code>complete lattice</code>的笛卡尔积，那么它本身也是一个<code>complete lattice</code>)</strong>则称其积为<code>product lattice</code>并满足下面性质:</p><ul><li>P = P1 x P2...x Pn</li><li>(x1, ..., xn) ≼ (y1, ..., yn) ≡ (x1 ≼ y1)∧...∧(xn≼yn)</li><li>(x1, ..., xn) ⊔ (y1, ..., yn) ≡ (x1 ⊔ y1)∧...∧(xn ⊔ yn)</li><li>(X1, ..., xn) ⊓ (y1, ..., yn) ≡ (x1 ⊓ y1)∧...∧(xn ⊓ yn)</li></ul><p>即一个<code>product lattice</code>中的每一个元素<code>lattice</code>满足的性质它都满足。</p><h4 id="data-flow-analysis-framework-via-lattice">Data Flow Analysis Framework via Lattice</h4><h5 id="iterative-algorithm">Iterative Algorithm</h5><p>回顾前面三个具体的数据流分析算法，即相应的<code>may/must</code>分析从各自的初始状态出发，<strong>经过不断迭代（Transfer Function/Control Flow）</strong>最终到达<strong>不动点</strong>——整个程序的数据流不会发生变化，算法停止。</p><p>这里从更具体的角度来理解这个算法：</p><p>给定一个<code>CFG</code>，其中有<code>k</code>个节点(这里简化成为只带一个<code>statement</code>的<code>basic block</code>)。<strong>而迭代算法在每次迭代中更新这k个节点的输出<code>OUT</code></strong>，引入一个<code>k-tuple</code>:</p><ul><li>(OUT[n<sub>1</sub>], OUT[n<sub>2</sub>], ..., OUT[n<sub>k</sub>]) ≡ <font color="red">(V<sub>1</sub> x V<sub>2</sub> ... x V<sub>k</sub>)</font></li></ul><p><strong><code>k-tuple</code>就是每一次迭代后所有节点输出值的<code>product</code>记为V<sup>k</sup>。</strong>而更具体的解释就是<strong>不同的数据流分析算法在每次迭代中通过应用各种<code>Transfer Function/Control Flow</code>来更新<code>k-tuple</code>的值——可以将每一次迭代抽象出成为一个函数:F: V<sup>k</sup> ⟶ V<sup>k</sup></strong>。而当最后一次迭代的输出没有发生变化便到达了不动点。</p><p><img src="13.png" width="50%" height="50%" alt=""></p><p>This general <em>iterative algorithm</em> produces a solution to data flow analysis，根据<strong>函数F的一个不动点</strong>的定义：</p><ul><li>X is a <font color="yellow">fix point</font> of Function F if <font color="yellow">X = F(X)</font>&gt;</li></ul><p>可以得到<font color="red">当把每一个迭代抽象成为一个函数的时候，<code>Iterative Algorithm</code>最终会到达一个<strong>不动点</strong>，而这个<strong>不动点</strong>就是数据流分析的一个结果</font>。</p><h5 id="data-flow-analysis-framework-via-lattice-1">Data Flow Analysis Framework via Lattice</h5><p>定义一个数据流分析框架主要有三个部分(<font color="red">D</font>, <font color="green">L</font>, <font color="blue">F</font>):</p><ul><li><font color="red">D</font>: 指的是分析的方向是<code>backwwards/forwards</code></li><li><font color="green">L</font>: 核心部分是<code>lattice</code>，代表所分析的<strong>数据流值域</strong>，和<strong>一个<code>meet⊓</code>或者<code>join⊔</code>运算符</strong>（一般一个数据流分析算法只会用到其中一个运算符——故其实是<code>semilattice</code>）</li><li><font color="blue">F</font>: 指的是分析中的<code>Transfer Functions</code></li></ul><p><strong>分析框架就可以看成是在一个<code>lattice</code>的值上不停的迭代<code>transfer functions</code>和<code>join/meet operations</code></strong>。</p><h5 id="fixed-point-theorem">Fixed Point Theorem</h5><p>在学完<strong><code>Iterative Algorithm</code></strong>以及<strong><code>Data FLow Analysis Framework</code></strong>之后，我们需要进一步理解这两者之间的关系，并更深层次的理解<strong>在<code>lattice</code>上定义的函数的不动点原理-<code>Fixed Point Theorem</code></strong>，首先对<code>Iterative Algorithm</code>提出一些核心的问题:</p><ul><li>迭代算法能保证<strong>一定会到达不定点么？</strong></li><li>假设可以到达不动点，那这个<strong>不动点是唯一的么</strong>，或者<strong>通过迭代算法到达的不动点是最精确的么？</strong></li><li>假设可以到达不动点，那<strong>什么时候可以到达？</strong></li></ul><p>前两个问题引出了<strong>不动点理论及其存在性以及精确性</strong>。由于前面介绍的<code>Iterative Algorithm</code>也是建立在<code>Lattice</code>之上的，所以为了<strong>回答这三个<code>Iterative Algorithm</code>有关的问题，首先应该引入建立在<code>Lattice</code>上的函数并研究该函数不动点的性质，最后将这个函数与<code>Iterative Algorithm</code>联系起来。</strong></p><h6 id="monotonicity">Monotonicity</h6><p>引入<strong>在<code>Lattice</code>定义上的函数f</strong>并定义其单调性:</p><ul><li><code>f: L ⟶ L (L is a Lattice)</code> is monotonic if ∀x,y∊L, x≼ y ⟹ f(x) ≼ f(y)</li></ul><p>在此基础上引入<code>Fixed-Point Theorem</code>:</p><p><font color="red">对于一个<code>complete lattice(L, ≼)</code>，如果①在其上的函数<code>f:L⟶L</code>是单调的，②L是<code>finite lattice</code>： 那么通过迭代f(⊥), f(f(⊥)), ..., f^k(⊥)可以得到<code>least fixed point</code>；  通过迭代f(⊤), f(f(⊤)), ..., f^k(⊤)可以得到<code>greatest fixed point</code>。</font></p><p>可以通过证明该理论来回答前两个问题。证明分为两步:</p><ul><li>不动点的存在</li><li>迭代到达最小/大不动点</li></ul><h6 id="proof">Proof</h6><blockquote><p><em>Proof-Existence of Fixed Point:</em></p><p>​ <em>∵ <code>⊥</code>是<code>Lattice</code>最小元素，由<code>f:L⟶L</code>的定义可知<code>f(⊥)</code>也是<code>Lattice</code>上的元素⟹ ⊥ ≼ f(⊥)</em></p><p>​ <em>∵ <code>f</code>是单调的 ⟹ f(⊥) ≼ f(f(⊥))=f<sup>2</sup>(⊥) 相似的 ⟹ ⊥≼ f(⊥) ≼ f<sup>2</sup>(⊥) ... ≼ f<sup>i</sup>(⊥)</em></p><p>​ <em>∵<code>L</code>是<code>finite</code>的 ⟹ f<sup>k</sup>(⊥) = f<sup>(k+1)</sup>(⊥)</em></p><p>​ <em>∴ 不动点存在</em></p><p><em>Proof-Least Fixed Point:</em></p><p>​ <em>假设有另一个不动点<code>x</code>，⟹ <code>x = f(x)</code>, <code>⊥ ≼ x</code></em></p><p><code>Induction:</code></p><p>​ <em>∵ f 是单调的 ⟹ f(⊥) ≼ f(x)</em></p><p>​ <em>假设f^i(⊥) ≼ f<sup>i</sup>(x), ∵ f单调 ⟹ f<sup>(i+1)</sup>(⊥) ≼ f<sup>(i+1)</sup>(x)</em></p><p>​ <em>∴根据归纳法 ⟹ f<sup>i</sup>(⊥) ⟹ f<sup>i</sup>(x)</em></p><p>​ <em>∵<code>x</code>是不动点，f<sup>i</sup>(⊥) ≼ f<sup>i</sup>(x) = x， 又∵f<sup>fix</sup>=f<sup>k</sup>(⊥)是从⊥开始迭代停止的不动点 ⟹ f<sup>k</sup>(⊥) ≼ x</em></p><p>​ <em>∴f<sup>k</sup>(⊥)是唯一的最小不动点(最大不动点证明类似)</em></p></blockquote><h6 id="iterative-and-fixed-point">Iterative and Fixed-Point</h6><p>理解数据流分析的最后一步，就是将分析的<code>Iterative Algorithm</code>与前面建立在<code>Lattice</code>上<code>Fixed-Point Theorem</code>联系起来，而关于不动点原理的前提:</p><ul><li>a complete lattice(L, ≼)， L is finite</li><li><code>f: L ⟶ L</code> is monotonic</li></ul><p>可以看出<strong>只需要将迭代算法抽象成一个个定义在<code>Lattice</code>上的单调函数即可(根据不动点原理该函数一定会达到最大/小不动点)</strong>——下面具体对<code>Iterative Algorithm</code>进行抽象:</p><p>迭代算法中的<code>CFG</code>每一个节点的输出V<sub>i</sub>都可以抽象成一个<code>Lattice</code>，<strong>故全部<code>CFG</code>的输出V<sup>k</sup>就是一个<code>product lattice</code></strong>。又因为节点是有限的，故这个<code>product lattice</code>是<code>complete lattice</code>。</p><p><img src="15.png" width="50%" height="50%" alt=""></p><p>又因为迭代算法的核心就是V<sup>k</sup>应用<code>Transfer Function</code>和<code>meet/join Function</code>完成一次又一次的迭代，<strong>这里的<code>Transfer /meet.join Function</code>可以抽象成定义在<code>Lattice</code>上的函数。</strong></p><p><img src="16.png" width="50%" height="50%" alt=""></p><p>只要保证<code>Transfer Function</code>和<code>meet/join Function</code>是单调的，就可以完成迭代算法到不动点理论的映射。</p><p>其实所有的<code>Transfer Function</code>本质上都是<code>gen/kill problems</code>，因此简化为函数f<sub>i</sub>: L ⟶ L。其基本公式可以简化成为<font color="red">OUT[S] = gen<sub>S</sub> ⋃ (IN[S] - kill<sub>S</sub>)</font> 。从基本公式中可得:</p><ul><li>gen<sub>S</sub>和kill<sub>S</sub>是根据数据流分析算法的定义决定的，所以<strong>保持不变</strong></li><li>gen<sub>S</sub>是单调的(OUT[S]只会增加)，IN[S]要么被kill掉，要么也加入到OUT[S]中</li><li><strong>因此<code>OUT[S] never shrinks</code></strong></li></ul><p>由于输入一定是有限的(输入就是数据流比如<code>all definitions/all variables/all expressions</code>)因此该函数一定也是单调有界的。</p><p>相对来说<code>meet/join Function</code>函数⊔/⊓:L x L ⟶ L，只证明⊔是单调的，⊓类似:</p><blockquote><p><em>Poof.</em></p><p><em>∀x, y, z ∊ L, x ≼ y, 我们要证明 x⊔z ≼ y⊔z</em></p><p><em>∵ x≼y, y ≼ y⊔z ⟹ x ≼ y⊔z</em></p><p><em>∵ x⊔z是least upper bound of x and z</em></p><p><em>∴x⊔z ≼ y⊔z</em></p></blockquote><p>得证该函数也是单调的。</p><p>到此为止，我们完美的将<code>data-flow analysis</code>的<code>iterative algorithm</code>转化成为<code>fixed-point theorem</code>的已知条件，故<code>fixed-point theorem</code>的结论当然也适用于<code>iterative algorithm</code>。我们也回答了这一节最开始关于迭代算法不动点存在性和精度的问题。</p><h6 id="complexity">Complexity</h6><p>关于迭代算法的不动点理论还有最后一个问题，就是算法会在什么时候到达不动点即<code>when can we get the solution</code>?<strong>这就涉及到了在<code>Lattice</code>建立的函数的复杂度：</strong></p><p>首先引入<code>Lattice</code>的高度<code>height</code>，即从<code>lattice</code>的<code>top</code>到<code>bottom</code>最长的一条路径<code>h</code>，假设该<code>CFG</code>中节点的数目是<code>k</code>，<strong>那最坏情况需要<code>i = h* k</code>次迭代才能到达不动点。</strong></p><p>到此为止，所有的理论部分都介绍结束了！</p><h4 id="maymust-analysis-on-lattice">May/Must Analysis On Lattice</h4><p>前面一部分主要从数学角度引入<strong>在<code>lattice</code>上定义的函数的不动点定理，然后证明了数据流分析的算法本质上就是通过迭代来达到不动点。</strong>但是实际上不同的数据流分析算法有不同的应用场景，各自对精度和Soundness的要求也不相同——因此如何理解<code>may</code>和<code>must</code>分析的<strong>初始化条件</strong>以及<strong>最大/小不动点</strong>？ 本节解决 ①<code>may/must data-flow analysis</code>如果用<code>lattice</code>表述会是什么样子?②这些分析和求解<code>lattice</code>上的不动点有什么关系？即<code>may</code>求解最小不动点而<code>must</code>求解最大不动点？③求解不动点和分析的<code>Soundness</code>和分析精度有什么关系？这部分讲解十分精彩，图见课件，这里只是记录我认为最核心的需要理解的部分。</p><h5 id="may-analysis">may analysis</h5><p><code>may</code>分析从⊥到⊤。</p><p>拿<code>Reaching Definition</code>应用于<font color="red">检测未定义变量</font>为例：</p><h6 id="bottom">bottom</h6><p>分析的<code>⊥</code>是no definitions can reach，<strong>⊥就意味着所有变量都不是未定义</strong>，这个分析结果一定是<code>unsafe</code>的（因为实际上哪怕只有一个未定义变量没有被检测出来，<strong>运行时也一定会报错</strong>）。</p><h6 id="top">top</h6><p>分析的<code>⊤</code>是all definitions may reach，就意味着所有的变量都是未定义，故分析结果一定是<code>safe</code>的（因为就算有一个定义过的变量被检测成未定义，<strong>运行时也不会报错</strong>）。</p><h6 id="safe-precision">safe &amp; precision</h6><p>分析算法继续迭代，沿着更加<code>safe</code>的方向走，直到到达最小不动点——这部分是已经证明过的了，问题是如何理解分析的精度和安全。</p><p>回顾<code>may</code>分析结果<strong>可以有误报但不可以有漏报</strong>即<code>false-positive</code>或者<code>sound</code>。我理解是<font color="red">这里的<code>safe</code>和<code>precision</code>都是针对运行时来说的</font>，<strong>⊥一定会在运行时报错，⊤程序不会运行</strong>，而如何保证<code>safe</code>是由设计者自己设计的<code>Transfer Function</code>决定的。<strong>另一方面精度问题针对在<code>safe</code>的前提下是否可以尽量少误报</strong>，因为不动点有很多而最终我们需要的只是最小的那个。</p><h5 id="must-analysis">must analysis</h5><p><code>must</code>分析从⊤到⊥。</p><p>拿<code>available expression</code>应用于<font color="red">优化公共子表达式删除</font>为例：</p><h6 id="top-1">top</h6><p>分析的⊤是all expressions must be available，<strong>就意味着所有的表达式都是可以被优化的</strong>，这个分析结果一定是<code>unsafe</code>的（因为哪怕有一个表达式不是公共的，那优化结果一定是错的）。</p><h6 id="bottom-1">bottom</h6><p>分析的⊥是no expressions are available的，就意味着所有的表达式都不可被优化，故分析结果一定是<code>safe</code>的（因为哪怕有一个公共表达式为被检测出来，那也仅仅只是少几个优化）。</p><h6 id="safe-precision-1">safe &amp; precision</h6><p>回顾<code>must</code>分析结果<strong>可以有漏报但是不可以有误报</strong>即<code>false-negative</code>或者<code>complete</code>。我理解是<font color="red">这里的<code>safe</code>和<code>precision</code>也是针对程序运行结果而言的</font>，<strong>⊥少几个优化，⊤的程序一定出现问题。</strong>如何保证<code>safe</code>是由设计者自己设计的<code>Transfer Function</code>决定的。<strong>另一方面精度问题针对在<code>safe</code>的前提下是否可以尽量少漏报，</strong>因为不动点有很多而最终我们需要的只是最大的那个。</p><p><font color="red">由此可以看出<code>may/must</code>分析完全针对的是不同的场景，但是其分析结果的<code>safe</code>和<code>precision</code>却都是针对程序运行时和最终的结果。</font></p><h5 id="another-view">another view</h5><p>老师在这里提供了另一个角度，就是在<code>lattice</code>上迭代函数，其中<code>Transfer Function</code>本身是固定的，<strong>而两种分析的<code>join/meet Function</code>根据<code>lattice</code>的性质其就是两个元素的<code>least/greatest upper/lower bound</code>，加上分别从<code>⊥</code>和<code>⊤</code>开始，</strong>故每次迭代函数走的都是最小/大的路径，故到达的也是最小/最大不动点。</p><h4 id="mop-and-distributivity">MOP and Distributivity</h4><p>前面讨论了数据流分析<code>Iterative Algorithm</code>最后到达的不动点是最精确的。但是如何衡量这个精度？这一小节引入一个很经典的<strong>概念</strong><code>Meet-Over-All-Paths Solution</code>即<code>MOP</code>。</p><p><code>MOP</code>概念引入<code>CFG</code>的每一条路径都是从<code>entry</code>一直到其执行结束。</p><ul><li>P = Entry ⟶ S<sub>1</sub> ⟶ S<sub>2</sub> ⟶... ⟶ S<sub>i</sub></li></ul><p><code>MOP</code>每一条<code>path</code>的<code>Transfer Function</code>是该条路径上所有<code>statements</code>的<code>Transfer Function</code>的合力，最后应用<code>meet operator</code>来计算数据流值: MOP[S<sub>i</sub>] = ⊔/⊓ F<sub>P</sub>(OUT[Entry])。<code>MOP</code>仅仅作为一个理论上的概念存在是因为应用中很多路径是<code>not executable</code>的，<code>Unbounded</code>的以及<code>not enumerable</code>的，故对于那种指数爆炸的程序<code>MOP</code>是<code>impractical</code>的。<strong>这里主要通过<code>MOP</code>概念对比<code>Iterative Algorithm</code>。</strong>对于同一个<code>CFG</code>:</p><p><img src="17.png" width="50%" height="50%" alt=""></p><p>迭代算法是在每一个<code>control flow</code>应用函数:<em>IN[S<sub>4</sub>] = f<sub>S<sub>3</sub></sub>(f<sub>S<sub>1</sub></sub>(OUT[Entry]) ⊔ f<sub>S<sub>2</sub></sub>(OUT[Entry]))</em></p><p>而<code>MOP</code>只会在路径结束之后应用函数:<em>MOP[S<sub>4</sub>] = f<sub>S<sub>3</sub></sub>(f<sub>S<sub>1</sub></sub>(OUT[Entry])) ⊔ f<sub>S<sub>3</sub></sub>(f<sub>S<sub>2</sub></sub>(OUT[Entry]))</em></p><p>简化一下就是:</p><ul><li>Ours = F(x ⊔ y)</li><li>MOP = F(x) ⊔ F(y)</li></ul><p>可以证明<strong>迭代算法的精度要比<code>MOP</code>更不准。</strong>只有当F函数是<code>distributive</code>的时候才能保证<code>F(x⊔y) = F(x) ⊔ F(y)</code>即两种算法的精确度是一样的。前面的所有<code>Bit-vector/Gen/Kill</code>问题的数据流分析算法它们的<code>meet/join</code>函数都是<code>distributive</code>的。</p><h4 id="constant-propagation">Constant Propagation</h4><p>常量传播是一个<code>non-distributive</code>的数据流分析算法。</p><p>Given a variable x at program point p, determine whether x is guaranteed to hold a constant value at p.</p><p>按照数据流分析框架(<font color="red">D</font>, <font color="green">L</font>, <font color="blue">F</font>)来解释的话，该分析一定是前向分析<code>forward-analysis</code>，由于作为优化算法其必须保证运行时不可以出错故是<code>must</code>分析。其<code>lattice</code>的domain是一个pair<code>(x, v)</code>其中<code>x</code>是变量而<code>v</code>表示变量的值（有<code>constant</code>, <code>undefined</code>，<code>notAconstant</code>三种选项），分析的<code>meet operator</code>和之前的算法不同——不是单一的⊔/⊓：</p><ul><li>NAC ⊓ v = NAC</li><li>UNDEF ⊓ v = v</li><li>c ⊓ v = ?<ul><li>c ⊓ c = c</li><li>c<sub>1</sub> ⊓ c<sub>2</sub> = NAC</li></ul></li></ul><p>给定<code>s: x = ...</code>是一个赋值语句，因此该语句OUT则是IN的所有变量减掉<code>x</code>(因为x被重新赋值了)再加上该语句中新gen出来的变量。故定义常量传播的<code>Transfer Function</code>F: OUT[s] = gen ⋃ (IN[s] - {(x, _)})。其中gen函数:</p><ul><li>s: x = c; //c is a constant ⟹ gen = {(x, c)}</li><li>s: x = y; ⟹ gen = {(x, val(y))}</li><li>x: x = y op z; ⟹ gen = {(x, f(y, z))}<ul><li>val(y) op val(z) // if val(y) and val(z) are constants</li><li>NAC // if val(y) or val(z) is NAC</li><li>UNDEF //UNDEF op UNDEF or UNDEF op NAC</li></ul></li></ul><p>下面的这个例子中：</p><p><img src="18.png" width="50%" height="50%" alt=""></p><p>用数据流分析迭代算法以及<code>MOP</code>算法来完成常量传播求值之后进行一次对比:</p><ul><li>Ours: F(X ⊓ Y) = {(a, NAC), (c, NAC), <font color="green">(c, NAC)</font>}</li><li>MOP: F(X) ⊓ F(Y) = {(a, NAC), (b, NAC), <font color="green">(c, 10)</font>}</li></ul><p>按照<code>must</code>分析的不动点理论，分析是从⊤到⊥（⊤就是UNDEF，⊥是NAC）进行的。而<code>Ours</code>的值要比<code>MOP</code>的值更靠近⊥故其分析则<code>less precise</code>。因此<code>F(X⊓Y)≠ F(X)⊓ F(Y)</code>进而<code>F(X⊓Y) ⋞ F(X)⊓ F(Y)</code>。所以该分析是<code>Nondistributive</code>的。</p><h4 id="worklist-algorithm">Worklist Algorithm</h4><p>在实际的数据流分析中会使用迭代算法的优化版本即<code>Worklist Algorithm</code>。</p><p>迭代算法的主要复杂度在<code>CFG</code>中一个节点输出有变化都需要使得整个<code>CFG</code>迭代，而<code>Worklist Algorithm</code>则是迭代算法的一种剪枝优化。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OUT</span>[entry] = nullptr;</span><br><span class="line"><span class="title">for</span>(each basic block\entry)</span><br><span class="line"><span class="type">OUT</span>[<span class="type">B</span>] = nullptr;</span><br><span class="line"><span class="type">Worklist</span> ⟵ all basic blocks</span><br><span class="line"><span class="title">while</span>(<span class="type">Worklist</span> is not empty) </span><br><span class="line"><span class="type">Pick</span> a basic block <span class="type">B</span> from <span class="type">Worklist</span></span><br><span class="line">old_OUT = <span class="type">OUT</span>[<span class="type">B</span>]</span><br><span class="line"><span class="type">IN</span>[<span class="type">B</span>] = ⊔<span class="type">OUT</span>[<span class="type">P</span>]</span><br><span class="line"><span class="type">OUT</span>[<span class="type">B</span>] = gen_B ⋃ (<span class="type">IN</span>[<span class="type">B</span>] - kill_B)</span><br><span class="line"><span class="keyword">if</span>(old_OUT ≠ <span class="type">OUT</span>[<span class="type">B</span>]) </span><br><span class="line">add all successors <span class="keyword">of</span> <span class="type">B</span> to <span class="type">Worklist</span></span><br></pre></td></tr></table></figure><p>至此，数据流分析的学习告一段落。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;编译器中大部分机器无关的全局优化是基于&lt;code&gt;Data-flow Analysis&lt;/code&gt;实现的。数据流分析技术从代码中收集程序语义相关的信息，是程序分析的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In each data-flow analysis application, we associate with every program point a data-flow value that represents an abstraction of the set of all possible program states that can be observed for that point.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在工业界的&lt;a href=&quot;https://www.zhihu.com/question/41959902&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;主流编译器&lt;/a&gt;中，&lt;code&gt;C&lt;/code&gt;系的&lt;code&gt;LLVM&lt;/code&gt;，&lt;code&gt;Java&lt;/code&gt;系的&lt;code&gt;HotSpot&lt;/code&gt;都是基于&lt;code&gt;SSA&lt;/code&gt;做数据流分析而不是传统的&lt;code&gt;lattice&lt;/code&gt;。南大这节课中是基于&lt;code&gt;Lattice&lt;/code&gt;来讲解过程内&lt;code&gt;Intra-procedural&lt;/code&gt;，无别名&lt;code&gt;no aliases&lt;/code&gt;的经典数据流分析框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(0-Introduction)</title>
    <link href="http://haotianmcihael.github.io/2021/05/02/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-0-Introduction/"/>
    <id>http://haotianmcihael.github.io/2021/05/02/NJU静态程序分析-0-Introduction/</id>
    <published>2021-05-01T19:00:36.000Z</published>
    <updated>2022-03-16T10:22:34.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>编译器作为工业界对PL理论的部分实现——和编程语言，运行时环境一样只是机器解释世界的一个角度。而当我解锁了从更加PL的方式看待<code>计算</code>这件事情之后，又打开了一扇通往新世界的大门。过去的几十年里<code>Programming Language</code>的内核并没有变化多少——但是程序本身却随着应用需求变的更加庞大和复杂。而静态程序分析作为PL的重要应用，其目的就在于在编译期确保程序的可靠性，安全性等各种性质。</p><p>​ <strong>Static Analysis analyzes a program P to reasono about its behaviors and determines whether it satisfies some properties before running P.</strong></p><p>​ 主要的学习资源是<a href="https://pascal-group.bitbucket.io/teaching.html" target="_blank" rel="noopener">NJU-PASCAL团队的静态分析课程</a>以及<a href="https://book.douban.com/subject/3774682/" target="_blank" rel="noopener">龙书</a>和<a href="https://book.douban.com/subject/1400374/" target="_blank" rel="noopener">鲸书</a>中的部分章节。</p><a id="more"></a><h3 id="static-analysis">Static-Analysis</h3><p>​ PL的大框架大体上可以分成三个部分:</p><ul><li>Theory</li></ul><p>包括如何设计一个语言内核，一个类型系统，如何完成语义分析，如何形式化等等不同的理论，更多是作为学术研究的课题</p><ul><li>Environment</li></ul><p>针对特定场景设计的编译器和运行时环境等</p><ul><li>Application</li></ul><p>程序分析，程序合成，程序验证</p><p>而静态程序分析主要关注在程序的<strong>Reliability</strong>比如在程序运行前检测到空指针异常，内存泄漏等问题防止程序在运行过程中报运行时错误；<strong>Security</strong>比如隐私数据泄露，注入攻击<code>injection attack</code>等；<strong>Optimization</strong>编译优化等方面。</p><h3 id="rices-theorem">Rice‘s Theorem</h3><p>Any non-trivial property of the behavior of programs in a <strong>recursively enumerable</strong> language is undecidable.</p><p>这个定理有点哥德尔不完备定理的感觉——不存在一个完美的分析算能准确预测出程序的各种关键行为，即No Silver Bullet。这也引出了在实践中最重要的一个评判标准Sound和Complete。</p><p>这里的<code>recursively enumerable</code>递归可枚举是<strong>图灵完备</strong>的另一种说法，简写为<code>r.e.</code>。</p><h3 id="sound-and-complete">Sound and Complete</h3><p>假设一个程序中存在10个<code>unknown error</code>，一套分析框架不可能精确定位到这十个。而是在其值域范围内波动——不仅仅包含这10的集合就是<code>Sound</code>，只包含这10个的子集就是<code>Complete</code>。</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>伴随着这一对概念还有一对——<code>false negatives</code>和<code>false positives</code>。</p><ul><li>False negatives</li></ul><p>就是<code>Compromise soundness</code>也就是缩小原来分析的量，这样会更加的<code>complete</code>——便会产生<strong>漏报</strong></p><ul><li>False positives</li></ul><p>就是<code>Compromise completeness</code>也就是增大原来分析的量，这样会更加的<code>sound</code>——便会产生<strong>误报</strong></p><p>其实这里为什么要引入这一对概念我没有太理解……有点往回绕的意思。 这个图得好好理解一下。</p><p><img src="2.png" width="50%" height="50%" alt=""></p><p>在实践中，用的更多的标准是<code>compromising completeness</code>也就是要让结果更加的<code>sound</code>但是损失了精确度。<strong>换句话讲，分析的结果一定要全面，但不一定精确。也就是说宁可误报一些分析行为，也不允许程序在运行时报异常——这样整个系统付出代价会更高。</strong></p><h4 id="例子">例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;;</span><br><span class="line">class Base&#123;</span><br><span class="line">  A fld;</span><br><span class="line">&#125;;</span><br><span class="line">class B : A&#123;&#125;;</span><br><span class="line">class C : A&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base a = new Base();</span><br><span class="line">if(condition) &#123;</span><br><span class="line">  B b = new B();</span><br><span class="line">a.fld = b;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">  C c = new D();</span><br><span class="line">a.fld = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// case</span><br><span class="line">B bTmp = (B)a.fld;</span><br></pre></td></tr></table></figure><p>可以看到上例中的case中进行了一次强制转换，如果控制流走的是<code>!condition</code>那么就会报错。如果分析器是<code>sound</code>的这里就应该检测出该程序的控制流错误——从而减少了BUG。</p><h4 id="tradeoff">tradeoff</h4><p>因为<code>sound</code>会分析出比理论更多的结果，所以导致分析的速度会变慢。</p><p>Static Analysis ensure soundness, while making good trade-offs between analysis precision and analysis speed——分析过程的本质上也是一种速度和精度之间的权衡。</p><h3 id="to-conclude">To Conclude</h3><p>​ 大部分分析方式可以总结为下面的两个部分：</p><ul><li>Abstraction</li></ul><p>就是将具体的程序特征和行为进一步抽象成分析器的元符号，完成一定意义的所谓<strong>形式化</strong></p><ul><li><p>Over-approximation</p></li><li><p>transfer functions</p></li></ul><p>In static analysis, transfer functions define how to evaluate different program statements on abstract values. Its defined according to &quot;analysis problem&quot; and the &quot;semantics&quot; of different program statements.</p><ul><li>control flows</li></ul><p>程序的本质其实就是语句及语句之间的关联，映射到static analysis中就是（语句）<code>transfer functions</code>和（关联）<code>control flows</code>。在抽象的基础上，进一步颗粒化程序运行行为。比如<code>transfer functions</code>定义为程序中<code>statements</code>和程序异常行为的语义比如声明语句，除零异常等。而<code>control flows</code>定义了程序的控制流比如一些if-else分支。<strong>这样就能更加细粒度的完成程序行为的建模，然后在模型基础上完成分析器预定的sound的分析结果。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;编译器作为工业界对PL理论的部分实现——和编程语言，运行时环境一样只是机器解释世界的一个角度。而当我解锁了从更加PL的方式看待&lt;code&gt;计算&lt;/code&gt;这件事情之后，又打开了一扇通往新世界的大门。过去的几十年里&lt;code&gt;Programming Language&lt;/code&gt;的内核并没有变化多少——但是程序本身却随着应用需求变的更加庞大和复杂。而静态程序分析作为PL的重要应用，其目的就在于在编译期确保程序的可靠性，安全性等各种性质。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;Static Analysis analyzes a program P to reasono about its behaviors and determines whether it satisfies some properties before running P.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 主要的学习资源是&lt;a href=&quot;https://pascal-group.bitbucket.io/teaching.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NJU-PASCAL团队的静态分析课程&lt;/a&gt;以及&lt;a href=&quot;https://book.douban.com/subject/3774682/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;龙书&lt;/a&gt;和&lt;a href=&quot;https://book.douban.com/subject/1400374/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鲸书&lt;/a&gt;中的部分章节。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程（Ocaml）</title>
    <link href="http://haotianmcihael.github.io/2021/04/18/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88Ocaml%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2021/04/18/函数式编程（Ocaml）/</id>
    <published>2021-04-18T09:48:24.000Z</published>
    <updated>2022-03-16T09:52:27.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>最近在实验室实习的过程中学到了很多有意思的东西，对<code>Programming Languages</code>也有了更深的了解，<code>Ocaml</code>是一门支持多范式的函数式编程语言。<strong>程序描述计算，但是又不仅仅是计算</strong>。<code>Ocaml</code>的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:</p><ul><li>关于<code>scripting/imperative/object-oriented/functional PL</code>的基本概念<ul><li><code>Higher-order Functions</code></li><li><code>State-Full vs State-Free Computation</code></li><li><code>Modelling Objects and Closures</code></li><li><code>Exceptions/Continuations to Defer Control</code></li><li><code>Polymorphism</code></li><li><code>Partial Evaluation/Lazy Programming/Modules</code></li></ul></li><li>关于<code>reason about programs</code>的方法<ul><li><code>Type Checking</code></li><li><code>Induction</code></li><li><code>Operational Semantics</code></li><li><code>QuickCheck</code></li></ul></li><li>关于设计一门语言的基本规则</li></ul><a id="more"></a><h3 id="fps-basic-concepts">FP's Basic Concepts</h3><p><code>Ocaml is a statically typed functional programminng language</code>。函数式编程中，<code>function</code>永远是一等公民，程序中只有<code>expression</code>的概念，通过<code>functions</code>递归处理<code>values</code>来完成<code>computations</code>。<code>Ocaml</code>通过<code>pattern matching</code>模式匹配的方式来定义递归数据结构和函数，进而写出更简洁的程序。</p><p>在函数式中还有一个和<code>imperative PL.</code>中不同的概念称为<code>effect-free programming</code>。在命令式语言中，我们通过给<code>variables/fields</code>赋值来修改程序状态并将赋值行为的结果看成是<code>effects</code>。但是比如函数式就不会<code>explicitly</code>的分配内存，甚至没有<code>exception handling</code>来改变控制流状态——<strong>不支持<code>effect</code>被称为<code>pure functiional</code>比如<code>Haskell</code></strong>。<code>Ocaml</code>不是纯函数式语言。所以支持<code>effectful/state-full programming</code>和<code>pure FP</code>。</p><p>最后一个关键字就是<code>statically typed</code>静态类型。<code>Types statically approximate the runtime behaviour of an expression.</code>意思就是<code>static type checking</code>本身是在程序运行之前进行类型检查——通过<code>syntatic structure of expressions</code>。它可以保证通过静态类型检查的程序在运行时一定不会<code>core dump</code>。这样的<code>statically typed PL.</code>比如<code>Ocaml/Java/ML/Haskell/Scala等</code>也被称为是<code>type-safe</code>的。</p><h4 id="expressions-names-values-and-types">Expressions, Names, Values and Types</h4><p>在函数式中没有语句<code>statements</code>，最基本的<code>expression</code>就是<code>numbers/strings/booleans</code>。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">2</span> + <span class="number">3</span>;;</span><br><span class="line">- : <span class="built_in">int</span> = <span class="number">5</span></span><br><span class="line"># <span class="number">4.0</span> /. <span class="number">2.0</span>;;</span><br><span class="line">- : <span class="built_in">float</span> = <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>上面代码中的格式为<code>&lt;name&gt; : &lt;type&gt; = &lt;value&gt;</code> 。我们将<code>;;</code>之前的式子称为<code>expressions</code>，将整个计算过程称为<code>evaluation</code>，而将计算的结果称为<code>values</code>。</p><p>注意在<code>Ocaml</code>中基础运算符并没有被重载，故浮点运算都是在后面有一个<code>,</code>。这主要是因为<code>Ocaml</code>是静态类型的，不会在运行时去根据运算符参数来推导重载的<code>operators</code>。</p><p>通过类型检查的程序，其<code>evaluation</code>要么更新到一个新的<code>state</code>要么报一个<code>built-in runtime error</code>。比如:</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">3</span> / <span class="number">0</span>;;</span><br><span class="line"><span class="type">Exception</span>: <span class="type">Division_by_zero</span></span><br></pre></td></tr></table></figure><h4 id="variables-bindings-and-functions">Variables, Bindings and Functions</h4><p><code>Ocaml</code>是一个<code>call-by-value</code>的语言——<code>it binds values to variable names not expressions</code>。这里有一个<code>binding</code>的概念，区分于<code>assignment</code>。我们只是在<code>values</code>和<code>name</code>之间建立了“链接”——并没有新的<code>state</code>被创建——我理解和<code>imperative PL.</code>不同的应该是内存模型比如<code>C</code>中对局部变量是放在栈上的但是确实创建了内存。当然这种“链接”也是可以更新的。在<code>Ocaml</code>中用<code>let</code>表达式来建立一个绑定。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">let</span> x = <span class="number">3</span> * <span class="number">3</span>;;</span><br><span class="line"><span class="keyword">val</span> x : <span class="built_in">int</span> = <span class="number">9</span></span><br><span class="line"># <span class="keyword">let</span> x = <span class="number">42</span>;;</span><br><span class="line"><span class="keyword">val</span> x : <span class="built_in">int</span> = <span class="number">42</span></span><br></pre></td></tr></table></figure><p>变量的作用域是根据<code>binding stack</code>来确定的。局部或者临时创建的<code>binding</code>都会被<code>push</code>进<code>binding stack</code>中，在不需要的时候会被<code>GC</code>清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># let k = 4;;</span><br><span class="line">val k : int = 4</span><br><span class="line"># let k = 3 in k * k ;;</span><br><span class="line">- : int = 9</span><br><span class="line"># k;;</span><br><span class="line">- : int = 4</span><br></pre></td></tr></table></figure><p>这里有一个新的<code>let &lt;name&gt; = &lt;expression 1&gt; in &lt;expression 2&gt;</code>结构——将<code>expression1</code>的<code>value</code>绑定到<code>name</code>上，然后继续使用这个新的绑定对<code>expression 2</code>进行<code>evalutions</code>。</p><p>在函数式中<code>let</code>不仅可以绑定基本类型，还可以绑定函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let area : float -&gt; float = function r -&gt; pi *. r *. r;;</span><br><span class="line">let area : float -&gt; float = fun r -&gt; 3.14 *. r *. r;;</span><br><span class="line">let area (r:float) = pi *. r *. r;;</span><br><span class="line">let a1 = area(2.0);;</span><br></pre></td></tr></table></figure><p>上面的三种写法是等价的，都得到函数类型<code>val area : float -&gt; float = &lt;fun&gt;</code>。<strong>有意思的是函数作为一种绑定，也是在<code>binding stack</code>中的，所以它只能看到过去的绑定：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># let (pi*float) = 3.0</span><br><span class="line">val pi : float = 3.14</span><br><span class="line"># let area (r:float) = pi *. r *.r;;</span><br><span class="line">val area : float -&gt; float = &lt;fun&gt;</span><br><span class="line"># let a1 = area(2.0);;</span><br><span class="line">val a1 : float = 12.0</span><br><span class="line"># let (pi*float) = 4.0</span><br><span class="line">val pi : float = 4.0</span><br><span class="line"># let a2 = area(2.0);;</span><br><span class="line">val a2 : float = 12.0</span><br></pre></td></tr></table></figure><p>最后介绍一下递归函数。在<code>Ocaml</code>中递归函数使用<code>let rec</code>来声明。比如定义<code>factorial</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># exception Domain;;</span><br><span class="line"># let rec fact n = </span><br><span class="line">if n &lt; 0 then raise Domain</span><br><span class="line">else if n = 0 then 1</span><br><span class="line">else n * fact(n - 1);;</span><br></pre></td></tr></table></figure><p>在函数式中所有的函数都可以被写成尾递归的形式然后进一步优化——这是因为尾递归函数的栈帧可以被优化掉。比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># let fact_tr n = </span><br><span class="line">let rec f n acc = </span><br><span class="line">if n = 0 then acc else f (n - 1) (n * acc)</span><br><span class="line">in</span><br><span class="line">f n 1</span><br></pre></td></tr></table></figure><h4 id="data-types-and-pattern-matching">Data Types and Pattern Matching</h4><p>这一节可以在<code>Ocaml</code>中定义自己的递归/非递归的数据类型。</p><p><code>Ocaml</code>使用<code>type</code>来定义<strong>有限无序的非递归集合</strong>，这里举一个扑克牌的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># type suit = Clubs | Spades | Hearts | Diamonds;;</span><br><span class="line">type suit = Clubs | Spades | Hearts | Diamonds</span><br><span class="line"># type rank = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace;;</span><br><span class="line"># type card = rank * suit;;</span><br><span class="line">type card = rank * suit</span><br><span class="line"># type hand = Empty | Hand of card * hand;;</span><br><span class="line">type hand = Empty | Hand of card * hand</span><br><span class="line"># let rec dom (s1, s2) = match (s1, s2) with </span><br><span class="line">| (Spades, _) -&gt; true</span><br><span class="line">| (Hearts, Diamonds)  -&gt; true</span><br><span class="line">| (s1, s2) -&gt; s1 = s2</span><br></pre></td></tr></table></figure><p><code>Ocaml</code>使用<code>pattern matching</code>模式匹配来操作这些数据结构。这里有两个概念——<code>patterns</code>和<code>constructors</code>。每一个<code>pattern</code>由不同的<code>constructors</code>填充——这里的构造器指的是每一个和类型元素同名的构造器比如<code>Clubs</code>。<code>Ocaml</code>规定构造器首字母必须大写，且匹配是从上到下的顺序。</p><p>进一步的，为了简化代码而支持<code>inductively</code>的<code>deep pattern</code>构造形式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># let rec add c1 c2 = match c1 c2 with</span><br><span class="line">| (Hearts, v1), (Hearts, v2) -&gt; v1 + v2</span><br><span class="line">| _, _ -&gt; 0;;</span><br><span class="line">val add : (&apos;a -&gt; (suit * int) * (suit * int)) -&gt; &apos;a -&gt; int = &lt;fun&gt;</span><br></pre></td></tr></table></figure><p>这里会发现构造了一个比较复杂的类型<code>('a -&gt; (suit*int)*(suit*int)) -&gt; 'a -&gt; int</code>。其中<code>type1 * type2</code>为一个<code>pair</code>，而`<code>a</code>为任意类型。</p><p>上述函数的基本类型推导过程为两个任意类型为输入参数，<code>int</code>为输出。其中任意类型为<code>(suit*int)*(suit*int)</code>的。</p><p>上面扑克牌的例子中<code>hand</code>定义一组<strong>无限递归集合</strong>。在<code>hand</code>类型中，<code>Empty</code>和<code>Hand</code>分别为两个<code>constructors</code>。<code>Empty</code>没有输入参数，而<code>Hand</code>以<code>a tuple of a card and another hand</code>的一个<code>tuple</code>为输入参数。看下面的实例化例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># let hand0: hand = Empty</span><br><span class="line">let hand1: hand = Hand((Ace, Hearts), Empty)</span><br><span class="line">let hand2: hand = Hand((Queen, Diamonds), hand1)</span><br><span class="line">let hand3:hand = </span><br><span class="line">Hand((Ace, Spades),</span><br><span class="line">Hand((Ten, Diamonds), </span><br><span class="line">Hand((Seven, Clubs),</span><br><span class="line">Hand((Queen, Spades),</span><br><span class="line">Hand((Eight, Clubs), Empty)))));;</span><br></pre></td></tr></table></figure><p>这个<code>hand</code>类型实际上就是一棵退化的二叉树（只能靠右生长）——叶子是<code>Empty</code>， 而<code>Hand</code>构造器使用两个参数来建树。</p><p>下面我们定义一个函数，这里函数的类型是<code>suit -&gt; hand -&gt; hand</code>，功能是给定一个<code>suit -&gt; hand</code>的输入，然后从<code>hand</code>中找有匹配到<code>suit</code>类型的<code>hand</code>然后返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># let rec extract (s:suit) (h:hand) = match h with </span><br><span class="line">| Empty -&gt; Empty</span><br><span class="line">| Hand ((_, s&apos;) as c, h&apos;) -&gt;</span><br><span class="line">if s = s&apos; then Hand(c, extract s h&apos;)</span><br><span class="line">else extract s h&apos;</span><br></pre></td></tr></table></figure><p>上一个函数中的<code>Empty</code>实际上就是一个终结符，意味着如果<code>hand</code>类型都不匹配的话就直接返回<code>Empty</code>。但是如果我要匹配一个<code>card</code>的话，没有匹配上该怎么返回呢？<code>Ocaml</code>引入一个<code>optional data type</code>。比如下面的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># type &apos;a option = None | Some of &apos;a</span><br><span class="line">type &apos;a option = None | Some of &apos;a</span><br><span class="line"># let rec find (r, h) = match h with</span><br><span class="line">| Empty  -&gt; None</span><br><span class="line">| Hand((r&apos;, s&apos;), h&apos;) -&gt; if r = r&apos; then Some s&apos;</span><br><span class="line">else find(r, h&apos;)</span><br><span class="line">val find: rank * hand -&gt; suit option = &lt;fun&gt;</span><br></pre></td></tr></table></figure><p>其中<code>option type</code>表示由<code>Some</code>构造器实现的类型为`<code>a</code>的元素集合，是符合多态的任意类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;最近在实验室实习的过程中学到了很多有意思的东西，对&lt;code&gt;Programming Languages&lt;/code&gt;也有了更深的了解，&lt;code&gt;Ocaml&lt;/code&gt;是一门支持多范式的函数式编程语言。&lt;strong&gt;程序描述计算，但是又不仅仅是计算&lt;/strong&gt;。&lt;code&gt;Ocaml&lt;/code&gt;的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于&lt;code&gt;scripting/imperative/object-oriented/functional PL&lt;/code&gt;的基本概念
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Higher-order Functions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State-Full vs State-Free Computation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Modelling Objects and Closures&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exceptions/Continuations to Defer Control&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Polymorphism&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Partial Evaluation/Lazy Programming/Modules&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于&lt;code&gt;reason about programs&lt;/code&gt;的方法
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Type Checking&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Induction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Operational Semantics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuickCheck&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于设计一门语言的基本规则&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Ocaml" scheme="http://haotianmcihael.github.io/categories/Ocaml/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="FP" scheme="http://haotianmcihael.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>Lisp语言和Emacs</title>
    <link href="http://haotianmcihael.github.io/2021/02/16/Lisp%E8%AF%AD%E8%A8%80%E5%92%8CEmacs/"/>
    <id>http://haotianmcihael.github.io/2021/02/16/Lisp语言和Emacs/</id>
    <published>2021-02-16T13:58:30.000Z</published>
    <updated>2022-03-16T10:25:10.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>​ 第一次接触<code>EMACS</code>是大二的时候，当时只顾着新奇的界面和强大的功能却忽视了其背后真正的理论。后来我写代码也一直不喜欢IDE这种东西，但现在回过头来看，这貌似也只是一种浮于表面而无关原理的执拗。</p><p>​ 这次重新回归到<code>Spacemacs</code>，我希望仔细从<code>Lisp</code>的角度理解这款编辑器，不管是其插件特性还是语言本身。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;​ 第一次接触&lt;code&gt;EMACS&lt;/code&gt;是大二的时候，当时只顾着新奇的界面和强大的功能却忽视了其背后真正的理论。后来我写代码也一直不喜欢IDE这种东西，但现在回过头来看，这貌似也只是一种浮于表面而无关原理的执拗。&lt;/p&gt;
&lt;p&gt;​ 这次重新回归到&lt;code&gt;Spacemacs&lt;/code&gt;，我希望仔细从&lt;code&gt;Lisp&lt;/code&gt;的角度理解这款编辑器，不管是其插件特性还是语言本身。&lt;/p&gt;
    
    </summary>
    
      <category term="Lisp" scheme="http://haotianmcihael.github.io/categories/Lisp/"/>
    
    
      <category term="EMACS" scheme="http://haotianmcihael.github.io/tags/EMACS/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly和Wabt</title>
    <link href="http://haotianmcihael.github.io/2020/11/12/WebAssembly%E5%92%8CWabt/"/>
    <id>http://haotianmcihael.github.io/2020/11/12/WebAssembly和Wabt/</id>
    <published>2020-11-12T09:01:21.000Z</published>
    <updated>2022-03-16T09:54:07.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="abstract">Abstract</h3><p>最近参加<a href="https://github.com/deeplang-org" target="_blank" rel="noopener"><code>deeplang</code></a>的的过程中，接触到了一些编译领域的新技术，总结一下希望有时间了可以进一步的深入了解。参考资料是<a href="https://book.douban.com/subject/30396640/" target="_blank" rel="noopener">WebAssembly标准入门</a>。</p><a id="more"></a><h3 id="points">Points</h3><p>过去很多技术尝试将<code>C/C++</code>程序直接运行在浏览器中，比如<code>TypeScript</code> 将<code>C/C++</code>代码转换为<code>JS</code>。</p><ul><li><code>Emscripten</code></li></ul><p>而这个项目利用<code>LLVM</code>编译器前端编译<code>C/C++</code>代码，生成<code>LLVM</code>平台特有的跨平台中间语言代码，最终再将<code>IR</code>转换为<code>JavaScript</code>的<strong><code>asm.js</code>子集</strong>——这是<code>WebAssembly</code>的基础。</p><ul><li><code>AOT编译</code></li><li><code>JIT编译</code></li></ul><p><code>JIT</code>的优点在于<code>Profile-Based Optimization</code>，根据运行时信息然后随着时间的推移尽可能的得到最优的代码。</p><p>而<code>AOT</code>的优点在于无需<code>runtime</code>运行，直接静态链接至最终的程序中。</p><ul><li><code>WebAssembly</code></li></ul><p><code>JavaScript</code>运行在其虚拟机上，而<code>WebAssembly</code>也运行在其虚拟机上。而现在<code>Node.js 8.0</code>之后的版本也可以运行<code>WebAssembly</code>——也就是说<code>WebAssembly</code>虚拟机可以脱离<code>JS</code>的环境支持，不仅仅运行在浏览器中。</p><h3 id="webassembly概述">WebAssembly概述</h3><p>和<code>LLVM IR</code>很像，有两种汇编表示——<code>.wat</code>文本表示和<code>.wasm</code>机器表示。</p><h4 id="关键概念">关键概念</h4><ul><li>模块</li></ul><p>由<code>.wasm</code>编译而来的可执行机器码的二进制对象。</p><ul><li>内存</li></ul><p>网页环境下，<code>wasm</code>的内存由<code>JavaScript</code>中的<code>ArrayBuffer</code>对象实现的。</p><ul><li>表格</li></ul><p>引入表格对象用于存储函数引用来模拟<code>C/C++</code>指针。</p><ul><li>实例<ul><li>导入对象 调用JS函数</li><li>导出对象 提供接口</li></ul></li></ul><p>指一个模块及其运行时的所有状态，包括内存，表格以及导入对象等。模块只有被实例化之后才可以调用。</p><h4 id="程序生命周期">程序生命周期</h4><ul><li>将<code>wat</code>或者其他语言编译成<code>.wasm</code>文件</li><li>网页中使用<code>fetch</code>等获取<code>.wasm</code>文件<ul><li><code>emrun --no_browser --port 8080 .</code> 将文件运行在<code>http</code>协议上</li><li>然后打开<code>http://localhost:8080/xxx.html</code></li></ul></li><li>将<code>.wasm</code>编译为模块，编译过程中进行合法性检查</li><li>实例化，初始化导入对象，创建模块实例</li><li>执行实例的导出函数，完成操作</li></ul><h4 id="虚拟机体系结构">虚拟机体系结构</h4><ul><li>一个全局类型数组(函数签名)</li><li>一个全局函数数组</li><li>一个全局变量数组</li><li>一个全局表格对象(元素引用)</li><li>一个全局内存对象</li><li>一个运行时栈</li></ul><h4 id="hello-world">Hello World</h4><p>JavaScript部分<code>hello.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Show me the answer<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var wasmMem = new WebAssembly.Memory(&#123;initial:1&#125;);</span></span><br><span class="line"><span class="undefined">            function printStr(offset, length)&#123;</span></span><br><span class="line"><span class="undefined">                var bytes = new Uint8Array(wasmMem.buffer, offset, length);</span></span><br><span class="line"><span class="undefined">                var string = new TextDecoder('utf-8').decode(bytes);</span></span><br><span class="line"><span class="undefined">                console.log(string);</span></span><br><span class="line"><span class="undefined">                &#125;;</span></span><br><span class="line"><span class="undefined">            var importObj = &#123;js : &#123;print: printStr, mem: wasmMem&#125;&#125;; </span></span><br><span class="line"><span class="undefined">            fetch('hello.wasm').then(response=&gt;</span></span><br><span class="line"><span class="undefined">                        response.arrayBuffer()</span></span><br><span class="line"><span class="undefined">                        ).then(bytes=&gt;</span></span><br><span class="line"><span class="undefined">                          WebAssembly.instantiate(bytes, importObj)</span></span><br><span class="line"><span class="undefined">                        ).then(result =&gt; result.instance.exports.hello()</span></span><br><span class="line"><span class="undefined">                        );</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>wat部分<code>hello.wat</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ;; hello.wat</span><br><span class="line"></span><br><span class="line">(<span class="keyword">module</span></span><br><span class="line">      ;; import js::print as js_print(); </span><br><span class="line">      (import "js" "print" (func $js_print (param i32 i32)))</span><br><span class="line">      (import "js" "mem" (memory 1))  ;;import js::mem as memory</span><br><span class="line">      (data (i32.const 0) "你好，wasm")</span><br><span class="line">      (func (export "hello")</span><br><span class="line">           i32.const 0    ;; pass offset 0 to js_print</span><br><span class="line">           i32.const 13   ;; pass offset 13 to js_print</span><br><span class="line">           call $js_print </span><br><span class="line">            )</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>首先将<code>.wat</code>编译成为<code>.wasm</code>,需要用到<a href="https://github.com/WebAssembly/wabt" target="_blank" rel="noopener">wabt工具集</a>。还需要下载<a href="https://github.com/juj/emsdk.git" target="_blank" rel="noopener">Emscripten工具集</a>。编译好之后配置环境变量。就可以执行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wat2wasm hello.wat -o hello.wasm</span><br><span class="line"><span class="meta">$</span> emrun --no_browser --port 8080 .</span><br></pre></td></tr></table></figure><p>然后打开<code>http://localhost:8080/xxx.html</code>，启动<code>Chrome</code>下的开发者模式，看到执行成功。</p><h3 id="webassembly核心">WebAssembly核心</h3><h4 id="在js环境中">在JS环境中</h4><p>浏览器中的<code>wasm</code>运行在<code>JS</code>虚拟机上，页面可以通过一组<code>JS</code>对象进行<code>wasm</code>模块的编译，载入，配置，调用等操作。</p><p>在<code>wasm</code>中的几个关键概念都有与之对应的对象：</p><ul><li>模块——<code>WebAssembly.Module</code></li><li>内存——<code>WebAssembly.Memory</code></li><li>表格——<code>WebAssembly.Table</code></li><li>实例——<code>WebAssembly.Instance</code></li></ul><h4 id="webassembly汇编语言">WebAssembly汇编语言</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;最近参加&lt;a href=&quot;https://github.com/deeplang-org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;deeplang&lt;/code&gt;&lt;/a&gt;的的过程中，接触到了一些编译领域的新技术，总结一下希望有时间了可以进一步的深入了解。参考资料是&lt;a href=&quot;https://book.douban.com/subject/30396640/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebAssembly标准入门&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://haotianmcihael.github.io/categories/JavaScript/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="WebAssembly" scheme="http://haotianmcihael.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>LLVM漫谈（2-Implementing a Language）</title>
    <link href="http://haotianmcihael.github.io/2020/07/07/LLVM%E6%BC%AB%E8%B0%88%EF%BC%882-Implementing-a-Language%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2020/07/07/LLVM漫谈（2-Implementing-a-Language）/</id>
    <published>2020-07-06T23:05:29.000Z</published>
    <updated>2022-03-16T10:29:57.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abstract">Abstract</h1><p>基于<code>LLVM</code>实现简单的编程语言<code>kaleidoscope</code>，来源于<a href="https://releases.llvm.org/9.0.0/docs/tutorial/LangImpl01.html" target="_blank" rel="noopener">LLVM9.0.0 tutorial</a>。</p><p><code>LLVM</code>的官方文档还是很不错的，阅读完其中的<strong>tutorials</strong>就能大致上手<code>LLVM</code>了。实现的代码对<code>C++11</code>要求比较高，我放在了<a href="https://github.com/haotianmichael/LLVMSet/tree/master/Kaleidoscope" target="_blank" rel="noopener">Github</a>上。</p><p>实现共分为10部分：</p><ul><li>实现<strong>词法分析器Lexer</strong></li><li>使用<strong>递归下降</strong>和<strong>运算符优先级解析</strong>实现<strong>语法分析器Parser</strong></li><li>将<strong><code>AST</code></strong>转化成<strong><code>LLVM-IR</code></strong></li><li>添加<strong><code>JIT</code>即时编译</strong>和<strong>优化器</strong>的支持</li><li>扩展——<strong>控制流</strong>，这一章会引入<strong><code>SSA</code></strong>概念</li><li>扩展——<strong>用户定义运算符</strong></li><li>扩展——<strong>自动变量</strong>，深入<strong><code>SSA</code></strong></li><li>目标代码生成</li><li>扩展——<strong>添加调试器</strong></li><li>深入——<strong>GC，异常等</strong></li></ul><a id="more"></a><h1 id="parser">Parser</h1><h2 id="编译原理">编译原理</h2><h2 id="c原理">C++原理</h2><h1 id="llvm-ir">LLVM-IR</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;
&lt;p&gt;基于&lt;code&gt;LLVM&lt;/code&gt;实现简单的编程语言&lt;code&gt;kaleidoscope&lt;/code&gt;，来源于&lt;a href=&quot;https://releases.llvm.org/9.0.0/docs/tutorial/LangImpl01.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LLVM9.0.0 tutorial&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LLVM&lt;/code&gt;的官方文档还是很不错的，阅读完其中的&lt;strong&gt;tutorials&lt;/strong&gt;就能大致上手&lt;code&gt;LLVM&lt;/code&gt;了。实现的代码对&lt;code&gt;C++11&lt;/code&gt;要求比较高，我放在了&lt;a href=&quot;https://github.com/haotianmichael/LLVMSet/tree/master/Kaleidoscope&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上。&lt;/p&gt;
&lt;p&gt;实现共分为10部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现&lt;strong&gt;词法分析器Lexer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;递归下降&lt;/strong&gt;和&lt;strong&gt;运算符优先级解析&lt;/strong&gt;实现&lt;strong&gt;语法分析器Parser&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;&lt;code&gt;AST&lt;/code&gt;&lt;/strong&gt;转化成&lt;strong&gt;&lt;code&gt;LLVM-IR&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;添加&lt;strong&gt;&lt;code&gt;JIT&lt;/code&gt;即时编译&lt;/strong&gt;和&lt;strong&gt;优化器&lt;/strong&gt;的支持&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;控制流&lt;/strong&gt;，这一章会引入&lt;strong&gt;&lt;code&gt;SSA&lt;/code&gt;&lt;/strong&gt;概念&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;用户定义运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;自动变量&lt;/strong&gt;，深入&lt;strong&gt;&lt;code&gt;SSA&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;添加调试器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;深入——&lt;strong&gt;GC，异常等&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>LLVM漫谈（1-LLVM编译框架）</title>
    <link href="http://haotianmcihael.github.io/2020/06/25/LLVM%E6%BC%AB%E8%B0%88%EF%BC%881-LLVM%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2020/06/25/LLVM漫谈（1-LLVM编译框架）/</id>
    <published>2020-06-25T04:53:37.000Z</published>
    <updated>2022-03-16T10:29:30.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abstract">Abstract</h1><p><strong>LLVM</strong>，这个星球最牛逼的编译器。</p><p>其核心设计理念就是<strong>统一的底层中间表达以及模块化的软件工程化方法。</strong>LLVM采用了<code>前端-优化器-后端</code>的组织形式，<strong>只是不同的前端和后端都采用统一的底层中间表示格式（LLVM IR）来最大可能复用优化器的代码。</strong></p><p>在<a href="http://nondot.org/sabre/" target="_blank" rel="noopener">Chris Lattner</a>将其开源后，<a href="http://llvm.org/" target="_blank" rel="noopener">LLVM</a>逐渐发展成为了成熟的编译框架，具有大量库和编译链工具。</p><p>我使用的平台是<code>macOS Mojave 10.14</code>，在编译的时候要注意版本是否兼容。</p><p><strong>一般系统会通过打印二进制文件名称和无法加载的动态库的名称来发现链接错误。当屏幕上打印动态库名称时要予以注意，这说明系统动态链接器和加载器无法加载该库，因为该程序与当前系统不兼容。</strong></p><p>我编译<code>LLVM 10.0.0</code>的时候出错如下：</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>后来发现这个版本的<code>Xcode</code>工具链最高只支持<code>LLVM 9.0.0</code>版本，然后换了版本最后编译成功。</p><a id="more"></a><h1 id="build">BUILD</h1><table><colgroup><col style="width: 34%"><col style="width: 65%"></colgroup><thead><tr class="header"><th>Subproject Deployed On My System</th><th>Note</th></tr></thead><tbody><tr class="odd"><td><strong>llvm-core</strong></td><td><strong>modern source- and target-independent <a href="http://llvm.org/docs/Passes.html" target="_blank" rel="noopener">optimizer</a>, along with <a href="http://llvm.org/docs/CodeGenerator.html" target="_blank" rel="noopener">code generation support</a> for many popular CPUs</strong></td></tr><tr class="even"><td><strong>Clang</strong></td><td><strong>&quot;LLVM native&quot; C/C++/Objective-C compiler front-end</strong></td></tr><tr class="odd"><td><strong>LLDB</strong></td><td><strong>native debugger</strong></td></tr><tr class="even"><td><strong>LLD</strong></td><td><strong>native linker</strong></td></tr><tr class="odd"><td><strong>libcxx/libcxxabi</strong></td><td><strong>standard conformant and high-performance implementation of the C++ Standard Library,</strong></td></tr><tr class="even"><td><strong>compiler-rt</strong></td><td><strong>highly tuned implementations of the low-level code generator support routines and implementations of run-time libraries</strong></td></tr></tbody></table><h2 id="llvm">llvm</h2><p>以上的<code>subproject</code>通过以下编译方式完成部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//ought to download source of subprojects to local, besides </span><br><span class="line"><span class="meta">$</span> git clone https://github.com/llvm/llvm-project.git  </span><br><span class="line"><span class="meta">$</span> mkdir /LLVM/llvm-build  &amp;&amp; cd //LLVM/llvm-build</span><br><span class="line"><span class="meta">$</span> cmake -G Ninja -DLLVM_ENABLE_PROJECTS='lldb;clang;compiler-rt;lld;' \    </span><br><span class="line">        -DCMAKE_INSTALL_PREFIX='/LLVM/llvm-install'  \</span><br><span class="line">        ~/where you put llvm-src</span><br><span class="line"><span class="meta">$</span> ninja &amp;&amp; ninja install</span><br><span class="line"><span class="meta">$</span> echo $?   //check</span><br></pre></td></tr></table></figure><h2 id="libcxxlibcxxabi">libcxx/libcxxabi</h2><p>这里理清楚一个概念：</p><ul><li><code>glic</code>是<code>linux</code>最重要的运行库，其实现最底层的<code>API</code>供其他库使用比如<code>malloc/printf</code>等。</li><li><code>libstdc++</code>是一个<code>C++</code>标准库，如果跑在<code>linux</code>则依赖<code>Glibc</code></li><li><code>libcxx</code>是<code>LLVM</code>专门开发的一个代替<code>libstdc++</code>的<code>c++</code>标准库</li><li><code>compiler-rt</code>是<code>LLVM</code>开发来替代<code>libgcc</code>,主要用于为硬件不支持的低级功能提供特定于目标的支持</li></ul><p><code>clang++</code>构建可执行文件的时候使用<code>libcxx</code>或者<code>libclc</code>(OpenCL运行时库)。其中<code>libcxx</code>实现由<strong>库本身和一个低级函数层<code>libcxxabi</code>组成，这个函数层用来处理异常和运行时类型信息(RTTI)等功能，这种分离式设计使得<code>libcxxabi</code>更容易移植。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/llvm/llvm-project.git</span><br><span class="line"><span class="meta">$</span> cd llvm-project</span><br><span class="line"><span class="meta">$</span> mkdir /LLVM/libcxx-build &amp;&amp; cd /LLVM/libcxx-build</span><br><span class="line"><span class="meta">$</span> cmake -G Ninja -DCMAKE_C_COMPILER=clang \</span><br><span class="line">        -DCMAKE_CXX_COMPILER=clang++ \</span><br><span class="line">        -DLLVM_ENABLE_PROJECTS="libcxx;libcxxabi" \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX='/LLVM/llvm-install'   \</span><br><span class="line">        ~/where you put libcxx-src</span><br><span class="line"><span class="meta">$</span> make # Build</span><br><span class="line"><span class="meta">$</span> make check-cxx # Test</span><br><span class="line"><span class="meta">$</span> make install-cxx install-cxxabi # Install</span><br></pre></td></tr></table></figure><h2 id="warning">warning</h2><p>其中<code>llvm</code>和<code>libcxx</code>我是分开编译的，而且<strong>编译目录和安装目录都是指定的目录，默认很可能会安装到系统路径下，从而带来错误。</strong></p><ul><li><code>~/Document/LLVM9.0.0/</code><ul><li><code>llvm</code> //llvm源代码</li><li><code>libcxx</code> //libcxx源代码</li></ul></li><li><code>/LLVM/</code><ul><li><code>llvm-build</code> //llvm编译路径</li><li><code>llvm-install</code> //llvm安装路径</li></ul></li><li><code>/LLVM/</code><ul><li><code>libcxx-build</code> //libcxx编译路径</li><li><code>libcxx-install</code> //libcxx安装路径</li></ul></li></ul><h1 id="features">Features</h1><h2 id="核心设计">核心设计</h2><p><code>LLVM</code>中最核心的就是<code>LLVM-IR</code> ：</p><ul><li><strong><code>SSA</code>表示和允许快速优化的无限寄存器</strong></li><li><strong>通过将整个程序存储在磁盘IR表示中，实现便捷的链接时优化</strong></li></ul><p>当然<code>LLVM</code>不仅仅只有一种中间表示形式：</p><ul><li>将<code>C</code>或<code>C++</code>转换为<code>LLVM-IR</code>的时候，<code>Clang</code>将使用<strong>抽象语法树<code>AST</code>结构</strong>在内存中表示程序</li><li>将<code>LLVM-IR</code>转换为特定于机器的汇编语言的时候，<code>LLVM</code>首先将程序转换为<strong>有向无环图<code>DAG</code></strong>格式以便进行<strong>指令选择</strong>，然后将其转换回<strong>三地址表示</strong>以进行<strong>指令调度</strong></li><li>为了实现汇编器和链接器，<code>LLVM</code>使用第四种中间数据结构<code>MCModule</code>在对象文件的上下文中保存成程序表示</li></ul><p>在整个框架中，&quot;库&quot;是一个很核心的概念。很多二进制工具都可以直接调用库来实现。而<strong>Clang作为编译驱动程序则可以通过链接小工具的库来实现其功能——代码重用。</strong>故<code>clang</code>在二进制文件中是最大的，因为它链接并利用了整个<code>LLVM</code>生态系统。<strong>而开发者一般都是将LLVM各个组件看出是库。</strong></p><p><img src="2.png" width="50%" height="50%" alt=""></p><h2 id="编译流程">编译流程</h2><h3 id="clang">clang</h3><p><code>clang</code>作为编译器驱动程序隐式的调用从前端到链接器的所有工具。<strong>整个过程都是在内存中完成的，并不会将中间文件输出到磁盘中。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> clang hello.c -o hello</span><br><span class="line"><span class="meta">$</span> clang -### hello.c -o hello          //可以查看驱动程序调用的所有工具</span><br></pre></td></tr></table></figure><h3 id="独立工具">独立工具</h3><p><code>LLVM</code>独立工具会将中间文件输出到磁盘上。</p><table><colgroup><col style="width: 15%"><col style="width: 84%"></colgroup><thead><tr class="header"><th>Tools</th><th>Notes</th></tr></thead><tbody><tr class="odd"><td><code>opt</code></td><td><strong>在IR级别对程序进行优化的工具，输入必须是LLVM位码文件(编码的LLVM-IR)，并且生成的输出文件必须具有相同的类型</strong></td></tr><tr class="even"><td><code>llc</code></td><td><strong>通过特定后端将LLVM位码转换为目标机器汇编语言文件或目标文件的工具，可以通过传递参数来选择优化级别，打开调试选项以及启用或禁用特定与目标的优化</strong></td></tr><tr class="odd"><td><code>llvm-mc</code></td><td><strong>能够汇编指令并生成诸如<code>ELF</code>,<code>Mach-O</code>,<code>PE</code>等对香格式的可执行目标文件，也可以反汇编相同的对象，从而转储这些指令的汇编信息和内部<code>LLVM</code>机器指令数据结构</strong></td></tr><tr class="even"><td><code>lli</code></td><td><strong>是<code>LLVM IP</code>的解释器和<code>JIT</code>编译器</strong></td></tr><tr class="odd"><td><code>llvm-link</code></td><td><strong>将几个<code>LLVM</code>位码链接在一起，以产生一个包含所有输入的<code>LLVM</code>位码</strong></td></tr><tr class="even"><td><code>llvm-as</code></td><td><strong>将人工可读的<code>LLVM-IR</code>文件(称为<code>LLVM</code>汇编码)转换为<code>LLVM</code>位码</strong></td></tr><tr class="odd"><td><code>llvm-dis</code></td><td><strong>将<code>LLVM</code>位码解码成为<code>LLVM</code>汇编码</strong></td></tr></tbody></table><h4 id="emit-llvm"><code>-emit-llvm</code></h4><ul><li><strong>LLVM位码</strong>： 编码的<code>LLVM-IR</code></li><li><strong>LLVM汇编码</strong>： 人工可读的<code>LLVM-IR</code></li></ul><p>假设<code>main.c</code>和<code>sum.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ vim main.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">main(<span class="keyword">void</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> r = sum(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"r = %d\n"</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ vim sum.c</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接使用<strong>编译器驱动程序<code>Clang</code></strong>的话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> clang main.c sum.c -o sum</span><br></pre></td></tr></table></figure><p>如果使用独立工具的话:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> clang -emit-llvm -c main.c -o main.bc</span><br><span class="line"><span class="meta">$</span> clang -emit-llvm -c sum.c -o sum.bc</span><br></pre></td></tr></table></figure><p>其中<code>-emit-llvm</code>编译选项可以让<code>clang</code>根据<code>-c</code>或者<code>-S</code>参数来生成<strong><code>LLVM</code>位码</strong>还是<strong><code>LLVM</code>汇编码</strong>。</p><ul><li><code>-c</code> 生成LLVM位码</li><li><code>-c -S</code>生成LLVM汇编码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> clang -emit-llvm -c -S main.c -o main.ll</span><br><span class="line"><span class="meta">$</span> clang -emit-llvm -c -S sum.c -o sum.ll</span><br></pre></td></tr></table></figure><h4 id="llc">llc</h4><p>该工具从每个LLVM位码文件内生成特定于目标的可重定位目标文件，并通过将其链接到系统链接器来构建可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> llc -filetype=obj main.bc -o main.o</span><br><span class="line"><span class="meta">$</span> llc -filetype= obj sum.bc -o sum.o</span><br><span class="line"><span class="meta">$</span> clang main.o sum.o -o sum</span><br></pre></td></tr></table></figure><h4 id="llvm-link">llvm-link</h4><p>该工具将多个LLVM位码文件连接成为最终的LLVM位码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> llvm-link main.bc sum.bc -o sum.linked.bc</span><br><span class="line"><span class="meta">$</span> llc -filetype=obj sum.linked.bc -o sum.linked.o</span><br><span class="line"><span class="meta">$</span> clang sum.linked.o -o sum</span><br></pre></td></tr></table></figure><p>可以看到所有的二进制工具都围绕几个中间形式的表示展开，这些中间表示在编译过程中占很重要的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;LLVM&lt;/strong&gt;，这个星球最牛逼的编译器。&lt;/p&gt;
&lt;p&gt;其核心设计理念就是&lt;strong&gt;统一的底层中间表达以及模块化的软件工程化方法。&lt;/strong&gt;LLVM采用了&lt;code&gt;前端-优化器-后端&lt;/code&gt;的组织形式，&lt;strong&gt;只是不同的前端和后端都采用统一的底层中间表示格式（LLVM IR）来最大可能复用优化器的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://nondot.org/sabre/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chris Lattner&lt;/a&gt;将其开源后，&lt;a href=&quot;http://llvm.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LLVM&lt;/a&gt;逐渐发展成为了成熟的编译框架，具有大量库和编译链工具。&lt;/p&gt;
&lt;p&gt;我使用的平台是&lt;code&gt;macOS Mojave 10.14&lt;/code&gt;，在编译的时候要注意版本是否兼容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般系统会通过打印二进制文件名称和无法加载的动态库的名称来发现链接错误。当屏幕上打印动态库名称时要予以注意，这说明系统动态链接器和加载器无法加载该库，因为该程序与当前系统不兼容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我编译&lt;code&gt;LLVM 10.0.0&lt;/code&gt;的时候出错如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;后来发现这个版本的&lt;code&gt;Xcode&lt;/code&gt;工具链最高只支持&lt;code&gt;LLVM 9.0.0&lt;/code&gt;版本，然后换了版本最后编译成功。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>LLVM漫谈（0-编译系统概述）</title>
    <link href="http://haotianmcihael.github.io/2020/06/02/LLVM%E6%BC%AB%E8%B0%88%EF%BC%880-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2020/06/02/LLVM漫谈（0-编译系统概述）/</id>
    <published>2020-06-01T20:36:42.000Z</published>
    <updated>2022-03-16T10:28:29.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abstract">Abstract</h1><p>从开始接触编译系统的学习已经快半年了，有些心得总结一下。</p><p>什么是编译系统？我想从两个角度谈一下：</p><p>首先从技术角度来讲，广义的编译系统负责将高级语言转换成为CPU可执行的二进制机器代码。编译系统包括<strong>编译器</strong>， <strong>汇编器</strong>，<strong>静态/动态链接器</strong>，<strong>操作系统装载器</strong>以及<strong>运行库</strong>。</p><ul><li>编译器： 是系统前半部分的核心，负责将源文件<strong>.c</strong>转换成为汇编文件<strong>.s</strong>。</li><li>汇编/链接/装载器：是系统后半部分的核心，主要是将<strong>.s</strong>转换为<strong>二进制ELF文件</strong>并进一步围绕<strong>ELF</strong>处理。</li><li>运行库：是操作系统层面用来支持<strong>高级语言运行环境</strong>比如内存池，标准API等的库文件。</li></ul><p>然后从专业的角度来讲，我觉得可以分为<strong>系统层面</strong>和<strong>算法优化层面</strong>，系统层面主要是整个编译框架比如LLVM，核心是和操作系统交互的部分，这部分内容是编译器工程师的基本功，需要掌握细节。而算法优化层面指的是<strong>编译优化</strong>——编译器工程师的最理想的方向就是做优化，这一部分需要精通，从静态单赋值SSA等传统的静态分析优化到现在主流的深度学习推理引擎比如TVM等。</p><p>本文主要是对系统层面的学习，对系统层面的学习止步于对LLVM编译框架的使用和源代码阅读。</p><a id="more"></a><h1 id="思路">思路</h1><p>本文主要分为三个部分，编译，ELF以及库文件。</p><p>首先简单介绍一下编译器的整体框架和编译流程。</p><p>**核心部分是学习*nix操作系统下的ELF文件的格式——普通c/c++高级程序在目标文件中是如何存储的；目标文件是如何被链接器链接在一起，并且形成可执行文件的过程。目标文件在链接时符号处理，重定位和地址分配如何进行。可执行文件如何被装载并且执行，可执行文件与进程的虚拟空间之间如何映射。讲解动态链接。 **</p><p>最后讲解一下运行库的原理和操作系统与编译系统交互的部分。</p><h1 id="编译器">编译器</h1><p>编译器分为前端和后端，直观上讲<strong>就是将源语言形式化的表示并翻译成为汇编目标语言</strong>。前端主要有：</p><ul><li><p><strong>词法分析器</strong></p></li><li><strong>语法分析器</strong>，</li><li><p><strong>语义分析器</strong></p></li></ul><p>等完成源语言的语法推导，语义处理，然后将特定信息收集到符号表中，不同的编译器前端会生成不同的<strong>中间表示</strong>——比如<strong>LLVM IR</strong>就是一种非常重要的中间代码。</p><p>后端主要是：</p><ul><li><p><strong>寄存器分配</strong></p></li><li><p><strong>指令选择</strong></p></li><li><p><strong>指令调度</strong></p></li></ul><p><strong>后端和目标机的关系比较紧密，也是优化的重点平台。 </strong></p><h1 id="汇编器">汇编器</h1><p>当编译器将源文件翻译成为汇编语言之后，<strong>.s</strong>文件需要进一步的被<strong>汇编器</strong>进行转换成为<strong>可重定位目标文件（Relocatable File）</strong>。</p><p>因为汇编语言本质上就是助记符，<strong>汇编器就是将汇编文件翻译成为机器可执行的初步的二进制文件，这里的初步是汇编器汇编之后生成的.o文件还不能直接在操作系统中运行，这是因为.o文件中很多符号和变量的地址都没有确定——属于相对地址，所以无法加载到进程地址空间中，而且其运行还需要操作系统提供的运行库提供支持，这一切都需要链接器来完成。所以.o文件又称为可重定位目标文件。</strong></p><p>从<strong>.s</strong>文件翻译成为<strong>.o</strong>文件，必须按照特定指令集的机器码，还有ELF文件的格式来转换，实现起来不是很难——<strong>需要精通目标机器的体系结构，以及目标机器的ELF文件格式</strong>。这里不涉及体系结构的知识。</p><h1 id="elf">ELF</h1><h2 id="elf简介">ELF简介</h2><p>其实从汇编器的实现中就已经用到了ELF的知识。</p><p>ELF可以说是编译系统工具链中的最重要的文件格式了，离开编译器之后的所有编译步骤几乎都和ELF相关或者围绕ELF展开，所以对它的研究非常有意义。</p><p>最早是由Unix System V Release3提出了COFF的概念以及使用规范。后来Windows基于COFF指定了PE格式标准，而Linux也以ELF作为基本格式。COFF的主要贡献就是提供了“段segment”的概念。</p><h2 id="elf类型">ELF类型</h2><p>根据ELF文件标准，可以分为下面4类：</p><table><colgroup><col style="width: 24%"><col style="width: 37%"><col style="width: 37%"></colgroup><thead><tr class="header"><th>ELF文件类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr class="odd"><td><strong>可重定位目标文件(Relocatable File)</strong></td><td>由汇编器生成的.o文件，又被称为<strong>目标文件</strong>，因为需要连接重定位其文件中的符号地址所以叫Relocatable；另外，<strong>静态链接库.a其实也是使用ar程序将很多.o文件压缩并对其进行索引和编号。所以也算此类型。</strong></td><td>Linux下的.o文件，.a静态库文件；Windows下的.obj，.lib静态库文件</td></tr><tr class="even"><td><strong>可执行文件(Executable File)</strong></td><td>是可以直接执行的程序，又被称为<strong>可执行文件</strong>。</td><td>/usr/bash文件；Windows下的.exe</td></tr><tr class="odd"><td><strong>共享目标文件(Shared Object File)</strong></td><td><strong>共享</strong>就是动态链接的本质。其可以被链接器继续链接生成新的目标文件；也可以和可执行文件结合，作为进程映像的一部分来运行。</td><td>Linux下的.so；Windows下的DLL</td></tr><tr class="even"><td><strong>核心转储文件(Core Dump File)</strong></td><td>当进程意外终止的时候，系统可以将该进程的地址空间及终止时的一些其他信息转储到核心转储文件中。</td><td>Linux下的core dump</td></tr></tbody></table><h2 id="elf格式">ELF格式</h2><h3 id="分段">分段</h3><p>以目标文件<strong>.o</strong>为例介绍，目标文件中的内容至少含有编译后的机器指令<strong>代码和数据</strong>。按照COFF的历史规定，ELF格式也是按照<strong>段-segment</strong>来管理的。下面是ELF文件的基本格式：</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>从图中可以看到，ELF的开头是<strong>ELF Header</strong>，描述了整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接及入口地址（如果是可执行文件的话），目标硬件，操作系统等信息。ELF中第二重要的数据结构是<strong>Section Header table</strong>——描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移量以及段的属性等，从其中可以得到每个段的所有信息。<strong>ELF Header</strong>后面就是各个段的内容。分段的目的如下：</p><ul><li>当指令和数据分离的时候，<strong>操作系统可以分配不同的读写权限便于管理</strong></li><li>当指令和数据分离的时候，<strong>CPU缓存的命中率会更高</strong></li><li>当指令和数据分离的时候，<strong>多个进程可以共享同一份指令，节省开销</strong></li></ul><h3 id="elf-header">ELF Header</h3><p>是ELF文件最开头的一个结构体。它包含了描述整个文件的基本属性。因为ELF文件在各个平台下都通用，为了对每个成员的大小做出明确的规定以便保持兼容性。ELF使用typedef定义了一套自己的变量体系类似<code>Elf32_Addr</code>这种。下面简单列出文件头中的关键信息：</p><ul><li>ELF魔数，文件机器字节长度，数据存储方式，版本，运行平台，</li><li>ABI版本，ELF重定位类型，硬件平台，<strong>入口地址（OS加载的虚拟地址，可重定位目标文件该值为0）</strong>，程序头入口和长度，</li><li><strong>Section Header table的位置（以偏移量的方式）</strong>和长度及段的数量</li></ul><p>魔数：当年的UNIX是在PDP小型机器上开发的，而当时的系统加载可执行文件直接从第一个字节开始运行，人们一般将第一条指令设置为跳转指令，这个魔数就是当时的JMP指令，为了兼容性被保留下来。</p><h3 id="section-header-table">Section Header table</h3><p>段表描述了ELF的各个段segment的信息比如段名，段长度，段偏移以及段的读写权限等。 实现上，一般会采取一个结构体数组来表示段表。</p><ul><li>段类型： 很多类型比如<code>.data</code>,<code>.text</code>或者<code>.rel</code>,<code>.string</code>等</li><li>段标志位：表示该段在进程内虚拟地址空间中的属性</li></ul><h3 id="relocation-table">Relocation Table</h3><p>目标文件中代码段和数据段那些对绝对地址的引用，需要在链接的时候重定位。每一个需要重定位的位置，最后都会有一个<strong>相应的重定位表</strong>比如<code>.rel.txt</code>,<code>.rel.data</code>等。</p><h3 id="sections">Sections</h3><ul><li><code>.data</code>: 保存初始化的全局变量和局部静态变量</li><li><code>.bss</code>: 保存未初始化的全局变量和局部静态变量</li><li><code>.data</code>: 保存代码段，等等</li></ul><p>整个ELF文件有很多段比如字符串段，调试信息段strip等。包括在不同的平台标准上ELF格式都不同，这里不展开说了。</p><h1 id="链接器">链接器</h1><p>链接的本质就是要把多个不同的目标文件之间相互“粘”在一起——<strong>实际上就是目标文件之间地址的引用，及对函数和变量的地址的引用。</strong></p><h2 id="符号">符号</h2><p><strong>在链接过程中，每一个ELF目标文件都会有一个相应的符号表，这个符号表对应ELF中的一个段<code>.symtab</code>，这个表里记录了目标文件所用到的所有符号，每个定义的符号有一个符号值，对于变量和函数来说该值就是其地址。</strong></p><p>ELF的符号可以大致分为：</p><ul><li><strong>定义</strong>在目标文件中的<strong>全局符号</strong></li><li>在目标文件内中<strong>引用</strong>的<strong>全局符号，又称为外部符号</strong></li><li>段名</li><li>局部符号</li><li>链接器在生成可执行文件的时候，自行定义的特殊符号比如程序起始地址<code>__executable_start</code></li></ul><p>其中最重要的就是<strong>全局符号</strong>，因为其他的符号只是在目标文件中可见，而全局符号的作用域是跨文件的。</p><p>UNIX系统通过<strong>符号修饰</strong>和<strong>函数签名</strong>机制防止不同目标文件中的符号名称冲突。</p><h3 id="强弱符号定义引用">(强/弱符号)(定义/引用)</h3><p>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。<strong>强符号和弱符号都是针对定义来说的，不是针对符号的引用。</strong></p><ul><li>不同的目标文件中不允许有同名的强符号</li><li>强符号可以屏蔽弱符号</li></ul><p>而当外部变量的符号引用在目标文件被链接成为可执行文件时，如果是强引用，如果定义不存在则报错，而弱引用不会报错。<strong>强/弱引用一般用于库文件的链接过程。</strong></p><h2 id="静态链接">静态链接</h2><p>链接器一般都采用<strong>Two-pass Linking</strong>的方式：</p><ul><li><strong>空间与地址分配：</strong> 扫描所有的输入文件，获得它们各个段的长度，属性和位置，<strong>并将输入目标文件中的符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表。</strong></li><li><strong>符号解析与重定位：</strong> 读取输入文件中段的数据，重定位信息；进行<strong>符号解析与重定位，调整代码中的地址。</strong><ul><li>各个段中的符号地址</li><li>代码中的地址引用</li></ul></li></ul><h3 id="空间与地址分配">空间与地址分配</h3><p>链接器能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p><p><img src="2.png" width="50%" height="50%" alt=""></p><h3 id="符号解析与重定位">符号解析与重定位</h3><p>这里有两部分，符号的地址和代码中的地址。其中链接器在完成地址和空间分配之后就可以确定所有<strong>符号</strong>的虚拟地址了，而链接器就可以根据符号的地址(<strong>通过查找由所有输入目标文件的符号表组成的全局符号表</strong>)对每个需要<strong>重定位的指令——即会用到外部符号的指令</strong>进行地址修正。</p><h4 id="重定位表">重定位表</h4><p>链接器通过ELF文件中的重定位表来完成指令中地址的调整。</p><h4 id="abi">ABI</h4><p>指的是和二进制兼容性有关的内容：</p><ul><li>内置类型的大小和在存储器中的放置方式（大端，小端，对齐方式等）</li><li>组合类型（结构体，数组等）的存储方式和内存分布</li><li>外部符号与用户定义的符号之间的命名方式和解析方式</li><li>函数调用方式，比如参数入栈顺序，返回值如何保存等</li><li>堆栈的分布方式，比如参数和局部变量在堆栈中的位置，参数传递方式等</li><li>寄存器使用约定</li></ul><h4 id="静态链接库">静态链接库</h4><p>静态链接库实际上就是一组目标文件的集合。即很多目标文件经过压缩打包之后的一个文件。</p><p><img src="3.png" width="50%" height="50%" alt=""></p><h2 id="装载">装载</h2><h3 id="虚拟地址空间">虚拟地址空间</h3><p>首先32位CPU指的是CPU的数据线是32位的，但是其地址线不一定只有32位，PAE地址扩展方式修改了页映射的方式使得可以访问到更多的物理内存。而操作系统提供一个窗口映射的方式，将这些额外的内存映射到进程地址空间中。应用程序可以根据需要来申请和映射，比如Linux中的mmap系统调用。</p><p>关于现代操作系统的虚拟内存管理机制这里不展开介绍。</p><h3 id="内核装载elf可执行文件">内核装载ELF可执行文件</h3><p>一共有如下四个步骤：</p><h4 id="进程创建">进程创建</h4><p><strong>第一步是创建一个独立的虚拟地址空间。 </strong></p><p>创建虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构。在i386的Linux下，<strong>创建虚拟地址空间实际上就是分配一个页目录</strong>就可以了，甚至不设置页映射关系——这些等到后面程序发生缺页中断的时候再进行设置（<strong>当程序发生了页错误，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，在设置缺页和物理页框的映射关系</strong>）。</p><p><strong>这一步本质上就是完成虚拟空间到物理内存的映射关系。</strong></p><h4 id="完成elf和进程的映射">完成ELF和进程的映射</h4><p><strong>第二步是读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。 </strong></p><p>很明显，这种映射关系是保存在操作系统中的一个数据结构（类似页目录）。<strong>Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。</strong>操作系统在内部保存这种VMA结构，就是因为当程序发生段错误的时候，可以通过查找这样一个数据结构来定位错误页在可执行文件中的位置。</p><h4 id="运行">运行</h4><p><strong>第三步是将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</strong></p><p>操作系统进行内核堆栈和用户堆栈的切换，CPU运行权限的切换，然后设置CPU的指令寄存器并将控制权交给进程。</p><h4 id="缺页中断">缺页中断</h4><p>在上述步骤都完成之后，其实可执行文件的真正指令和数据都没有被装载进内存中。<strong>操作系统只是通过可执行文件头部的信息建立起来可执行文件和进程虚存之间的映射关系而已。</strong></p><p><strong>当发生一次缺页中断的时候，操作系统将查询这个数据结构，然后找到空页面所在的VMA ，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与物理页之间建立映射关系，完成真正的装载。</strong></p><p><img src="4.png" width="50%" height="50%" alt=""></p><h3 id="进程虚拟地址空间分布">进程虚拟地址空间分布</h3><h4 id="elf文件链接视图和执行视图">ELF文件链接视图和执行视图</h4><p>操作系统装载ELF可执行文件的时候是以段segment为单位的，一般只关心跟装载有关的问题，最主要的是段的权限(可读，可写，可执行)。ELF文件中，段的权限往往只有为数不多的几种组合，基本上是三种：</p><ul><li>以代码段为代表的权限为可读可执行的段</li><li>以数据段和BSS段为代表的权限为可读可写的段</li><li>以只读数据段为代表的权限为只读的段</li></ul><p><strong>一般对于相同权限的段，把它们合并在一起作为一个段进行映射——成为segment。多个sections组合成为segment，装载的时候一个segment在进程虚拟空间中只有一个对应的VMA，这样可以明显的减少内部碎片，从而节省了内存空间。 </strong></p><p>所以对于系统来讲，section是链接视图，而segment是执行视图。</p><p>在操作系统装载的时候，VMA除了用来映射可执行文件中的各个segment以外，事实上进程虚拟空间中的堆栈也是以VMA的形式存在的。所以总结一下，操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间，基本原则就是相同权限属性的，有相同映像文件的映射成一个VMA，一个进程基本上可以分为如下几种VMA区域：</p><ul><li>代码VMA，权限只读、可执行；有映像文件</li><li>数据VMA，权限可读写，可执行；有映像文件</li><li>堆VMA，权限可读写，可执行；无映像文件，匿名，可向上扩展</li><li>栈VMA，权限可读写，不可执行；无映像文件，匿名，可向下扩展</li></ul><p><img src="5.png" width="50%" height="50%" alt=""></p><h4 id="段地址对齐">段地址对齐</h4><p>因为装载过程是通过虚拟内存的页映射机制完成的。假设页大小默认为4096Bytes，所以如果要将一段物理内存和进程虚拟地址空间之间建立映射关系，<strong>这段内存空间的长度必须是4K的整数倍，并且这段空间在物理内存和进程虚拟地址空间中的起始地址必须是4096的整数倍。 </strong> 系统为了防止碎片化，也会采取一些优化的映射方案，这里不深入了。</p><h2 id="动态链接">动态链接</h2><p>静态链接有<strong>空间浪费</strong>和<strong>更新困难</strong>两个问题。</p><p>共享文件在内存中只存在一份，这样不仅仅节省内存，还增加CPU缓存的命中率。ELF动态链接文件称为<strong>.so</strong>共享对象文件，而Windows动态链接库称为<strong>.dll</strong>文件。</p><p>当程序被装载的时候，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并且将程序中所有<strong>未决议的符号</strong>绑定到相应的动态链接库中，并进行重定位工作。<strong>也就是说动态链接器把链接这个过程从本来的程序装载前被推迟到装载的时候。</strong>这样的话<strong>动态链接与静态链接相比，性能损失大约在5%以下。这点损失换取空间上的节省和程序构建和升级时的灵活性，是想当值得的。</strong></p><p><img src="6.png" width="50%" height="50%" alt=""></p><h3 id="地址无关代码">地址无关代码</h3><p>由性质可以知道<strong>共享对象在编译的时候不能假设自己在进程虚拟地址空间中的位置。</strong>而可执行文件基本可以确定自己在虚拟地址空间中的起始位置。这里注意动态链接的模块概念：可执行文件模块和正常静态链接一样，而共享对象模块即动态链接库就不行。</p><p>那共享对象在被加载的时候，如何确定它在进程虚拟地址空间中的位置？</p><p>这里提出一个问题：<code>如果直接将目标文件推迟到装载的时候再链接可以吗？</code></p><p>答案是不行。<strong>动态链接模块被装载映射到虚拟空间之后，指令部分是在多个进程中共享的，由于装载的时候重定位的方法需要修改指令（会影响代码段中的绝对地址引用），所以没有办法做到同一份指令被多个进程共享。</strong></p><p>所以最终的解决办法就是：<strong>将共享的指令部分中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一份副本——所谓地址无关代码(PIC, Pisition-independent Code)技术。</strong></p><h4 id="代码段地址无关代码">代码段地址无关代码</h4><p>这里把共享对象模块中的地址引用按照是否跨模块分为两类：模块内部引用和模块外部引用；按照不同的引用方式有可以分为指令引用和数据访问。</p><ul><li>模块内部的函数调用，跳转等</li><li>模块内部的数据访问，比如模块中定义的全局变量，静态变量</li><li>模块外部的函数调用，跳转等</li><li>模块外部的数据访问，比如模块中定义的全局变量，静态变量</li></ul><p><img src="7.png" width="50%" height="50%" alt=""></p><p>这里提一下模块间，因为这些全局变量的地址是跟模块装载地址有关的。ELF的做法就是在数据段中建立一个<strong>指向这些变量的指针数组，也被称为全局偏离表(Global Offset Table GOT)</strong>，当代码需要引用该全局变量的时候，可以通过GOT中相对应的项间接引用。</p><p><img src="8.png" width="50%" height="50%" alt=""></p><p>链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。GOT在数据段所以可被修改。总结一下：</p><table><thead><tr class="header"><th></th><th>指令跳转，调用</th><th>数据访问</th></tr></thead><tbody><tr class="odd"><td>模块内部</td><td>相对跳转和调用</td><td>相对地址访问</td></tr><tr class="even"><td>模块外部</td><td>间接跳转和调用GOT</td><td>间接访问GOT</td></tr></tbody></table><h5 id="共享模块的全局变量问题">共享模块的全局变量问题</h5><p>这里需要注意，如果一个模块引用了一个定义在共享对象的全局变量的时候。编译器无法判断该global是在同一个模块的其他目标文件中，还是定义在另一个共享对象中。</p><p>解决办法是所有的全局变量都通过GOT访问。</p><h4 id="数据段地址无关代码">数据段地址无关代码</h4><p>数据段中也会出现绝对地址引用的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">static int *p = &amp;a;</span><br></pre></td></tr></table></figure><p>这里的指针p就是一个绝对地址。一般来说，如果发现数据段中有绝对地址引用，编译器和链接器会产生一个重定位表。</p><p>对于可执行文件来说，默认情况下，如果可执行文件是动态链接的，那么编译器会使用PIC的方法来产生可执行文件的代码段部分，以便于不同的进程能够共享代码段，节省内存。所以一般动态链接的可执行文件中会有<code>.got</code>段。</p><h3 id="动态链接过程">动态链接过程</h3><p>动态链接情况下，可执行文件的装载与静态链接情况基本一样。首先操作系统会读取可执行文件的头部，检查文件的合法性，然后文件头中读取每个“Segment”的虚拟地址，文件地址和属性，并将它们映射到进程虚拟空间的相应位置，这些步骤跟前面的静态链接情况下的装载基本无异。在静态链接情况下，操作系统接着就可以把控制权转交给可执行文件的入口地址，然后程序开始执行，一切很顺利。</p><p>但是在动态链接下，操作系统还不能再装载完可执行文件之后就把控制权交给可执行文件，因为我们知道可执行文件依赖于很多共享对象，<strong>这时候可执行文件里对于很多外部符号的引用还处于无效地址的状态，即还没有跟相应的共享对象中的实际位置链接起来</strong>。所以在映射完可执行文件之后，操作系统会其中一个动态链接器。</p><p>动态链接分为三步：启动动态链接器本身，然后装载所有需要的共享对象，最后是重定位和初始化。</p><h3 id="共享库">共享库</h3><p>因为动态链接的诸多优点，操作系统中一般有很多共享对象——按照合理的组织和使用方式构建起来的共享库。共享库的更新会影响ABI的使用。</p><h1 id="运行库">运行库</h1><p>经过前面的介绍，基本上编译系统的概念都介绍完了。下面的部分涉及操作系统接口，也只是简单的介绍一下。</p><p>操作系统装载程序之后，首先运行的代码并不是<code>main</code>的第一行，而是某些别的代码，这些代码负责准备好<code>main</code>函数执行所需要的环境，并且负责调用<code>main</code>函数，这时候才可以申请内存，使用系统调用，触发异常，访问I/O。在函数返回之后会记录<code>main</code>的返回值，调用<code>atexit</code>注册的函数，然后结束进程。</p><p>运行这些代码的函数成为<strong>入口函数</strong>或者<strong>入口点</strong>。这些都是运行库的一部分。个人理解运行库的概念就是操作系统和应用层的接口，区别于系统调用，比如Glibc那样。</p><h1 id="常用二进制工具基于llvm">常用二进制工具(基于LLVM)</h1><table><thead><tr class="header"><th>命令</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>llvm-size</code></td><td>查看ELF文件的各个段的大小</td></tr><tr class="even"><td><code>llvm-readelf -h</code></td><td>查看ELF Header(部分)</td></tr><tr class="odd"><td><code>llvm-readelf -S</code></td><td>查看ELF Header(全部)</td></tr><tr class="even"><td><code>llvm-objdump -s</code></td><td>将所有ELF段以十六进制的方式打印</td></tr><tr class="odd"><td><code>llvm-objdump -d</code></td><td>将所有指令段反汇编 <strong>字节寻址,小端</strong></td></tr><tr class="even"><td><code>llvm-nm</code></td><td>查看ELF文件的符号表</td></tr><tr class="odd"><td><code>c++filt</code></td><td>解析函数签名</td></tr><tr class="even"><td><code>ld a.o b.o -e main -o ab</code></td><td>直接使用链接器生成可执行文件ab（将main函数作为程序入口）</td></tr><tr class="odd"><td><code>llvm-objdump -r</code></td><td>查看目标文件的重定位表</td></tr><tr class="even"><td><code>ar -t libc.a</code></td><td>查看静态链接库包含了那些文件</td></tr><tr class="odd"><td><code>clang -fPIC -shared lib.so  lib.c</code></td><td>编译一个共享对象文件</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;
&lt;p&gt;从开始接触编译系统的学习已经快半年了，有些心得总结一下。&lt;/p&gt;
&lt;p&gt;什么是编译系统？我想从两个角度谈一下：&lt;/p&gt;
&lt;p&gt;首先从技术角度来讲，广义的编译系统负责将高级语言转换成为CPU可执行的二进制机器代码。编译系统包括&lt;strong&gt;编译器&lt;/strong&gt;， &lt;strong&gt;汇编器&lt;/strong&gt;，&lt;strong&gt;静态/动态链接器&lt;/strong&gt;，&lt;strong&gt;操作系统装载器&lt;/strong&gt;以及&lt;strong&gt;运行库&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译器： 是系统前半部分的核心，负责将源文件&lt;strong&gt;.c&lt;/strong&gt;转换成为汇编文件&lt;strong&gt;.s&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;汇编/链接/装载器：是系统后半部分的核心，主要是将&lt;strong&gt;.s&lt;/strong&gt;转换为&lt;strong&gt;二进制ELF文件&lt;/strong&gt;并进一步围绕&lt;strong&gt;ELF&lt;/strong&gt;处理。&lt;/li&gt;
&lt;li&gt;运行库：是操作系统层面用来支持&lt;strong&gt;高级语言运行环境&lt;/strong&gt;比如内存池，标准API等的库文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后从专业的角度来讲，我觉得可以分为&lt;strong&gt;系统层面&lt;/strong&gt;和&lt;strong&gt;算法优化层面&lt;/strong&gt;，系统层面主要是整个编译框架比如LLVM，核心是和操作系统交互的部分，这部分内容是编译器工程师的基本功，需要掌握细节。而算法优化层面指的是&lt;strong&gt;编译优化&lt;/strong&gt;——编译器工程师的最理想的方向就是做优化，这一部分需要精通，从静态单赋值SSA等传统的静态分析优化到现在主流的深度学习推理引擎比如TVM等。&lt;/p&gt;
&lt;p&gt;本文主要是对系统层面的学习，对系统层面的学习止步于对LLVM编译框架的使用和源代码阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
      <category term="Linker" scheme="http://haotianmcihael.github.io/tags/Linker/"/>
    
      <category term="Loader" scheme="http://haotianmcihael.github.io/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>GCC-RISCV交叉编译工具链</title>
    <link href="http://haotianmcihael.github.io/2020/02/16/Gcc-RISCV%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>http://haotianmcihael.github.io/2020/02/16/Gcc-RISCV交叉编译工具链/</id>
    <published>2020-02-15T18:16:45.000Z</published>
    <updated>2022-03-16T10:25:43.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="absrtact">Absrtact</h3><p>旨在x86平台上编译RISCV架构的可执行文件。</p><p>RISCV作为一款极具使命感的指令集，其软件栈也是非常完整的。交叉编译环境可以在<a href="https://github.com/riscv/riscv-gnu-toolchain" target="_blank" rel="noopener">这里</a>下载。</p><p>交叉编译工具链包括:</p><ul><li><code>GCC</code>编译器</li><li>C运行库<ul><li><code>Glibc</code> : <code>gnu</code>旗下的库，作为<code>linux</code>的标准库和内核打交道</li><li><code>Newlib</code>： 在嵌入式中使用广泛</li></ul></li><li><code>Buntils</code>二进制套件</li><li><code>GDB</code>调试器</li></ul><a id="more"></a><h3 id="不同版本的工具链">不同版本的工具链</h3><table><thead><tr class="header"><th>Version</th><th>Note</th></tr></thead><tbody><tr class="odd"><td>Riscv-unknown-linux-gnu-gcc</td><td><sup>1</sup>32位架构的<sup>2</sup><strong>Linux版本</strong></td></tr><tr class="even"><td>Riscv-unknown-elf-gcc</td><td>32位架构的<strong>非Linux版本</strong></td></tr></tbody></table><ul><li>每个版本都有32位架构和64位架构，这里的位数和运行本机的字长无关，<strong>指的是没有通过<code>-march=</code>和<code>-mabi=</code>选项指定RISCV架构的位宽</strong></li><li><strong>Linux版本</strong>指的是<strong>该工具链使用Linux系统中运行的<code>Glibc</code>作为C运行库——</strong>另外的个版本则使用<code>Newlibc</code>库</li></ul><h3 id="交叉编译选项">交叉编译选项</h3><h4 id="march">-march=</h4><p>​ 由于<span class="math inline">\(RISCV\)</span>为模块化指令，该选项支持不同的模块化指令集组合,关于<span class="math inline">\(RISCV\)</span>模块见后面的介绍:</p><ul><li><code>rv32i[m][a][f[d]][c]</code></li><li><code>rv32g[c]</code></li><li><code>rv64i[m][a][f[d]][c]</code></li><li><code>rv64g[c]</code></li></ul><h4 id="mabi">-mabi=</h4><p>​ 该选项选定了目标平台所支持的<code>ABI</code>函数调用:</p><ul><li><code>ilp32</code>，<code>ilp32f</code>，<code>ilp32d</code> 32位架构(int-32位 long-32位 long long-64位)</li><li><code>lp64</code>，<code>lp64f</code>，<code>lp64d</code> 64位架构(int-32位 long-64位)</li></ul><h4 id="后缀">后缀</h4><table><thead><tr class="header"><th>suffix</th><th>Note</th></tr></thead><tbody><tr class="odd"><td>--</td><td>使用浮点类型操作直接使用RISCV浮点指令进行支持，但是当浮点数作为函数参数进行传递时，无论是单精度还是双精度均需要存储器中的堆栈进行传递</td></tr><tr class="even"><td>-f</td><td>使用浮点类型操作直接使用RISCV浮点指令进行支持，但是当浮点数作为函数参数进行传递时，单精度通过寄存拿起传递，双精度通过内存堆栈传递</td></tr><tr class="odd"><td>-d</td><td>使用浮点类型操作直接使用RISCV浮点指令进行支持，但是当浮点数作为函数参数进行传递时，单/双精度均可通过寄存器传递</td></tr></tbody></table><p><strong>只有<code>-march=</code>支持浮点扩展，(-mabi=)才允许加上<code>f/d</code>后缀以支持浮点运算。</strong></p><p><img src="1.png" width="50%" height="50%" alt=""></p><h3 id="riscv汇编语言简介">RISCV汇编语言简介</h3><p><img src="2.png" width="50%" height="50%" alt=""></p><h3 id="总结">总结</h3><p>目前交叉编译平台主要有两部分: <code>riscv32-unknown-elf-gcc</code>平台编译生成<span class="math inline">\(RISCV\)</span>可执行文件，而<code>qemu-riscv32</code>平台运行<code>RISCV</code>可执行文件。</p><p><code>qemu</code>是一款很强大的虚拟机，分为系统模式和用户模式，用户模式运行可执行文件，而系统模式模拟特定指令集从而运行操作系统镜像文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;absrtact&quot;&gt;Absrtact&lt;/h3&gt;
&lt;p&gt;旨在x86平台上编译RISCV架构的可执行文件。&lt;/p&gt;
&lt;p&gt;RISCV作为一款极具使命感的指令集，其软件栈也是非常完整的。交叉编译环境可以在&lt;a href=&quot;https://github.com/riscv/riscv-gnu-toolchain&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;下载。&lt;/p&gt;
&lt;p&gt;交叉编译工具链包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GCC&lt;/code&gt;编译器&lt;/li&gt;
&lt;li&gt;C运行库
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Glibc&lt;/code&gt; : &lt;code&gt;gnu&lt;/code&gt;旗下的库，作为&lt;code&gt;linux&lt;/code&gt;的标准库和内核打交道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Newlib&lt;/code&gt;： 在嵌入式中使用广泛&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buntils&lt;/code&gt;二进制套件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GDB&lt;/code&gt;调试器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="RISCV" scheme="http://haotianmcihael.github.io/tags/RISCV/"/>
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>从syscall的角度理解操作系统</title>
    <link href="http://haotianmcihael.github.io/2019/06/25/%E4%BB%8Esyscall%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://haotianmcihael.github.io/2019/06/25/从syscall的角度理解操作系统/</id>
    <published>2019-06-25T06:34:20.000Z</published>
    <updated>2022-03-16T09:53:19.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abstract">Abstract</h1><p>操作系统控制硬件资源并完成底层抽象。</p><p>UNIX和C的发展一脉相承。20世纪80年代以来，针对UNIX的各种<strong>标准化工作</strong>对其实现提供了具体的限制以此来完善系统不同实现之间的可移植性——<strong>ISO-C，IEEE-POSIX以及Single UNIX Specification</strong>等等。</p><p><strong>这些标准本质上是应用程序和操作系统接口的子集。</strong>一个操作系统的具体实现除了内核之外，最重要的就是对API的封装。<strong>UNIX一般通过系统调用和运行库的方式来完成应用程序接口，比如GNU为Linux开发的Gblic就支持ISO-C和IEEE-POSIX等核心标准。</strong></p><p>个人觉得从<strong>系统编程和内存</strong>的角度去理解<strong>文件系统</strong>和<strong>进程/线程</strong>等OS核心概念会比较有趣。</p><a id="more"></a><h1 id="文件系统">文件系统</h1><p>文件系统是一种持久性存储的系统抽象。并涉及到<strong>磁盘空间</strong>和<strong>内存空间</strong>的IO操作，比较难理解：</p><ul><li><strong>文件描述符表</strong>，<strong>打开文件表</strong>，<strong>i节点</strong>是文件存储的本质，而<strong>文件长度</strong>，<strong>文件偏移量</strong>，<strong>文件所占磁盘空间</strong>，<strong>文件用户权限</strong>是文件的重要属性。可以从<code>dup</code>，<code>lseek</code>，<code>stat/chmod</code>等函数理解</li><li><strong>理解内核获取文件的过程是最核心的</strong>。这涉及到<strong>内核页高速缓存</strong>，<strong>用户区间缓冲区</strong>，<strong>标准IO缓冲区</strong>等核心概念。可以从<code>read/write</code>，<code>fgets/fputs</code>，<code>sync/flush</code>函数理解</li><li>从<strong>用户时间</strong>和<strong>CPU时间</strong>理解标准IO函数和<code>read/write</code>等系统调用。<strong>系统调用的开销要大于函数调用。</strong>而这一切都取决于双方缓冲区的选择</li></ul><h1 id="进程">进程</h1><p>进程是独立功能的程序在数据集合上的一次动态执行过程。</p><ul><li>准备</li><li>就绪</li><li>阻塞</li><li>执行</li><li>结束</li></ul><p>内核为每个进程维护一个<strong>进程控制块</strong>，从<code>fork/exit/wait</code>等函数可以理解这些状态。另外<code>fork/exec</code>区分了父子进程在创建前后所共享的资源：</p><ul><li>代码段（<strong>但是子进程获得父进程数据空间，堆栈空间的副本</strong>）</li><li>打开的文件描述符</li><li>实际ID，有效ID，设置ID</li><li>存储映像</li></ul><h1 id="线程">线程</h1><p>每个线程都包含又表示执行环境所必需的信息，其中包括进程中表示线程的线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量以及线程私有数据。<strong>一个进程的的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码，程序的全局内存和堆内存，栈以及文件描述符。</strong></p><ul><li>进程是资源分配单位</li><li>线程是CPU调度单位</li></ul><p><strong>多线程切换因为相同那那个的地址空间——页表，因此切换更快。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abstract&quot;&gt;Abstract&lt;/h1&gt;
&lt;p&gt;操作系统控制硬件资源并完成底层抽象。&lt;/p&gt;
&lt;p&gt;UNIX和C的发展一脉相承。20世纪80年代以来，针对UNIX的各种&lt;strong&gt;标准化工作&lt;/strong&gt;对其实现提供了具体的限制以此来完善系统不同实现之间的可移植性——&lt;strong&gt;ISO-C，IEEE-POSIX以及Single UNIX Specification&lt;/strong&gt;等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些标准本质上是应用程序和操作系统接口的子集。&lt;/strong&gt;一个操作系统的具体实现除了内核之外，最重要的就是对API的封装。&lt;strong&gt;UNIX一般通过系统调用和运行库的方式来完成应用程序接口，比如GNU为Linux开发的Gblic就支持ISO-C和IEEE-POSIX等核心标准。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人觉得从&lt;strong&gt;系统编程和内存&lt;/strong&gt;的角度去理解&lt;strong&gt;文件系统&lt;/strong&gt;和&lt;strong&gt;进程/线程&lt;/strong&gt;等OS核心概念会比较有趣。&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="UNIX" scheme="http://haotianmcihael.github.io/tags/UNIX/"/>
    
      <category term="Syscall" scheme="http://haotianmcihael.github.io/tags/Syscall/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Lab2</title>
    <link href="http://haotianmcihael.github.io/2018/11/22/Mit6-828-Fall-2018-Lab2/"/>
    <id>http://haotianmcihael.github.io/2018/11/22/Mit6-828-Fall-2018-Lab2/</id>
    <published>2018-11-21T20:51:42.000Z</published>
    <updated>2022-03-16T10:32:07.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lab2">Lab2</h2><h3 id="before-lab">Before Lab</h3><p>Lab2的主要内容:<code>Physical Page Management</code>,<code>Virtual Memroy</code>,<code>Kernel Address Space</code>;<strong>代码实现JOS中的内存分页管理功能，有页面管理和页表管理两部分。</strong>和理论相比，代码实现需要考虑的细节真是太多。实验最终的目的是通过几个检测函数:</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>Lab1完成时整个JOS内存布局如下图:</p><p><img src="9.png" width="50%" height="50%" alt=""></p><p>切换合并Git分支的时候可能会出现冲突，需要手动注释掉Lab1中的一些测试代码来解决，这里不再赘述。 <a id="more"></a></p><h3 id="memlayout.h和pmap.h">memlayout.h和pmap.h</h3><p>掌握这两个文件中的函数是完成Lab2必不可少的条件，在此进行总结。</p><h4 id="pmap.h">pmap.h</h4><p>Lab2中需要重点关注的对象有三个:物理内存，虚拟内存，空闲链表<strong><code>struct PageInfo</code></strong>。该头文件中的函数实现了三者之间的相互转化。</p><p><img src="2.png" width="50%" height="50%" alt=""></p><p>另外还有几个外部变量也需要重点关注一下:</p><ul><li><code>bootstack</code> 内核栈</li><li><code>pages</code> 所有物理内存按照4KB划分的对应映射数组</li><li><code>npage</code> 数组元素个数</li><li><code>kern_pgdir</code> 页目录</li></ul><p><strong>注意pages不是空闲链表，仅仅只是一个数组而已。而pages数组索引就是所有页式物理内存的索引。</strong>所以<code>struct PageInfo *pp</code>和物理内存关系很紧密：**(pp-pages)*4KB就是该数组元素对应的物理页面page的物理地址**，这也是<code>page2pa</code>函数的原型。</p><h4 id="memlayout.h">memlayout.h</h4><p>介绍了JOS虚拟内存的详细布局，定义了所有需要使用的宏。<strong>在Lab2中，我们需要完成的是内核部分虚拟地址到物理的映射。所以重点关注的是UTOP之上的布局.</strong>当然需要注意的细节就很多了，比如大小，权限，每一部分内存的作用等。</p><p><img src="3.png" width="50%" height="50%" alt=""></p><p>上图只是一个简化图，结合源码看会好很多，比如一些和大小有关的宏定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define PGSIZE          4096            // bytes mapped by a page</span><br><span class="line">#define KSTKSIZE        (8*PGSIZE)              // size of a kernel stack</span><br><span class="line">#define PTSIZE          (PGSIZE*NPTENTRIES) // bytes mapped by a page directory entry</span><br><span class="line">#define NPTENTRIES      1024            // page table entries per page table</span><br></pre></td></tr></table></figure><p>其中阴影部分指的是<code>page_init()</code>函数之前已经初始化好的。这是因为在<code>page_init()</code>函数之前分页机制还没有建立好，所以只能用字节分配的方法分配物理内存。这些阴影部分的物理内存都是<code>boot_alloc(uing32_t n)</code>函数分配的；而<code>page_init()</code>函数之后，所有的物理内存分配都是以页<strong>Page</strong>为单位，所以字节分配函数<code>boot_alloc()</code>也被禁用了。</p><h4 id="总结">总结</h4><p>我觉得整个Lab2就是在实现两种映射：<strong>物理内存到空闲链表的映射</strong>和<strong>虚拟内存到物理内存的映射</strong>。而上述的两个头文件基本讲清楚了映射需要实现的步骤和原理，应该反复阅读。初此之外还应该对C语言的<strong>强转</strong>，<strong>指针</strong>，<strong>位运算</strong>有一个很深的了解，最好先看一下TCPL。</p><h3 id="physical-page-management">Physical Page Management</h3><p>理论课很大的一部分缺失就是没有对物理内存布局进行讲解。而没有物理内存的基础，映射（Mapping）根本无从谈起。页面管理分析如下:<br>从代码角度看，Lab2接上Lab1中<code>kern/entry.S</code>跳转到<code>kern/init.c</code>中的<code>i386_init()</code>开始执行。可以发现<code>mem_init()</code>函数，整个Lab2就是完善这个内存函数的过程。而第一部分物理内存就是完成将物理内存映射到空闲链表上。<br>PartOne需要<strong>完成物理内存的管理，并实现物理内存的布局。</strong>这里的布局指的是对空闲链表的管理。所以<strong>我们首先要创建空闲链表，然后用空闲链表对这一整块物理内存进行管理，当然管理的单位是Page（4K）</strong>。<br>基本上需要实现的代码都在<code>pmap.c</code>中。我们用Taglist统筹一下该文件中所有的函数和宏定义:</p><p><img src="4.png" width="50%" height="50%" alt=""></p><h4 id="boot_alloc">boot_alloc</h4><p>彼时<code>mem_init()</code>函数中还只有一个函数————<code>i386_detect_memory()</code>。用来检测物理内存的硬件状态及其参数，其中有几个比较重要的变量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npages: 未分配</span><br><span class="line">npages_basemem: 160</span><br><span class="line">kern_pgdir: 未分配</span><br><span class="line">basemem: 640KB</span><br></pre></td></tr></table></figure><p>其中<code>basemem=640K</code>是因为在<code>inc/memlayout.h</code>中定义过一个宏:<code>#define IOPHYSMEM 0xA0000</code>。在Lab1的内存布局中有详细的分布，在这个宏定义的地址往上是 实模式下IDT和第一部分bootsector。所以将宏定义以下到<code>0x00000000</code>的内存称为base_mem。而这部分需要被映射到空闲链表中，所以按照页式单位可以映射640K/4K=160个pages。<br>接下来就是实现代码。因为代码太多不打算贴出来，主要是做Lab的思路并分享一些完善内存布局过程中画的草稿。<br>从<code>mem_init()</code>的进度来看，首先需要实现<code>boot_alloc()</code>函数，然后用该函数直接分配物理内存给<code>kern_pgdir</code>和<code>pages</code>两个数据结构。而<code>boot_alloc</code>中值得一提就是<code>extern char end[]</code>和对齐函数<code>ROUNDUP(a, n)</code>。<strong>在Lab1完成之后，我们将内核放到<code>0x10000000</code>这个位置直到<code>end</code>结束，所以<code>end</code>是链接器做链接时内核加载结束的地址。</strong>而<code>ROUNDUP(a, n)</code>的功能是向上对齐。因为我们的操作都是4KB对齐的，所以需要在<code>end</code>后面进行对齐操作。详细见Lab1的内存布局。<strong>最后函数返回的是已分配内存的虚拟首地址。</strong><br>指导书中推荐使用断言<strong>assert</strong>进行调试的方法。不过我一般使用输出调试<strong>cprintf+return</strong>。当分配好<code>kern_pgdir</code>和<code>pages</code>之后，我们使用输出调试看一下这两个数据结构的虚拟地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void boot_alloc() &#123;</span><br><span class="line">cprintf(&quot;before allocating nextfree is %x\n&quot;, nextfree);</span><br><span class="line">/*</span><br><span class="line">address allocator</span><br><span class="line">*/</span><br><span class="line">cprintf(&quot;after allocating nextfree is %x\n&quot;, nextfree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下输出结果:</p><p><img src="5.png" width="50%" height="50%" alt=""></p><p>然后就是实现<code>page_init()</code>函数。<strong>此时我们已经建立了一个和全部物理内存相对应的数组pages</strong>。这为接下来空闲链表的实现奠定了基础:<strong><code>page_init()</code>函数就是按照Hints中提示的物理内存的基本布局，找到那些空闲的物理内存并将其对应的pages数组元素链接起来形成一个链表。</strong>可能不好理解，直接上图:</p><p><img src="6.jpeg" width="50%" height="50%" alt=""></p><p>这个功能是由下面简单的几句C语言实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Part of the code:</span><br><span class="line"></span><br><span class="line"> for (i = 1; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">                pages[i].pp_ref = 0;</span><br><span class="line">                pages[i].pp_link = page_free_list;</span><br><span class="line">                page_free_list = &amp;pages[i];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><code>page_init</code>函数实现了空闲链表。至此内存的布局已经很清楚了：</p><p><img src="8.jpeg" width="50%" height="50%" alt=""></p><h4 id="page_alloc">page_alloc</h4><p><code>page_alloc</code>函数实现物理内存的页式分配————分配一页空闲的物理内存。根据上面的思路:<strong>pages数组就是全部物理内存的映射，而page_free_list是空闲物理内存的映射所以是部分pages元素链成的。</strong>所以我们实际上可以通过<code>page_free_list</code>指针来确定具体的物理地址:**(page_free_list-pages)*4K**。<br>实现很简单，当中需要注意的细节初始化函数<code>memset(void *v, int c, size_t n)</code>中需要的地址是虚拟地址。这里先参考一下<code>kern_pgdir</code>的实现和初始化。</p><p><img src="7.png" width="50%" height="50%" alt=""></p><p>所以在实现中<strong>需要将page_free_list指向的pages元素映射到具体的物理地址<code>page2pa</code>, 然后将物理地址转化为虚拟地址<code>PADDR</code></strong>并返回。</p><h4 id="细节">细节</h4><p>至此物理映射到空闲链表的过程已经实现。<code>boot_alloc</code>和<code>page_alloc</code>最终返回的都是<strong>虚拟地址</strong>。还有一些宏定义和函数比如<code>PGNUM(la)</code>，<code>memset(void *v, int c, size_t n)</code>的参数也是虚拟地址。在Lab2中一个核心问题就是区分<strong>物理地址</strong>还是<strong>虚拟地址</strong>。<br>因为mmu的缘故，访问内存的时候会进行一次线性地址到物理地址的转换。所不能直接使用物理地址。<strong>我们索性所有自定义用到地址的地方都使用虚拟地址，如果需要物理地址再使用<code>PADDR(la)</code>转化。</strong></p><h3 id="virtual-memory">Virtual Memory</h3><h4 id="question">Question</h4><p>首先区分<strong>逻辑地址</strong>，<strong>线性地址</strong>和<strong>物理地址</strong>的概念。Lab2屏蔽了逻辑地址到线性地址的转化，也就是GDT段式存储管理。直接从线性地址开始。<br>指导书中重点讲解了虚拟内存，物理内存和指针这几个概念。觉得有一些意思，就把翻译贴上了:</p><p><img src="10.png" width="50%" height="50%" alt=""></p><p>另外，在之后的Lab中会遇到很多<strong>一个物理页面同时被映射到好几块虚拟内存中</strong>的情况。JOS使用<code>struct PageInfo-&gt;pp_ref</code>来管理页目录对页表页的引用的数量。见下面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value = return_a_pointer();</span><br><span class="line">*value = 10;</span><br><span class="line">x = (mystery_t) value;</span><br></pre></td></tr></table></figure><p>根据上面的分析，指针<code>value</code>是虚拟地址。而对value进行强转并赋值的只能是虚拟地址了。</p><h4 id="pgdir_walk">pgdir_walk</h4><p>在实现下面的代码之前，默认熟悉<code>inc/mmu.h</code>中的所有内容。<br>该函数的作用很关键。<strong>给定一个虚拟地址，pgdir_walk函数返回一个指向该地址对应页表项的指针。而这个函数主要是为完成一部分虚拟地址到一部分物理地址的映射函数<code>boot_map_region</code>做准备的。所以只需要定位到页表项就可以，而不需要加上后12位偏移量。</strong>JOS的页目录（表）项<strong>PDE&amp;PTE</strong>的格式见下:</p><p><img src="11.png" width="50%" height="50%" alt=""></p><p>该函数的分析如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pte_t *</span><br><span class="line">pgdir_walk(pde_t *pgdir, const void *va, int create)</span><br><span class="line">&#123;</span><br><span class="line">        uintptr_t ptIndex = PTX(va);    //PTX取出页表项的偏移量</span><br><span class="line">        struct  PageInfo * newAlloc;     //空闲链表指针</span><br><span class="line">        if(!(pgdir[PDX(va)] &amp; PTE_P)) &#123;   //&amp;位运算是取出PTE_P这一位，看页表是否存在</span><br><span class="line">                if(create) &#123;</span><br><span class="line">                        if((newAlloc = page_alloc(1)) == NULL)</span><br><span class="line">                                return NULL;</span><br><span class="line">                        newAlloc-&gt;pp_ref++;</span><br><span class="line">// |位运算是合并位； 【20】+【12】分别为页目录项（注意不是页表项）20位的地址，后12位的标志位</span><br><span class="line">                        pgdir[PDX(va)] = page2pa(newAlloc) | PTE_P | PTE_U | PTE_W;             </span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                        return NULL;</span><br><span class="line">                &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        pte_t * pdPtr = KADDR(PTE_ADDR(pgdir[PDX(va)])); //取出页目录项的前20位</span><br><span class="line">        return pdPtr + ptIndex;   //具体的指向具体页表项的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中对页表项进行重新映射是关键的操作，便于理解还可以先取出前20位地址然后再加上标志位:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(create) &#123;</span><br><span class="line">                        if((newAlloc = page_alloc(1)) == NULL)</span><br><span class="line">                                return NULL;</span><br><span class="line">                  newAlloc-&gt;pp_ref++;</span><br><span class="line">                      pgdir[PDX(va)] = page2pa(newAlloc);   </span><br><span class="line">                      test = KADDR(pgdir[PDX(va)]);   //先取出20位</span><br><span class="line">  pgdir[PDX(va)] = page2pa(newAlloc) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">                      return test + ptIndex;//直接返回</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                        return NULL;</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>分页机制原理见下图，而<code>pgdir_walk</code>函数完成的是前两部分的，最后的<code>offset</code>并不在其中:</p><p><img src="12.png" width="50%" height="50%" alt=""></p><h4 id="boot_map_region">boot_map_region</h4><p>接上<code>pgdir_walk</code>函数返回虚拟地址相对应的页表项指针。注意该函数的参数中有一项是权限<code>perm</code>是和<code>PTE_P</code>一起的，一旦映射就存在了。因为是页表项所以是4KB对齐的（因为屏蔽掉后12位）。我们使用页表项完成虚地址到物理地址的映射:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">        for(i=0; i&lt;size/PGSIZE; i++, va+=PGSIZE, pa+=PGSIZE) &#123;  //4K 对齐</span><br><span class="line">                pte_t *pte = pgdir_walk(pgdir,(void*)va, 1);   </span><br><span class="line">                if(pte == NULL) panic(&quot;boot_map_region panic : out of memory!\n&quot;);</span><br><span class="line">                *pte = pa | perm | PTE_P;    //完成映射，并设置标志位来确定页表权限</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面几个函数实现都很简单，不再赘述。<br>至此，我们实现了内存页式管理的页表管理部分。</p><h3 id="kernel-address-space">Kernel Address Space</h3><h4 id="mapping">Mapping</h4><p>关于学习JOS对虚拟内存空间的整体布局。JOS是32位的操作系统，一共有4G的虚拟空间。<strong>以<code>ULIM</code>为分界线，界限以下为用户空间，以上为内核空间。</strong>其中从<code>ULIM</code>到<code>KERNBASE</code>部分作为内核的系统栈共4M空间。对于内存详细的布局可以从<code>inc/memlayout.h</code>中看到，这里的重点是因为内核和用户空间同时被映射到物理内存中，所以需要一种方式来避免两者之间相互读写。<strong>而且JOS和其他现代操作系统不同的是，整个OS只有一个页目录<code>kern_pgdir</code>（应该是每一个进程有一套完整的页表系统）。</strong><br>方法是权限位:</p><p><img src="13.png" width="50%" height="50%" alt=""></p><p>当一个程序试图访问一个虚拟地址的数据的时候，x86系统的保护机制运行为:</p><ul><li>先检查短权限位DPL，不过和页式分配无关</li><li>再检查页目录相应表项的访问权限，如果不过也产生异常</li><li>最后检查二级页表相应页表的访问权限，不够就产生异常</li></ul><p>x86对权限的原则是<strong>不在页目录这一环节限制太多，让最终的访问控制在二级页表这一环节上在设置。</strong>实际上Intel手册上给出了一个页目录加页表的访问控制的组合控制效果:</p><p><img src="15.png" width="50%" height="50%" alt=""></p><p>实现<code>mem_init</code>函数的最后一部分内容，实现JOS的虚拟映射:<br>首先我们将虚拟地址中<strong>[UPAGES, sizeof(pages)]</strong>部分映射到物理地址<strong>[pages, sizeof(pages)]</strong>上。<br>然后我们将虚拟地址中<strong>[KSTACKTOP-KSTKSIZE, KSTACKTOP]</strong>部分映射到<strong>[bootstack, KSTKSIZE]</strong>上。<br>最后将<code>KERNBASE</code>以上的虚拟地址映射到所有物理地址上。 这里注意一下一个细节:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void mem_init() &#123;</span><br><span class="line">...</span><br><span class="line">// Permissions: kernel R, user R</span><br><span class="line">kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在<code>mem_init</code>函数申请<code>kern_pgdir</code>之后就发生的映射，而这句代码本质上就是映射函数<code>boot_map_region</code>。目的很简单————<strong>完成<code>kern_pgdir</code>自身到<code>UVPT</code>的映射</strong>。我们不难明白，整个JOS只有一个页目录。Lab基本结束，这时候的JOS内存整体布局如下:</p><p><img src="14.png" width="50%" height="50%" alt=""></p><h4 id="question-1">Question</h4><p>第一个问题上面刚回答过了，就是映射的细节问题。<br>在映射的时候设置了<code>PTE_U</code>的用户才有读写权限。<br>我们的<code>UPAGES</code>有4MB的空间，一个<code>struct PageInfo</code>大小8B。所以能管理的物理块为**4MB/8*4KB = 2GB<strong>。<br>管理内存的开销一共有</strong>物理映射pages<strong>,</strong>页目录<strong>,</strong>页表**。如果第三个问题成立也就是说物理内存最大一共有2G的话，那pages大小一共有2G/4K*8=4M。而页目录<code>kern_pgdir</code>一共有4KB大小；相应的页表是4MB。一共有8MB+4KB。</p><h5 id="entry.s">entry.S</h5><p>这部分是在Lab1的时候遗留下来的问题，因为在系统刚启动的时候初始化过一个页目录<code>entry_pgdir</code>。关于细节可以参看<code>kern/entrypgdir.c</code>和<code>kern/entry.S</code>。这里介绍一些QEMU的新用法来进行调试（其实也在Lab2中是要求掌握的）:</p><ul><li><code>xp/Nx paddr</code> 输出从paddr物理地址开始的N个字节的值</li><li><code>info register</code> 输出当前寄存器的状态</li><li><code>info mem</code> 输出当前完成映射的虚拟地址和对应权限</li><li><code>info pg</code> 输出当前页表，页目录和页表项是分开的</li></ul><p>其实我们从Lab1的时候已经调试过，<code>movl    %eax,%cr0</code>执行结束的时候<strong>打开分页机制</strong>。但是这次可以直接看到分页的结果和映射的结果还是很爽的，结合<code>kern/entrypgdir.c</code>来看一下便很容易回答最后一个问题:</p><p><img src="16.png" width="50%" height="50%" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// The entry.S page directory maps the first 4MB of physical memory</span><br><span class="line">// starting at virtual address KERNBASE (that is, it maps virtual</span><br><span class="line">// addresses [KERNBASE, KERNBASE+4MB) to physical addresses [0, 4MB)).</span><br><span class="line">// We choose 4MB because that&apos;s how much we can map with one page</span><br><span class="line">// table and it&apos;s enough to get us through early boot.  We also map</span><br><span class="line">// virtual addresses [0, 4MB) to physical addresses [0, 4MB); this</span><br><span class="line">// region is critical for a few instructions in entry.S and then we</span><br><span class="line">// never use it again.</span><br><span class="line">//</span><br><span class="line">// Page directories (and page tables), must start on a page boundary,</span><br><span class="line">// hence the &quot;__aligned__&quot; attribute.  Also, because of restrictions</span><br><span class="line">// related to linking and static initializers, we use &quot;x + PTE_P&quot;</span><br><span class="line">// here, rather than the more standard &quot;x | PTE_P&quot;.  Everywhere else</span><br><span class="line">// you should use &quot;|&quot; to combine flags.</span><br><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line">pde_t entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">        // Map VA&apos;s [0, 4MB) to PA&apos;s [0, 4MB)</span><br><span class="line">        [0]</span><br><span class="line">                = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">        // Map VA&apos;s [KERNBASE, KERNBASE+4MB) to PA&apos;s [0, 4MB)</span><br><span class="line">        [KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">                = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不难发现其实在<code>entry_pgdir</code>中已经完成了<code>0x00000000-0x00400000</code>到<code>0xf0000000-0xf0400000</code>和到<code>0x00000000-0x00400000</code>的映射。而实现映射的方式也是直接讲地址写到页表项<code>entry_pgdir</code>中。<br>通过调试，发现两次页目录的创建过程中，映射的地址都不一样:</p><p><img src="17.png" width="50%" height="50%" alt=""></p><p>至此Lab2完成，Challenge时间关系不做了。这是<a href="https://github.com/haotianmichael/JOS" target="_blank" rel="noopener">源代码</a>.</p><p><img src="18.png" width="50%" height="50%" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;lab2&quot;&gt;Lab2&lt;/h2&gt;
&lt;h3 id=&quot;before-lab&quot;&gt;Before Lab&lt;/h3&gt;
&lt;p&gt;Lab2的主要内容:&lt;code&gt;Physical Page Management&lt;/code&gt;,&lt;code&gt;Virtual Memroy&lt;/code&gt;,&lt;code&gt;Kernel Address Space&lt;/code&gt;;&lt;strong&gt;代码实现JOS中的内存分页管理功能，有页面管理和页表管理两部分。&lt;/strong&gt;和理论相比，代码实现需要考虑的细节真是太多。实验最终的目的是通过几个检测函数:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Lab1完成时整个JOS内存布局如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;9.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;切换合并Git分支的时候可能会出现冲突，需要手动注释掉Lab1中的一些测试代码来解决，这里不再赘述。
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Shell</title>
    <link href="http://haotianmcihael.github.io/2018/11/17/Mit6-828-Fall-2018-Shell/"/>
    <id>http://haotianmcihael.github.io/2018/11/17/Mit6-828-Fall-2018-Shell/</id>
    <published>2018-11-17T07:48:07.000Z</published>
    <updated>2022-03-16T10:32:54.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hwshell">HW:Shell</h2><h3 id="abstract">Abstract</h3><p>6.828除了Lab之外还有针对小型操作系统XV-6的Readings和HomeWork。整个6.828也是围绕这两条线（Lab和HW）在走。Lab1让我适应了JOS的实验环境和调试技巧，但是Shell和System Calls才是真正属于操作系统的知识。关于XV-6的HomeWork都是建立在Readings基础之上的，本次HW<strong>需要实现一个小型的Shell</strong>，需要阅读的Readings有:</p><ul><li>XV-6.Chapter.0（重点资料）</li><li>man fork, (3)exec，open， close</li><li>TCPL</li></ul><p>学习过程中最有意思的当属斩获新技能和新工具了:)介绍一个新的vim插件神器————<a href="http://vim-taglist.sourceforge.net/manual.html#taglist-using" target="_blank" rel="noopener">Taglist</a>。</p><p><img src="27.png" width="50%" height="50%" alt=""></p><a id="more"></a><p>简单来讲，它以目录树的形式列出当前文件中的symbol:函数名，宏定义和变量。帮助我们从宏观上快速了解源码。本身支持跳转。安装manual中讲的很清楚，就不再赘述了。下面是我的配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;silent&gt; &lt;F8&gt; :TlistToggle&lt;CR&gt;&lt;CR&gt;   &quot;按f8开启Taglist</span><br><span class="line">let Tlist_Show_One_File=0                    </span><br><span class="line">let Tlist_Exit_OnlyWindow=1                  </span><br><span class="line">let Tlist_Use_Left_Window=1                 </span><br><span class="line">let Tlist_File_Fold_Auto_Close=1             </span><br><span class="line"></span><br><span class="line">     add the above Configs to your ~/.vimrc</span><br></pre></td></tr></table></figure><h3 id="操作系统调用system-calls">操作系统调用——System Calls</h3><p>操作系统的工作总结起来就是<strong>抽象</strong>和<strong>资源分配</strong>。<br>资源有内存分配，CPU调度等。而抽象指的就是系统调用。实验需要实现Shell中的命令，重定向和管道。每一个功能都是使用系统调用来实现的，所以将System Calls称为操作系统的接口一点都不过分。</p><h3 id="executing-simple-commands">Executing Simple Commands</h3><h4 id="fork">fork</h4><p><code>fork</code>系统调用创建一个子进程，对于父进程返回子进程的pid，对于子进程返回0。见下面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int pid = fork(); //创建了子进程</span><br><span class="line">if(pid == 0) &#123;   //父子进程都从这里开始执行，唯一区别就是pid不一样</span><br><span class="line">   printf(&quot;child: existing!\n&quot;);</span><br><span class="line">   exit();</span><br><span class="line">&#125;else if(pid &gt; 0) &#123;</span><br><span class="line">printf(&quot;parent: %d&quot;, pid);</span><br><span class="line">wait();  //父进程等待</span><br><span class="line">printf(&quot;child is done\n&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">fprintf(stdeer, &quot;fork error!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中<code>wait()</code>系统调用返回一个退出的子进程。</strong>上面这段代码其实就是整个Shell执行指令的原理:<strong>Shell提示符由父进程提供，然后创建一个子进程执行真正的命令，而父进程则<code>wait()</code>直到子进程返回,然后父进程等待下一条命令。</strong><br>执行效果如下:</p><p><img src="28.png" width="50%" height="50%" alt=""></p><p>回到Shell中来，我们需要修改子进程中的代码，能够正确执行简单的命令。涉及到<code>exec()</code>函数族。</p><h4 id="exec">exec</h4><p>exec提供了在一个进程中执行另一个进程的方法: 根据参数提供的文件路径和名称找到可执行文件，并执行。执行结束之后原调用进程的内容除进程号之外其他的全部被替换。<strong>通常和fork一起联合实现进程中执行程序。</strong><code>exec</code>函数族是由6个以exec开头的函数构成的，这6个函数的用法根据名称的不同会有些微的区别:</p><p><img src="29.png" width="50%" height="50%" alt=""></p><h5 id="查找可执行文件的方式">查找可执行文件的方式</h5><p>其中<code>execlp</code>，<code>execvp</code>在查找可执行文件的时候不用写文件的<strong>绝对路径</strong>，系统会自动根据环境变量“<span class="math inline">\(PATH”查找。`env`命令可以列出系统中当前的\)</span>PATH。</p><h5 id="参数传递方式">参数传递方式</h5><p>其中<code>execlp</code>,<code>execl</code>,<code>execle</code>这三个第五个字母是<code>l</code>的函数参数只能分别列出来————<code>const char *argv...</code>。而<code>execv</code>,<code>execve</code>,<code>execvp</code>这三个第五个字母是<code>v</code>的函数参数可以整体构造数组传递————<code>char *const argv[]</code>。<strong>所有的参数都应该以<code>NULL</code>结尾</strong>。</p><h5 id="环境变量">环境变量</h5><p>其中<code>execle</code>和<code>execle</code>可以在使用指定的环境变量。通过在参数末尾加上<code>char *const envp[]</code>的方法。</p><p>总结见下图:</p><p><img src="30.png" width="50%" height="50%" alt=""></p><h5 id="exec函数族使用注意事项">exec函数族使用注意事项</h5><ul><li>因为exec函数经常调用失败，所以需要加上判断语句</li><li>最后参数一定用<code>NULL</code>结尾 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int exec() &#123;</span><br><span class="line">int ret;</span><br><span class="line">if( fork() == 0 )&#123;</span><br><span class="line">if((ret = execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, NULL)) &lt; 0)  //参数以NULL结束</span><br><span class="line">fprintf(stderror, &quot;execlp error!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现命令">实现命令</h4><p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/sh.c" target="_blank" rel="noopener">Shell代码</a>分为两个部分:词法分析和命令执行；<br>实验需要修改<code>runcmd()</code>函数代码，实现具体的EXEC。需要关注函数类型，参数两个细节。根据调试知道<code>' '</code>为EXEC，而<code>execcmd</code>结构体中argv[0]中存储的是命令的名称，所以我们使用<code>execvp</code>来实现，<code>execvp</code>函数的第一个参数是可执行文件的名称，往后的参数可以用数组表示，这样可以保证该命令的可变参数得到实现。代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case &apos; &apos;:</span><br><span class="line">           ecmd = (struct execcmd*)cmd;</span><br><span class="line">           if(ecmd-&gt;argv[0] == 0)</span><br><span class="line">               _exit(0);</span><br><span class="line">           int pid, ret;</span><br><span class="line">           if ((pid = fork()) == 0) &#123;</span><br><span class="line">               if((ret = execvp(ecmd-&gt;argv[0], ecmd-&gt;argv)) &lt; 0) &#123;</span><br><span class="line">                   fprintf(stderr, &quot;Bash: command not found:%s\n&quot;, ecmd-&gt;argv[0]);</span><br><span class="line">                   exit(-1);</span><br><span class="line">               &#125;</span><br><span class="line">               exit(0);</span><br><span class="line">           &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">               wait(0);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br></pre></td></tr></table></figure><p>注意因为是多线程编程，所以调试的时候会出现很多不可思议的现象。<strong>可以先将fork()部分注释掉，进入执行函数看一下现象，然后输出调试。</strong>执行效果如下:</p><p><img src="31.png" width="50%" height="50%" alt=""></p><h3 id="io-redirection">I/O Redirection</h3><h4 id="文件描述符">文件描述符</h4><p>文件描述符是很重要的概念，它使得重定向成为可能。<code>File Descriptor</code>是一个整数，常常把其指向的对象称为文件。本实验中需要了解<code>open</code>，<code>creat</code>，<code>close</code>，<code>dup2</code>等系统调用返回值就是一个文件描述符。<strong>我们需要做的就是将Shell本身的文件描述符指向其他的文件描述符，从而实现重定向。</strong>Shell保证在任何时候都有3个打开的文件描述符————<code>0-标准输入</code>,<code>1-标准输出</code>,<code>2-错误输出</code>。<br>下面是会用到的几个系统调用:</p><ul><li><code>open(&quot;file_name&quot;, O_RDWR):</code> 打开文件，打开成功返回值最小的文件描述符————标准输入0，打开失败返回-1</li><li><code>create(&quot;file_name&quot;, 0777):</code> 创建文件，返回值同open</li><li><code>close(fd):</code> 释放一个文件描述符</li><li><code>dup2(oldfd, newfd):</code> 将oldfd复制给newfd</li></ul><p>重定向不需要考虑子进程的问题，但还是需要深入了解<code>fork</code>函数的机理，<strong>一旦fork，父进程拥有和子进程一模一样的文件描述符</strong>。而重定向需要考虑的是在子进程中将标准输入（输出）定向到其他文件即可。</p><h4 id="输入重定向">&lt; 输入重定向</h4><p>较简单，一旦文件不存在直接报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case &apos;&lt;&apos;:</span><br><span class="line">           rcmd = (struct redircmd*)cmd;</span><br><span class="line">           close(0);//关掉父进程的标准输入</span><br><span class="line">           if(open(rcmd-&gt;file, O_RDONLY) &lt; 0) &#123;</span><br><span class="line">               fprintf(stderr, &quot;Bash: No such file or directory:  %s\n&quot;, rcmd-&gt;file);  //输入不存在直接报错</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">//一旦open函数执行成功，它返回得文件描述符就是0，所以这时候该文件就变成了输入,定向成功</span><br><span class="line">               runcmd(rcmd-&gt;cmd);  //这里就是执行EXEC部分，所以fork的时候标准输入也是关闭的（和父进程一样close）</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br></pre></td></tr></table></figure><h4 id="输出重定向">&gt; 输出重定向</h4><p>如果文件不存在。创建新的文件时需要注意文件的权限。<code>creat</code>函数的参数0777权限为<code>-rwx rwx rwx</code>。关于umask的知识见<a href="https://my.oschina.net/alphajay/blog/112428" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case &apos;&gt;&apos;:</span><br><span class="line">rcmd = (struct redircmd*)cmd;</span><br><span class="line">int fd;</span><br><span class="line">if((fd = open(rcmd-&gt;file, O_RDWR)) &lt; 0) &#123;  //fd为新打开文件的文件描述符</span><br><span class="line">if((fd = creat(rcmd-&gt;file, 0777)) &lt; 0 ) &#123;</span><br><span class="line">fprintf(stderr, &quot;Bash: No such file or directory:  %s\n&quot;, rcmd-&gt;file);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dup2(fd, 1);   //将标准输出指向到新打开的文件fd上，所以输出就到了该文件上（实现了重定向）</span><br><span class="line">runcmd(rcmd-&gt;cmd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dup2(fd, 1);</span><br><span class="line">runcmd(rcmd-&gt;cmd);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><p>执行效果如下:</p><p><img src="32.png" width="50%" height="50%" alt=""></p><h3 id="implement-pipes">Implement pipes</h3><p>管道是一个小小的内和缓冲区，它以<strong>文件描述符对</strong>的形式提供给进程，从管道的一端写数据可以从管道的另一端读取。系统调用<code>pipe</code>将数组<code>int p[2]</code>初始化为管道的文件描述符。接下来做的无非就是重定向了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> case &apos;|&apos;:</span><br><span class="line">pcmd = (struct pipecmd*)cmd;</span><br><span class="line">int p[2];</span><br><span class="line">pipe(p);    //管道初始化</span><br><span class="line">if(fork() == 0) &#123;    </span><br><span class="line">dup2(p[0], 0);   //将标准输入重定向到管道的输入p[0]上</span><br><span class="line">close(p[0]);</span><br><span class="line">close(p[1]);</span><br><span class="line">runcmd(pcmd-&gt;right);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dup2(p[1], 1);  //讲标注输出重定向奥管道额输出p[1]上</span><br><span class="line">runcmd(pcmd-&gt;left);  </span><br><span class="line">close(p[0]);</span><br><span class="line">close(p[1]);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure><p>执行效果如下:</p><p><img src="33.png" width="50%" height="50%" alt=""></p><h3 id="make-grade">Make grade</h3><p>6.828对于HW的测试是直接在主机上测试的，编译Shell文件:<code>gcc Shell</code>得到<code>a.out</code>。已知该文件t.sh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; y</span><br><span class="line">cat &lt; y | sort | uniq | wc &gt; y1</span><br><span class="line">cat y1</span><br><span class="line">rm y1</span><br><span class="line">ls |  sort | uniq | wc</span><br><span class="line">rm y</span><br></pre></td></tr></table></figure><blockquote><p>在主机上，执行<code>./a.out &lt; t.sh</code>与在主机Shell上执行<code>source t.sh</code>对比结果，如下:</p></blockquote><p><img src="34.png" width="50%" height="50%" alt=""></p><blockquote><p>本次实验的源代码在<a href="https://github.com/haotianmichael/JOS/tree/master/Shell" target="_blank" rel="noopener">Github</a>上。<br>第一次接触Linux系统编程，很多零碎的知识和细节学起来很是吃力。不过在独立搞懂Shell的机制之后又觉得很爽，还是很期待之后的挑战:)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hwshell&quot;&gt;HW:Shell&lt;/h2&gt;
&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;6.828除了Lab之外还有针对小型操作系统XV-6的Readings和HomeWork。整个6.828也是围绕这两条线（Lab和HW）在走。Lab1让我适应了JOS的实验环境和调试技巧，但是Shell和System Calls才是真正属于操作系统的知识。关于XV-6的HomeWork都是建立在Readings基础之上的，本次HW&lt;strong&gt;需要实现一个小型的Shell&lt;/strong&gt;，需要阅读的Readings有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XV-6.Chapter.0（重点资料）&lt;/li&gt;
&lt;li&gt;man fork, (3)exec，open， close&lt;/li&gt;
&lt;li&gt;TCPL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;学习过程中最有意思的当属斩获新技能和新工具了:)介绍一个新的vim插件神器————&lt;a href=&quot;http://vim-taglist.sourceforge.net/manual.html#taglist-using&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Taglist&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;27.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Lab1</title>
    <link href="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/"/>
    <id>http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/</id>
    <published>2018-11-04T21:31:02.000Z</published>
    <updated>2022-03-16T10:34:57.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lab1">Lab1</h2><h3 id="before-lab">Before Lab</h3><p>Lab1一共有三部分:<code>Bootstrap</code>,<code>BootLoader</code>,<code>Kernel</code>;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分<code>monitor</code>中<strong>test_backtrace</strong>的功能。<br>如果<code>GDB</code>调试出错，可能是因为调试器没有链接到操作系统上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add </span><br><span class="line">add-auto-load-safe-path /Your Working Dir/.gdbinit</span><br><span class="line">line to your configuration file &quot;/root/.gdbinit&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="pc-bootstrap">PC Bootstrap</h3><h4 id="getting-started-with-x86-assembly">Getting Started with x86 assembly</h4><h5 id="exercise-1">Exercise 1</h5><p>JOS中使用AT&amp;T格式的汇编语言，在Lab0中介绍了相关资料。实验要求熟悉<strong>x86汇编</strong>和<strong>Inline汇编</strong>两种写法。</p><h4 id="simulating-the-x86">Simulating the x86</h4><p>Lab1的工作目录:</p><ul><li><code>/boot</code>目录包含和启动相关的文件。</li><li><code>/kern</code>目录包含内核和监视器相关的文件。</li><li><code>/lib</code>目录包含一些链接使用的库函数比如printf。</li><li><code>/inc</code>目录包含头文件，申明了需要使用的数据结构。</li><li><code>/obj</code>目录是make之后相应的反汇编代码，供调试使用。</li></ul><p>Lab1主要分析<code>/obj/kern/kern.asm</code>和<code>obj/boot/boot.asm</code>两个文件。这两个文件分别是<code>/boot</code>和<code>/kern</code>目录下的文件编译连接后的目标文件被反汇编而生成的。之所以这样做是因为反汇编之后可以看到每一条指令在内存中的绝对地址。这样调试的时候非常方便。至于<strong>实模式</strong>和<strong>保护模式</strong>下的地址转换在后续的实验中也会重点关注。</p><h4 id="the-pcs-physical-address-space">The PC's Physical Address Space</h4><p>最早的8086机器只有1Mb的寻址空间，后面的80x86系列机器为了向后兼容所以衍生出实模式和保护模式这两种概念，但是BIOS一直都存在于从<code>0x00000000</code>到<code>0x00100000</code>这1Mb的空间中。JOS的内存布局也是规定只有<code>0x00000000</code>到<code>0x10000000</code>这256MB大小的空间，但是默认地址线是32位的。<strong>这个很重要，因为后面实验对JOS进行虚拟内存分配的时候页框地址最大也只能是<code>0x10000000</code>，内核如何处理映射就是一个问题。</strong>具体布局见下图:</p><p><img src="6.png" width="50%" height="50%" alt=""></p><h4 id="the-rom-bios">The ROM BIOS</h4><h5 id="exercise-2">Exercise 2</h5><p>这里介绍一下常用的GDB调试参数:</p><ul><li><code>si</code>: 单步调试</li><li><code>info register</code>: 查看当前各寄存器的值</li><li><code>x/Nx Addr</code>: 查看内存地址Addr之后<strong>N字</strong>的内容</li><li><code>x/Ni Addr</code>: 查看内存地址Addr之后的N条反汇编指令</li><li><code>x/Ni $eip</code>: 查看CPU当前执行的下N条指令（其中$eip可以换成不同的寄存器，这里就不一一列举了）</li></ul><p>通过分析前面的JOS内存的布局，BIOS作为固件存在于<code>0xf0000</code>到<code>0xfffff</code>这64KB的空间上。<strong>注意启动为实模式，CPU的地址线寻址都是20位的。</strong>启动仿真器之后看到第一条代码停在了<code>0xffff0</code>的地址上，说明这是BIOS程序的入口。<code>0xffff0</code>到BIOS程序顶部<code>0xfffff</code>只有16字节的空间，需要更大的运行空间，因此第一条指令<code>ljmp   $0xf000,$0xe05b</code>；也就是跳转到<code>0xfe05b</code>这个地址正式开始运行BIOS的程序。<br>BIOS本身也是一个很复杂的系统，但是和OS关系不大。通过调试BIOS的代码我们知道了它的功能:</p><ul><li>建立中断向量表及相应的中断例程</li><li>初始化部分硬件及自检(POST)</li><li>激活<code>INT 19</code>中断来加载启动盘第一扇区512字节的内容到内存(Linux)</li></ul><p>这里应该说明第一扇区的内容是<code>/boot</code>目录下的内容:<code>boot.S</code>和<code>main.c</code>,这两个文件最后被编译链接成为可执行目标文件(这里需要ELF的知识)。在Linux系统中，这个可执行目标文件大小就是512字节，正好放在启动盘的第一个sector中,被称为<strong>bootsect</strong>。而BIOS的主要工作之一就是将<code>bootsect</code>加载到内存中，执行完任务之后，BIOS跳转到<code>bootsect</code>的初始位置。至此BIOS将权限交给操作系统，OS继续完成剩下的启动过程。 这里发现了一个小问题:就是在查看<code>/obj/boot</code>目录的时候，发现出现了<code>boot.out</code>和<code>boot</code>两个文件，如下:</p><p><img src="7.png" width="50%" height="50%" alt=""></p><p><code>strip</code>命令将ELF文件中的符号表信息等调试信息删掉，减少文件本身的大小。理论上讲<code>bootsect</code>最后应该被链接到启动盘<code>kernel</code>的第一个扇区上，换句话讲最后的<strong>操作系统启动盘</strong>只有一个。查看<code>/obj/boot</code>目录下生成的这个两个文件:<code>boot.out</code>的格式为<strong>可执行目标文件</strong>，<code>boot</code>是<strong>x86 boot sector</strong>的格式，这两个文件中一定有一个作为<code>bootsect</code>链接使用。见下图:</p><p><img src="8.png" width="50%" height="50%" alt=""></p><p>可是经过分析这两个文件大小都是<strong>8K</strong>,经过优化之后也要<strong>4K</strong>大小，和<code>512Bytes</code>相差太远。而且文件<code>boot</code>还不可以使用二进制工具分析。这个细节方面应该和<strong>链接</strong>关系很大，<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">《程序员的自我修养》</a>这本书是国内少有的讲链接装载的好书，有时间再拜读吧。</p><h3 id="the-boot-loader">The Boot Loader</h3><h4 id="code">Code</h4><h5 id="分析bootboot.s">分析boot/boot.S</h5><p>分析一下<code>/boot/boot.S</code>这个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">##############1.申明部分###############</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8       </span><br><span class="line">.set PROT_MODE_DSEG, 0x10       </span><br><span class="line">.set CR0_PE_ON,      0x1        </span><br><span class="line"></span><br><span class="line">#################2.16位实模式部分##########</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     </span><br><span class="line">  cli                      %禁止中断   </span><br><span class="line">  cld                        </span><br><span class="line"></span><br><span class="line">  xorw    %ax,%ax            %清零段寄存器</span><br><span class="line">  movw    %ax,%ds            </span><br><span class="line">  movw    %ax,%es            </span><br><span class="line">  movw    %ax,%ss            </span><br><span class="line">  </span><br><span class="line">###开启A20地址线##</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al          % 将64号端口的内容读到%al寄存器中   </span><br><span class="line">  testb   $0x2,%al           %检测%al的第二位是否为零（代表输入缓冲区是否为满，可以对端口继续读写）</span><br><span class="line">  jnz     seta20.1           %不为零则重复执行seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al          %将$0xd1写入%al寄存器</span><br><span class="line">  outb    %al,$0x64          %将%al寄存器的值写入64号端口</span><br><span class="line"></span><br><span class="line">seta20.2:                     %同样的方式</span><br><span class="line">  inb     $0x64,%al              </span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al              </span><br><span class="line">  outb    %al,$0x60          %两个端口读写   激活A20地址线</span><br><span class="line">###实模式————&gt;保护模式##</span><br><span class="line">  lgdt    gdtdesc    %加载GDT</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax    %取出%CR0寄存器的第零位并置1</span><br><span class="line">  movl    %eax, %cr0      %实模式向保护模式的转换</span><br><span class="line"></span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###########3.32位保护模式部分#############</span><br><span class="line"></span><br><span class="line">  .code32</span><br><span class="line">protcseg:</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax   </span><br><span class="line">  movw    %ax, %ds               </span><br><span class="line">  movw    %ax, %es               </span><br><span class="line">  movw    %ax, %fs               </span><br><span class="line">  movw    %ax, %gs               </span><br><span class="line">  movw    %ax, %ss               </span><br><span class="line"></span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spin:   %BUG Point！</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line">###########4.数据区################</span><br><span class="line">.p2align 2                       </span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)   </span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                     </span><br><span class="line">  .long   gdt</span><br></pre></td></tr></table></figure><p><strong>申明部分</strong>两个宏定义是在保护模式下的段描述符的申明，对于保护模式后面还介绍，这里权把它们看成是<code>CS</code>和<code>DS</code>段寄存器。<br><strong>实模式部分</strong>首先关掉了中断<code>cli</code>，因为接下来就要进行实模式下中断服务例程向保护模式下IDT中断描述符的交接。期间系统无法响应正常的中断服务。<code>cld</code>将标志位DF置零，DF和字符串操作相关;清零段寄存器。并打开了第21（A20）到第32根地址线，在没打开之前高于1MB的地址总是会“回滚”到0，这也是Linux检测保护模式和实模式的一个方法。<strong>接下来加载GDT，<code>movl %eax, %cr0</code>这句话是将系统控制寄存器<code>%CR0</code>的第0位（PE位）置一，意味着处理器工作方式变为保护模式。</strong>这里没有直接对<code>%CR0</code>进行操作，而是通过<code>%eax</code>来实现主要是为了不破坏寄存器的其他位，值得借鉴。最后<code>ljmp $PROT_MODE_CSEG, $protcseg</code>是跳转指令，<strong>需要注意的是现在已经是保护模式了，而在实模式下和保护模式下对于地址的转换方式已经从段寻址变成GDT寻址。</strong>这里只需要知道跳转到了<code>protcseg</code>这个地址。<br><strong>保护模式</strong>初始化了重要的段寄存器，然后跳转到<code>boot/main.c/bootmain</code>函数，开始将启动盘剩余的内核部分载入内存。<strong>注意在AT&amp;T格式的汇编语言中，操作数的字长是由操作符的最后一个字母决定的，后缀'b','w','l'分别表示字节（byte:8位），字（word:16位）和长字（long:32位）。</strong><br><strong>数据区部分</strong>都是在保护模式下建立GDT全局描述符的时候相关的宏定义。</p><h5 id="分析bootmain.c">分析boot/main.c</h5><p>分析一下<code>boot/main.c</code>这个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define SECTSIZE 512</span><br><span class="line">#define ELFHDR ((struct Elf *) 0x100000)</span><br><span class="line"></span><br><span class="line">void readsect(void*, uint32_t);</span><br><span class="line">void readseg(uint32_t, uint32_t, uint32_t);</span><br><span class="line">void bootmain(void);</span><br></pre></td></tr></table></figure><p>先看这两个宏定义，<code>SECTSIZE</code>是磁盘一个<code>sector</code>的大小，一般读写操作都要求地址对齐，这个宏定义就会派上用场。<code>ELFHDR</code>是一个指向ELF文件结构体的指针，不得不说<strong>强转</strong>是C语言最有力的工具之一，由此可知<code>0x100000</code>便是内存载入的首地址。这个地址也是BIOS程序结束的地方，可见JOS对于内存的规划分配还是很精确的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">readseg(uint32_t pa, uint32_t count, uint32_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    //pa是加载地址    count是加载文件大小    offset是在内核文件中的偏移量</span><br><span class="line">        uint32_t end_pa;</span><br><span class="line">        end_pa = pa + count;   //结束地址</span><br><span class="line">        pa &amp;= ~(SECTSIZE - 1);  //将加载地址与最小单位512对齐</span><br><span class="line">        offset = (offset / SECTSIZE) + 1;   //计算加载部分在启动盘中的哪一个sector中，因为sector从1开始算起</span><br><span class="line">        while (pa &lt; end_pa) &#123;</span><br><span class="line">                readsect((uint8_t*) pa, offset);  </span><br><span class="line">                pa += SECTSIZE;    //这句话表明 最终分配的内存有可能是大于实际需要内存的，因为总是以512为最小分配单元分配的</span><br><span class="line">                offset++;  </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>readseg</code>函数中的对齐，看下面这个sample函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">long SECSIZE = 0x200;  </span><br><span class="line">long pa = 0x30301;</span><br><span class="line">long to = 0x10387;</span><br><span class="line"></span><br><span class="line">to &amp;= ~(SECSIZE - 1);</span><br><span class="line">pa &amp;= ~(SECSIZE - 1);</span><br><span class="line"></span><br><span class="line">printf(&quot;secsize is : %lx\n&quot;, SECSIZE);</span><br><span class="line">printf(&quot;pa is : %lx\n&quot;, pa);</span><br><span class="line">printf(&quot;to is : %lx\n&quot;, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以需要对齐，因为磁盘和内存之间读写如果按照规定的最小粒度进行，CPU的访问性能会提高。具体见<a href="https://www.ibm.com/developerworks/library/pa-dalign/" target="_blank" rel="noopener">IBM.alignment</a>。上述函数的执行结果见下图:</p><p><img src="9.png" width="50%" height="50%" alt=""></p><p><code>readsect</code>函数都是一些端口操作。也没仔细研究Orz。下面主要看一下<code>bootmain</code>函数剩下的部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   for (; ph &lt; eph; ph++)</span><br><span class="line">            readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure><p>关于JOS对于ELF文件的申明见<code>/inc/elf.h</code>。一共有三个结构体，<code>Elf</code>代表文件头；<code>Proghdr</code>代表加载时候segment的信息；<code>Secthdr</code>代表运行时section的信息；<br>在Lab0中，我们分析过对一个程序加载的时候是以<code>segments</code>为最小粒度的。所以我们重点关注<code>Elf</code>和<code>Proghdr</code>这两个结构体的细节。</p><ul><li><code>e_phoff</code>: segment表在整个程序中的偏移量</li><li><code>e_phnum</code>: segment表项的个数</li><li><code>ph-&gt;p_pa</code>: 该segment在内存中的加载地址</li><li><code>ph-&gt;p_memsz</code>: 该segment的大小</li><li><code>ph-&gt;p_offset</code>: 该segment相对于表起始地址的偏移量</li></ul><p>所以<code>ph</code>就是segment段表的开始地址。而<code>eph</code>就是segment段表的项数。这个循环是把所有的segments都加载到相对应的内存地址中。<br>加载结束后，再次跳转<code>((void (*)(void)) (ELFHDR-&gt;e_entry))()</code>,通过调试反汇编代码，发现跳转的这个地址为<code>call *0x10018</code>,注意这里是一个指针，可以看到内核函数真正的入口在<code>0x0010000c</code>。所以正确的操作见下图:</p><p><img src="10.png" width="50%" height="50%" alt=""></p><h5 id="exercise-3">Exercise 3</h5><p>在上面分析的过程基本上回答了所有的问题:</p><ul><li><code>%CR0</code>标志位的改变意味着实模式切换到保护模式</li><li><code>call *0x10018</code>是最后一条BootLoader执行的指令，<code>movw $0x1234, 0x472</code>是内核第一条指令，这条指令在<code>0x0010000c</code>这个入口地址。</li><li>通过读取ELF文件中关于加载segments的信息，因为main函数最开始加载了8个sectors的内容到内存中，这部分内容就是和ELF格式和细节信息有关系。</li></ul><h4 id="loading-the-kernel">Loading the Kernel</h4><h5 id="exercise-4">Exercise 4</h5><p>重温C语言指针，实验中推荐<a href="https://book.douban.com/subject/1236999/" target="_blank" rel="noopener">TCPL</a>。分析实验中给出的部分示例代码，体会指针的魅力:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = (int *) ((char *) c + 1);</span><br><span class="line">*c = 500;</span><br><span class="line">printf(&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;,</span><br><span class="line">a[0], a[1], a[2], a[3]);</span><br></pre></td></tr></table></figure><p>这段代码将c强转成为char类型的指针之后加一，然后赋值为500；问题就出现在char类型和int类型的指针大小是不一样的。int类型为4个字节，而char类型只有1个字节;所以这样势必会导致赋值的时候改变数组中原来的布局。已知a[1]原来的值400，16进制为0x190;a[2]的值原来为301，16进制为0x12D;500的16进制为0x1F4;一个地址单元为一个字节，为见下图:</p><p><img src="11.png" width="50%" height="50%" alt=""></p><p>可以看到读写操作是按照字节为最小单元，最后导致a[1]的值变成0x1F490也就是十进制的128144；而a[2]由于被抹掉以个字节，所以变成0x100也就是256。下图是最终的运行结果:</p><p><img src="12.png" width="50%" height="50%" alt=""></p><h5 id="exercise-5">Exercise 5</h5><p>关于链接器和加载器，最经典的当然是这本<a href="https://www.iecc.com/linker/" target="_blank" rel="noopener">loader and linker</a>。这是中译本<a href="https://paper.seebug.org/papers/Archive/refs/elf/《链接器和加载器》中译本.pdf" target="_blank" rel="noopener">ll.Ch</a>。不过我做实验的时候没有想明白他们为什么要在这里引入这两个复杂的概念；题目很简单，但是不知道<code>LMA</code>和<code>VMA</code>是和虚拟内存有关系还是和链接器，加载器有关系。后来用<code>readelf -h kernel</code>发现<code>VMA</code>就是虚拟地址，所以这里他们所谓的linking address和loading address只是实验中自行定义的字面意思<strong>加载的地址</strong>和<strong>执行的地址</strong>，和链接器加载器没有关系！！另外在Lab0中已经分析过加载时候的<code>section</code>是所有<code>sections</code>组合成的一个聚合节，这里不考虑链接时候的单个<code>section</code>的概念。<strong>这样的话，就可以明白实验讲解的思路————引入使用ELF中<code>segments</code>的概念来解释加载过程，而加载过程时候已经开启了分页机制，所以这时候用<code>loading address</code>和<code>linking address</code>来解释<code>0xf0100000</code>和<code>0x00100000</code>的区别。而实际上<code>0xf0100000</code>就是映射到<code>0x00100000</code>上，相关细节在Kernel部分会继续分析。</strong> readelf和objdump的操作见下图:</p><p><img src="14.png" width="50%" height="50%" alt=""></p><p>将链接地址改掉之后，第一条报错的应该是和链接地址直接相关的指令，跳转指令<code>ljmp $PROT_MODE_CSEG, $protcseg</code>;</p><h5 id="exercise-6">Exercise 6</h5><p>前面分析过<code>#define ELFHDR ((struct Elf *) 0x100000)</code>所以我们可以知道，内核的装载地址(load address)就是<code>0x00100000</code>，而内核开始执行的地址应该是<code>e_entry</code>也就是<code>0x0010000c</code>。从BIOS到BootLoader的时候，内核还没有开始装载。所以<code>0x00100000</code>是空的。</p><p><img src="13.png" width="50%" height="50%" alt=""></p><h3 id="the-kernel">The Kernel</h3><h4 id="using-virtual-memory-to-work-around-position-dependence">Using virtual memory to work around position dependence</h4><p>Lab1中的地址映射: <code>0x00000000</code>————<code>0x00400000</code>映射到<code>0x00000000</code>————<code>0x00400000</code>；<code>0xf0000000</code>————<code>0xf0400000</code>映射到<code>0x00000000</code>————<code>0x00400000</code>;<br>在实验过程中关注了一下地址: 在执行到<code>kern/entry.S</code>文件之前，所有的内存地址都是物理地址（书中代言为线性地址，但是线性地址=物理地址所以没有太大区分）。直到<code>%CR0</code>寄存器的PG标志位被置零。这时候分页机制才被激活。<code>0x00100000</code>和<code>0xf0100000</code>都映射到<code>0x00100000</code>，所有两个地址存储的数值是一样的。而在映射还没有建好之前是不一样的。</p><h5 id="exercise-7">Exercise 7</h5><p><code>%CR0</code>寄存器PG位控制分页机制的实现。看到<code>mov %eax, %cr0</code>执行结束之后，索引地址变成了<code>0xf0100010</code>。地址映射不对，第一条错误的指令一定会是跳转指令<code>jmp *%eax</code>。具体的分页细节在Lab2中分析。实验操作见下图:</p><p><img src="15.png" width="50%" height="50%" alt=""></p><h4 id="code-1">Code</h4><h5 id="分析kernprintf.c">分析kern/printf.c</h5><p>下面分析一下<code>kern/printf.c</code>这个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void putch(int ch, int *cnt)</span><br><span class="line">&#123;</span><br><span class="line">        cputchar(ch);//显示屏输出函数console</span><br><span class="line">        *cnt++;   //每进行一次显示屏输出，参数自加</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int vcprintf(const char *fmt, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">        int cnt = 0;   //cnt将自身指针传给putch(int, int*)，在函数里进行自加</span><br><span class="line">        vprintfmt((void*)putch, &amp;cnt, fmt, ap);  //格式判断</span><br><span class="line">        return cnt;                  //返回最终输出的参数个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cprintf(const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        int cnt;</span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        cnt = vcprintf(fmt, ap);//变参传递</span><br><span class="line">        va_end(ap);</span><br><span class="line">        return cnt;  //返回参数个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cprintf</code>是主函数，这里用到了C语言的变参特性。变参在C库<code>stdarg.h</code>中定义至少要有一个固定的参数:<code>fun(const char *fmt, ...)</code>。主要有三个宏组成:</p><ul><li><code>va_list</code>: 申明可变参数指针ap，依次指向省略号表示的可变参数</li><li><code>va_start(ap, lastFix)</code>: 初始化ap，开始指向第一个可变参数</li><li><code>va_arg(ap, type)</code>: 将ap指向下一个可变参数</li><li><code>va_end(ap)</code>: 清除ap指针，结束函数</li></ul><p>可以看到变参<code>fmt</code>和变参指针<code>ap</code>被一路传到<code>vcprintf</code>———&gt;<code>vprintfmt</code>。在<code>vprintfmt</code>中使用。该文件中重点关注两个函数:</p><ul><li>在<code>lib/printfmt.c</code>中的函数: <code>vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)</code></li><li>在<code>kern/console.c</code>中的函数: <code>cputchar(int c)</code></li></ul><p>经过观察之后就可以知道: <strong><code>vprintfmt</code>函数判断字符串输出参数的类型并调用<code>cputchar</code>函数将相应的输出显示到显示屏上</strong>。<br>在函数分析之前再介绍一个vim的新技能:搜索高亮<code>:match Search /xxx/</code>,可以对现在正在关注的关键字进行高亮显示，调试的时候很有用:</p><p><img src="22.png" width="50%" height="50%" alt=""></p><h6 id="分析函数vprintfmt">分析函数vprintfmt</h6><p><code>vprintfmt</code>函数其实很简单，主体就是一个while循环:在遇到<code>%</code>之前直接输出，遇到<code>%</code>之后开始判断格式并输出。</p><h6 id="分析函数cputchar">分析函数cputchar</h6><p><strong>在<code>vprintfmt</code>函数中需要注意一个变量:<code>ch = *(unsigned char *) fmt++</code>。<code>ch</code>代表了当前ap指针指向的变参，也就是我们需要输出的内容。</strong><code>cputchar(ch)</code>中的参数正好就是这个<code>ch</code>。我们使用Ctags跟踪这个<code>ch</code>参数经过的函数:<code>putch(int ch, int *)</code>————&gt;<code>cputchar(int ch)</code>————&gt;<code>cons_putc(int ch)</code>。现在基本上可以看清所有的控制台输出操作都是定义在<code>console.c</code>文件中的。我们直接分析一下<code>cons_putc(int ch)</code>这个函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void cons_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">        serial_putc(c);</span><br><span class="line">        lpt_putc(c);</span><br><span class="line">        cga_putc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上三个子函数都涉及到的内联汇编<code>inb()</code>和<code>outb()</code>两个函数在<code>inc/x86.h</code>中有定义。其中<code>serial_putc</code>是串口输出，<code>lpt_putc</code>是并口输出，而<code>cga_putc</code>是显示屏输出，具体不细分析了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; !(inb(0x378+1) &amp; 0x80) &amp;&amp; i &lt; 12800; i++)</span><br><span class="line">       delay();    //判断数据缓冲区寄存器是否为空，为空则一直循环</span><br><span class="line">   outb(0x378+0, c);     //将C参数代表的内容写到端口中</span><br></pre></td></tr></table></figure><p>另外，在<code>cga_putc(c)</code>函数中，有一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">    for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">        crt_buf[i] = 0x0700 | &apos; &apos;;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们知道<code>cga_putc(c)</code>函数是用于显示屏输出的函数，而查看这几个宏定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static uint16_t crt_pos //光标</span><br><span class="line">#define CRT_ROWS        25   //显示屏行</span><br><span class="line">#define CRT_COLS        80    //显示屏列</span><br><span class="line">#define CRT_SIZE        (CRT_ROWS * CRT_COLS)  //显示屏面积</span><br></pre></td></tr></table></figure><p>简单来讲就是如果输出满屏之后，需要页面向上滚动一行。</p><h4 id="formatted-printing-to-the-console">Formatted Printing to the Console</h4><h5 id="exercise-8">Exercise 8</h5><p>经过上面的分析之后，知道格式化输出是在<code>kern/printfmt.c/vprintfmt()</code>这个函数中。找到相应的位置修改就行。</p><p><img src="16.png" width="50%" height="50%" alt=""></p><h5 id="questions">Questions</h5><p>这是Exercise.8后面的一些问题，当然很简单了:<br>1.cputchar(int c) 2.一句话，就是满屏时候的处理方法 3.主要是变参指针<code>ap</code>和格式化变参<code>fmt</code>的指向问题，之前分析过<br>4.将代码加到<code>kern/monitor.c</code>中，输出见下图。因为57616的十六进制就是ell。而0x0x00646c72在小端存储的机器上用char*表示就是<code>rld\0</code>。如果想要用大端存储的话，只要反过来就行0x726c6400。</p><p><img src="17.png" width="50%" height="50%" alt=""></p><p>5.根据变参的定义，如果fmt参数不够，那最终ap指针会指向一个未知内存区域。所以输出的数不一定。见下图:</p><p><img src="18.png" width="50%" height="50%" alt=""></p><p>6.关于变参的定义是在<code>inc/stdarg.h</code>中,我们看一下<code>va_arg</code>是如何一次一次取出变参的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define va_arg(ap, type) __builtin_va_arg(ap, type) //Fall 2018</span><br><span class="line"></span><br><span class="line">#define va_arg(ap, type) \</span><br><span class="line">(*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))  //Fall 2015</span><br></pre></td></tr></table></figure><p>可以看到va_arg是通过地址往后增长来取出下一个变参的。<strong>而正常编译器是从右往左的顺序将参数入栈的（因为栈是从高地址向低地址延伸的）。</strong>如果这时候栈的顺序变了，那只需要将va_arg函数中的对地址的加法改为减法就行。</p><h4 id="the-stack">The Stack</h4><h5 id="exercise-9">Exercise 9</h5><p>关于栈的定义在<code>kern/entry.S</code>中。见下图:</p><p><img src="19.png" width="50%" height="50%" alt=""></p><p>因为栈是从高地址向低地址延伸的，所以<code>mov $(bootstacktop) %esp</code>将栈顶地址赋值给<code>%esp</code>寄存器。而在数据段中对栈大小的定义也很清楚了————<code>KSTKSIZE</code>是一个宏定义，大小为8x4KB=32KB。</p><h5 id="exercise-10">Exercise 10</h5><p>需要深入了解栈调用的机制，就需要了解<strong>stack pointer</strong><code>%esp</code>和<strong>base pointer</strong><code>%ebp</code>这两个寄存器的用法。我们通过调试<code>test_backtrace()</code>函数来深入了解。(实际上只要有函数调用就会有栈，但很明显test_backtrace不是第一个调用的函数。当然你也可以从第一个函数i386_init开始，这个时候%esp也刚刚完成初始化0xf0110000,感觉会更爽一些)。<br><code>test_backtrace</code>函数的调用发生在<code>kern/init.c/i386_init()</code>中，所以我们第一个断点设置在<code>0xf01000de</code>。从反汇编代码中可以看出，开始调用<code>test_backtrace</code>之前，还有两条指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5, (%esp)</span><br><span class="line">call f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure><p>在还没有开始执行的时候，查看一下寄存器的状态<code>info registers</code>:<code>%esp</code>的值为<code>0xf010ffe0</code>，<code>%ebp</code>的值为<code>0xf010fff8</code>。<br>然后开始执行第一句，将参数5<strong>movl</strong>到栈顶，注意这里不是压栈而是直接存进去的，所以栈指针<code>%esp</code>是不会移动的。但是这时候栈顶元素应该是0x5。我们可以通过<code>info registers</code>命令和<code>x/8x $esp</code>来分别验证，效果如下:</p><p><img src="20.png" width="50%" height="50%" alt=""></p><p>在看一下第二条指令<code>call f0100040</code>。<code>call</code>指令可以分成两条指令:<code>push %eip</code>和<code>jmp 0xf0100040</code>。所以看到<code>push</code>指令是正宗的压栈指令，这时候<code>%esp</code>寄存器的值是要-4的，而且递减满堆栈的顺序是<strong>先-4，再压栈</strong>。这次栈顶元素应该是下一条指令的地址<code>0xf01000ea</code>，而且<code>%esp</code>的值还得-4。我们可以通过<code>info registers</code>和<code>x/8x $esp</code>来分别验证:</p><p><img src="21.png" width="50%" height="50%" alt=""></p><p>第三条指令就正式进入到<code>test_backtrace</code>函数内部了。分析一下函数内部的<strong>调用代码</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void test_backtrace(int x)</span><br><span class="line">&#123;</span><br><span class="line">f0100040:       55                      push   %ebp</span><br><span class="line">f0100041:       89 e5                   mov    %esp,%ebp</span><br><span class="line">f0100043:       53                      push   %ebx</span><br><span class="line">f0100044:       83 ec 14                sub    $0x14,%esp</span><br><span class="line">f0100047:       8b 5d 08                mov    0x8(%ebp),%ebx</span><br><span class="line">        cprintf(&quot;entering test_backtrace %d\n&quot;, x);</span><br><span class="line">f010004a:       89 5c 24 04             mov    %ebx,0x4(%esp)</span><br><span class="line">f010004e:       c7 04 24 20 1a 10 f0    movl   $0xf0101a20,(%esp)</span><br><span class="line">f0100055:       e8 c1 09 00 00          call   f0100a1b &lt;cprintf&gt;</span><br><span class="line">        if (x &gt; 0)</span><br><span class="line">f010005a:       85 db                   test   %ebx,%ebx    </span><br><span class="line">f010005c:       7e 0d                   jle    f010006b &lt;test_backtrace+0x2b&gt;</span><br><span class="line">                test_backtrace(x-1);</span><br><span class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</span><br><span class="line">f0100061:       89 04 24                mov    %eax,(%esp)</span><br><span class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</span><br><span class="line">f0100069:       eb 1c                   jmp    f0100087 &lt;test_backtrace+0x47&gt;</span><br><span class="line">        else</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上所有被调用的函数开头都会有这两条指令:<code>push %ebp</code>;<code>mov %esp, %ebp</code>;<br>实验指导书上也解释了<code>%ebp</code>寄存器的作用:<strong>On entry to a C function, the function's prologue code normally saves the previous function's base pointer by pushing it onto the stack, and then copies the current esp value into ebp for the duration of the function.</strong>每一个函数都有一个<code>%ebp</code>值，作为函数的栈帧，需要在每次调用新函数的时候压栈以保存上一个函数的返回地址。<br>这个时候莫名其妙的压栈了一个寄存器<code>%ebx</code>。我们将<code>%ebx</code>全局高亮显示发现，后面紧接着会有<code>mov 0x8(%ebp), %ebx</code>。那<code>0x8(%ebp)</code>存储的到底是啥？不难想到就是参数5。然后<code>%esp</code>指针接着扩展当前函数的栈空间。关注一下第二次调用<code>test_backtrace()</code>，前一条指令<code>mov %eax, (%esp)</code>和第一次调用的时候完全一样，而<code>%eax</code>中存的也是参数5-1=4;当然调用指令<code>call</code>也需要一次压栈。总结一下，如果是从<code>push %ebp</code>开始算起是函数栈的开头的话，那我们每一个函数调用会花费<code>4（push %ebp）+4(push %ebx)+20(sub $0x14,%esp)+4(call)</code>一共是32Bytes字节的空间。所以整个栈的布局见下图:</p><p><img src="23.png" width="50%" height="50%" alt=""></p><p>当然在调用过程中还调用了<code>cprintf()</code>这个函数，不过20字节用来分配栈空间也够了。</p><h5 id="exercise-11">Exercise 11</h5><p>经过上面的分析，栈的布局已经很清楚了。所以我们需要知道对于<code>read_ebp()</code>函数来说读出的是当前<code>%ebp</code>指针指向的地址，所以按照上面栈的布局:<code>(%ebp)--&gt;上一个%ebp</code>,<code>0x4（%ebp）--&gt;%eip</code>,<code>0x8(%ebp)--&gt;参数1</code>...当然这里的参数比5个少。<br>下面就是考验C语言的时刻，一定要注意格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">mon_backtrace(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        // Your code here.</span><br><span class="line">        /*</span><br><span class="line">         parameter &quot;argc&quot; indicates numbers of paras passed by the command-line;  parameter &quot;argv&quot; indicates specific paras accordingly.</span><br><span class="line">        */</span><br><span class="line">        struct Eipdebuginfo info;</span><br><span class="line">        cprintf(&quot;Stack backtrace:\n&quot;);</span><br><span class="line">        uint32_t *ebp = (uint32_t*)read_ebp();</span><br><span class="line">        while(ebp) &#123;</span><br><span class="line">                uint32_t eip = ebp[1];</span><br><span class="line">                cprintf(&quot;  ebp %x  eip %x  args &quot;, ebp, eip);</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+2));//这里提一下指针的用法，指导书中有讲解</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+3));</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+4));</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+5));</span><br><span class="line">                cprintf(&quot;%08.x\n&quot;, *(ebp+6));</span><br><span class="line"></span><br><span class="line">                ebp = (uint32_t*)*(ebp);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="exercise-12">Exercise 12</h5><p>对每一个<code>%eip</code>，尝试着给出其<strong>文件名称</strong>，<strong>函数名称</strong>和<strong>行号</strong>。这些信息都属于调的信息。实验要做的是找到这些调试信息，并按照规定格式将它们输出。这里需要了解<a href="https://sourceware.org/gdb/onlinedocs/stabs.html#Stab-Sections" target="_blank" rel="noopener">STAB</a>符号表的概念。<br>首先查看下<code>kern/kernel.ld</code>链接脚本。发现了有关<code>_STAB_*</code>的两个信息————<code>.stab</code>和<code>.stabstr</code>。其中stab是今天的重点。<code>kern/kdebug.c</code>中的宏定义说明了stab和stabstr的关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern const struct Stab __STAB_BEGIN__[];      // Beginning of stabs table</span><br><span class="line">extern const struct Stab __STAB_END__[];        // End of stabs table</span><br><span class="line">extern const char __STABSTR_BEGIN__[];          // Beginning of string table</span><br><span class="line">extern const char __STABSTR_END__[];            // End of string table</span><br></pre></td></tr></table></figure><p>再看一下<code>inc/stab.h</code>对stab定义的数据结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Entries in the STABS table are formatted as follows.</span><br><span class="line">struct Stab &#123;</span><br><span class="line">        uint32_t n_strx;        // index into string table of name    该项对应的在stabstr节内的索引偏移</span><br><span class="line">        uint8_t n_type;         // type of symbol   该项描述的符号类型   重点关注</span><br><span class="line">        uint8_t n_other;        // misc info (usually empty)   </span><br><span class="line">        uint16_t n_desc;        // description field  源文件的行号  重点关注</span><br><span class="line">        uintptr_t n_value;      // value of symbol   地址值   重点关注</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>objdump -G obj/kern/kernel</code>来查看当前ELF文件中的符号表信息。见下图:</p><p><img src="24.png" width="50%" height="50%" alt=""></p><p>仔细观察上图，发现每一列的分类就是按照stab数据结构分类的。重点关注一下<code>n_type</code>这个关键字，它表示该描述项的符号类型，上图中出现有很多<code>SO</code>，<code>FUN</code>...等符号类型。将这些列单独列出来进行对比:</p><p><img src="25.png" width="50%" height="50%" alt=""></p><p>很明显<code>SO</code>指的是文件名，<code>FUN</code>指的是函数名。<strong>注意这是objdump对应的符号表，JOS对符号表有自己定义的数据结构见<code>inc/stab.h</code></strong>。输出的顺序都是按照地址来排序的，很整齐。所以<code>stab_binsearch()</code>查找函数原理也就猜的差不多了，<strong>这些调试信息和相应地址的关系是通过符号表来连接的。当然所有的这些知识都可以通过<code>kern/kdebug.c</code>这个文件中对<code>stab</code>的注释（见过最全的注释了）学习到。所以我们最后分析一下这个文件:</strong><br>整个文件一共有两个函数<code>debuginfo_eip</code>和<code>stab_binsearch</code>。JOS建立了一个数据结构<code>Eipdebuginfo</code>用来存放调试信息，<code>debuginfo_eip</code>调用<code>stab_binsearch</code>函数完成一个实例化的<code>Eipdebuginfo</code>，所有的输出信息其实最后都存储在这个实例中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Eipdebuginfo &#123;</span><br><span class="line">        const char *eip_file;           // Source code filename for EIP</span><br><span class="line">        int eip_line;                   // Source code linenumber for EIP</span><br><span class="line"></span><br><span class="line">        const char *eip_fn_name;        // Name of function containing EIP</span><br><span class="line">                                        </span><br><span class="line">        int eip_fn_namelen;             // Length of function name</span><br><span class="line">        uintptr_t eip_fn_addr;          // Address of start of function</span><br><span class="line">        int eip_fn_narg;                // Number of function arguments</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right, int type, uintptr_t addr)</code>函数本质上就是一个二分查找。<strong><code>type</code>指的就是符号表项的符号类型，该函数每次查找的时候都需要确定查找的符号类型</strong>。我们需要完成的部分是行号，通过检查<code>inc/stab.h</code>文件，很容易知道行号的宏定义是<code>S_LINE</code>。二分查找失败的标志就是<code>LeftA &gt; rightA</code>。所以代码也很简单了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Your code here.</span><br><span class="line">       stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);   </span><br><span class="line">       if(lline &lt;= rline)&#123;</span><br><span class="line">               info-&gt;eip_line = stabs[lline].n_desc;  //确定行号</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">               return -1;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>最后将monitor的命令补充完整就更简单了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add :</span><br><span class="line">debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(&quot;\t%s:%d: %.*s+%d\n&quot;, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, info.eip_fn_addr);</span><br><span class="line">to kern/monitor.c/mon_backtrace()</span><br><span class="line"></span><br><span class="line">add :</span><br><span class="line">        &#123;&quot;backtrace&quot;, &quot;Display each stack frame called&quot;, mon_backtrace &#125;,</span><br><span class="line">to kern/monitor/commands[]</span><br></pre></td></tr></table></figure><p>运行结果见下图:</p><p><img src="26.png" width="50%" height="50%" alt=""></p><p>实验过程中有几处细节涉及到编译器的优化，因为还不是很了解编译链接的细节和原理，所以被我忽略掉了。<br>至此Lab1结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;lab1&quot;&gt;Lab1&lt;/h2&gt;
&lt;h3 id=&quot;before-lab&quot;&gt;Before Lab&lt;/h3&gt;
&lt;p&gt;Lab1一共有三部分:&lt;code&gt;Bootstrap&lt;/code&gt;,&lt;code&gt;BootLoader&lt;/code&gt;,&lt;code&gt;Kernel&lt;/code&gt;;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分&lt;code&gt;monitor&lt;/code&gt;中&lt;strong&gt;test_backtrace&lt;/strong&gt;的功能。&lt;br&gt;
如果&lt;code&gt;GDB&lt;/code&gt;调试出错，可能是因为调试器没有链接到操作系统上：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;add &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add-auto-load-safe-path /Your Working Dir/.gdbinit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;line to your configuration file &amp;quot;/root/.gdbinit&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Lab0</title>
    <link href="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/"/>
    <id>http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/</id>
    <published>2018-11-04T16:35:45.000Z</published>
    <updated>2022-03-16T10:30:51.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lab0">Lab0</h2><h3 id="abstract">Abstract</h3><p>从<code>8086汇编</code>实验之后，前后两周的时间勉强通过Lab1。<br>最大的感触是<strong>基础太差</strong>:对C语言的理解，对程序编译链接本质的理解，对<code>GDB</code>等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。 但是这次触动中却又多了一丝<code>见山不是山，见山又是山</code>的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如<code>printf</code>函数的实现就涉及C语言中变参的特性。有理由相信这种<strong>血浓于水</strong>的关系在后续的Lab中还会进一步加强，所以我也希望这会是我学习OS最完美的方法论——————<strong>Talk is cheap, show me the code.</strong>。 截止到Lab1，整个学习的过程显得很清晰————就是<strong>通过调试<code>kernel</code>的反汇编代码来理解运行原理并加以修改</strong>。Lab0是我在实验过程中掉进的坑，查阅的资料和逐渐点亮的技能树，缩短实验前的准备时间对理解OS本身还是很有帮助的。 <a id="more"></a></p><h3 id="实验环境的搭建">6.828实验环境的搭建</h3><ul><li>虚拟机环境: Ubuntu14.4 (<strong>32位</strong>)</li><li>仿真器: Qemu <code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li><li>实验代码: Lab <code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code></li></ul><p>虚拟机环境<code>32位</code>，因为<code>JOS</code>就是32位的操作系统。<br>仿真器使用MIT进行patched过的(见上链接)。原因是实验中分页机制是有意修改过的，使用<code>patched version</code>的话在后面<code>Exercise</code>中不需要手动转换地址。<br>关于实验代码，默认熟悉<code>Git</code>和<code>MakeFile</code>。每做完一个<code>Exercise</code>可以使用<code>make grade</code>进行测试。<br>在整个实验环境搭建的过程中，可能会因为虚拟机发型版本的不同而出现不同的链接库丢失，Google一下。详细的搭建过程见<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#" target="_blank" rel="noopener">Tools Guide</a></p><h3 id="关于6.828">关于6.828</h3><p>MIT的OS课程。学习共有三条主线:<code>Lectures</code>,<code>Readings</code>,<code>Labs</code>。<br>当然最重要的就是<code>Labs</code>。关于剩余的两部分，主要围绕一个叫做<code>xv6</code>的小型OS展开的。简单来讲，这是一个<strong>麻雀虽小五脏俱全</strong>的OS。有<code>Documents</code>和<code>Source Code</code>两份资料。知乎上评价很高，有人将其翻译成为中文版本上传至Github.<a href="https://github.com/ranxian/xv6-chinese" target="_blank" rel="noopener">XV6_Ch</a>，传说看懂源码之后可以超神……<br>做<code>Lab</code>的过程中，课程会提供大量的Readings来阅读，当然都是英文的。详细见<a href="https://pdos.lcs.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">Reference</a>。</p><h3 id="汇编和内联汇编">80386汇编和内联汇编</h3><h4 id="att-80386">AT&amp;T-80386</h4><p>在之前的汇编实验中，我们学习了16位的<code>Intel-8086</code>汇编。而在32位机器上需要使用32位的<code>80386</code>汇编语言。虽然对于<code>Linux</code>来说，<code>8086</code>和<code>80386</code>的机器是有很大的差别的，主要体现在实模式和保护模式上。但是就语言本身而言，更多的是递进的关系而语法差别并不大。目前还没有遇到保护模式相关的障碍。<br><code>x86</code>的汇编主要有两种格式:<code>Intel</code>和<code>AT&amp;T</code>。<code>6.828</code>使用的是<code>AT&amp;T</code>,而实际上Linux中的汇编也是后者居多。<strong>汇编语言本身主要有指令集<code>Instruction Set</code>和伪指令<code>Directives</code>两大部分内容</strong>。当然最全的文献是Intel自家的Documents，不过我觉得有些太杂和多了。下面的的资料在实验过程中帮了我很多。值得细看。</p><ul><li>MIT----<a href="https://pdos.lcs.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">pcasm-book</a>。</li><li>Wikipedia----<a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Added_with_80386" target="_blank" rel="noopener">x86 Instruction Set</a></li><li>Oracle----<a href="https://docs.oracle.com/cd/E26502_01/html/E28388/eoiyg.html" target="_blank" rel="noopener">x86 Assembler Directives</a></li></ul><h4 id="内联汇编">内联汇编</h4><p>因为操作系统本身就是和硬件打交道最频繁的系统软件，有些地方需要使用到汇编来简单粗暴的完成工作。<strong>内联汇编</strong>就是嵌入在C语言中的汇编语言，格式和原来的有很大的不同。不过IBM的那份资料可以解决一大半问题，也是难得的中文文档……</p><ul><li>MIT----<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">Brennan's Guide to Inline Assembly</a></li><li>IBM----<a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html" target="_blank" rel="noopener">汇编语言开发指南</a></li></ul><h3 id="elf文件">ELF文件</h3><p>实名Diss网上各种对ELF的讲解，故意弄混<code>section</code>和<code>segment</code>的概念。加上对二进制工具使用的不熟练，让我一度以为链接的难度系数是整个实验过程中最高的……直到我看到<code>CSAPP</code>中关于链接部分的讲解。</p><h4 id="编译驱动程序">编译驱动程序</h4><p><code>Compiler driver</code>指的是从C文件变成二进制文件的机器操作过程。我们从两个角度理解这个过程:<strong>机器运行的角度和C文件类型变化的角度</strong>。编译器和汇编器将多个<code>C</code>文件编译成相应的多个<strong>可重定位目标文件</strong>，也就是平时的<code>.o</code>文件，这种文件由不同的代码节和数据节构成，<strong>节</strong>在原文中是<code>section</code>。而链接器将多个<code>.o</code>文件链接成为一个<strong>可执行目标文件</strong>也就是平时的二进制文件。见下图:</p><p><img src="3.png" width="50%" height="50%" alt=""></p><p>熟悉一个程序的第一步是关注其输入输出。一句话总结链接器的功能:<strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</strong> 站在机器的角度，编译器和汇编器将ASCII格式的C文件编译成为字节块<strong>section</strong>的集合，而链接器做的就是将<strong>不同</strong>可重定位目标文件中的各种<code>sections</code>做归类，<strong>确定被链接块的运行时的内存位置</strong>。这是重点，目标文件纯粹是字节块的集合，而链接器本身对程序也所知甚少，她做的仅仅是对<strong>字节文件</strong>做处理，将多个文件的字节块放到了一个文件中。</p><h4 id="链接过程">链接过程</h4><p>链接器做两件事:</p><ul><li>符号解析: 输入文件的符号引用都对应到其定义上。</li><li>重定位: 编译器和汇编器生成的文件地址都是从0开始的，并没有和内存挂上关系。而链接器将这些不同的<code>section</code>定位到内存中的一个地址。也就是其加载地址。</li></ul><p>重点关注第二步重定位，本质上就是将多个可重定位文件中同类型的<code>.section</code>合并为一个大的聚合节。但是注意这时候还没有<code>segment</code>的概念,聚合节还是叫做<code>.section</code>。我查阅了<code>CSAPP</code>的英文版，全书第一次提到<code>segment</code> 是在链接器部分的最末尾，也就是讲重定位的时候。下面是原文:</p><p><img src="4.png" width="50%" height="50%" alt=""></p><p>明显看到<code>segment</code>还是内存的概念而非可执行文件中的部分。所以从头到尾链接过程都没有生成过<code>segment</code>这样一种东西，其只是多个<code>sections</code>对应于内存中的<strong>映射</strong>。全书对链接部分的讲解也很少提及<code>segment</code>，<strong>所以我们对链接的理解最小单位应该是<code>section</code>，链接过程就是对<code>section</code>进行操作;而最后重定位的时候将多个大的<code>section</code>映射到一段内存中，映射的单位才是<code>segment</code></strong>。现在看下图就很清楚了:</p><p><img src="5.png" width="50%" height="50%" alt=""></p><p>从文件类型的角度来看: 目前我们谈到的ELF文件有可重定位目标文件和可执行目标文件。可以使用二进制工具ELF文件进行分析。关于链接更本质的过程还是很复杂的，Lab1后面会有一部分和<strong>符号表</strong>相关的实验，建议先详细看看<code>CSAPP</code>和下面提供的资料。</p><ul><li>MIT----<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf" target="_blank" rel="noopener">The definitive standard for the ELF format</a></li><li>Wikipedia----<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li><li>ELF中文文档----<a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf" target="_blank" rel="noopener">ELF.Ch</a> ### 二进制分析工具 6.828中主要使用<code>objdump</code>，基本工具可以通过<code>man</code>来查看用法，这里列出几个最常见的参数。</li></ul><h4 id="objdump">Objdump</h4><p>对目标文件进行分析，在Linux平台上有三种<code>object file</code>:<code>Relocatable object File</code>,<code>Executable object File</code>,<code>Shared object File</code>，一直没搞懂为啥都叫<code>object File</code>。不过因为这三种目标文件对应于链接的不同阶段，所以对于链接过程本质的理解直接影响这里使用这个二进制分析工具。</p><ul><li><code>-f</code> Display file headers</li><li><code>-d</code> Disassembly</li><li><code>-h</code> Section headers</li><li><code>-x</code> All headers</li><li><code>-S</code> Display source code</li></ul><h4 id="nm">Nm</h4><p>列出目标文件中的符号表内容，应该和重定位关系密切。</p><h3 id="阅读源码cli工具">阅读源码CLI工具</h3><p>虽然我是<a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a>党，但是不得不承认VIM在进行文本操作的时候还是更<strong>方便:)</strong>一些。</p><h4 id="vim-ctags">VIM-Ctags</h4><p>这个就很强大了，用于在<code>tags</code>文件所在的根目录下寻找函数声明和宏定义，在阅读源码的时候基本上不知道的定义和关键字都可以使用<code>Ctags</code>来进行定位，非常实用。<br>安装成功之后，在工程目录下面执行命令<code>ctags -R *</code>对当前目录递归建立索引，会生成<code>tags</code>文件。在源码中遇到未见过的函数便将光标放在其上<code>Ctrl - }</code>即可跳转到其声明的位置。<code>Ctrl - o</code>自动返回。</p><h4 id="vim_taglist">VIM_TagList</h4><p>这个实际上没怎么用，功能是在VIM中打开目录树，便于程序员操作。可以先留下来，进一步观察。</p><h4 id="tmux">Tmux</h4><p>这又是一个神器，终端分屏功能强大，有<code>window</code>,<code>pannel</code>等概念。和<code>on-my-zsh</code>配合使用简直了。不愿意折腾的话也可以在<code>bash</code>下直接使用。我们在<code>GDB</code>调试OS的时候使用她作为分屏工具，需要在家目录下加入配置文件<code>~/.tmux.conf</code>。<br><img src="1.png" width="50%" height="50%" alt=""></p><h4 id="vimgrep">VimGrep</h4><p>用于在指定目录下进行全局搜索并在另一个窗口打开;关键字<code>sample</code>;在vim命令模式下执行命令；</p><ul><li>:<code>vim/sample/% | copen</code> 当前文件搜索</li><li><p>:<code>vim/sample/* | copen</code> 当前目录搜索</p></li><li>:<code>vim/sample/ ../** | copen</code> 从上一级目录开始递归搜索</li><li>:<code>vim/sample path1/**  path2/** | copen</code> 多路径搜索</li><li><p>: <code>cclose</code> 关闭当前搜索<br><img src="2.png" width="50%" height="50%" alt=""></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;lab0&quot;&gt;Lab0&lt;/h2&gt;
&lt;h3 id=&quot;abstract&quot;&gt;Abstract&lt;/h3&gt;
&lt;p&gt;从&lt;code&gt;8086汇编&lt;/code&gt;实验之后，前后两周的时间勉强通过Lab1。&lt;br&gt;
最大的感触是&lt;strong&gt;基础太差&lt;/strong&gt;:对C语言的理解，对程序编译链接本质的理解，对&lt;code&gt;GDB&lt;/code&gt;等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。 但是这次触动中却又多了一丝&lt;code&gt;见山不是山，见山又是山&lt;/code&gt;的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如&lt;code&gt;printf&lt;/code&gt;函数的实现就涉及C语言中变参的特性。有理由相信这种&lt;strong&gt;血浓于水&lt;/strong&gt;的关系在后续的Lab中还会进一步加强，所以我也希望这会是我学习OS最完美的方法论——————&lt;strong&gt;Talk is cheap, show me the code.&lt;/strong&gt;。 截止到Lab1，整个学习的过程显得很清晰————就是&lt;strong&gt;通过调试&lt;code&gt;kernel&lt;/code&gt;的反汇编代码来理解运行原理并加以修改&lt;/strong&gt;。Lab0是我在实验过程中掉进的坑，查阅的资料和逐渐点亮的技能树，缩短实验前的准备时间对理解OS本身还是很有帮助的。
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
