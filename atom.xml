<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HBlog</title>
  
  <subtitle>Mechanic</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haotianmcihael.github.io/"/>
  <updated>2018-10-20T07:16:25.409Z</updated>
  <id>http://haotianmcihael.github.io/</id>
  
  <author>
    <name>Tony Ma</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>8086实模式和保护模式</title>
    <link href="http://haotianmcihael.github.io/2018/10/20/8086%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://haotianmcihael.github.io/2018/10/20/8086实模式和保护模式/</id>
    <published>2018-10-20T15:13:53.000Z</published>
    <updated>2018-10-20T07:16:25.409Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
      <category term="Operating System" scheme="http://haotianmcihael.github.io/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch5</title>
    <link href="http://haotianmcihael.github.io/2018/10/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch5/"/>
    <id>http://haotianmcihael.github.io/2018/10/16/汇编语言（王爽）ch5/</id>
    <published>2018-10-15T16:32:55.000Z</published>
    <updated>2018-10-15T13:09:54.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五部分-中断II"><a href="#第五部分-中断II" class="headerlink" title="第五部分:中断II"></a>第五部分:中断II</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>CPU实现I/O功能的两个问题:从何处获得外设的输入？如何解决外设输入随时可能发生的问题？首先外设芯片内部有若干寄存器，CPU将这些寄存器当做端口来访问。外设的输入输出不直接送入CPU和内存而是通过这些寄存器。第二，CPU通过外中断控制I/O的随时性。<br><a id="more"></a></p></blockquote><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><blockquote><p>CPU可以直接读写三个地方的数据:</p><ul><li>内部寄存器</li><li>内存单元</li><li>端口<br>CPU通过端口地址来定位不同的端口，最多可以定位64KB个端口，则端口地址范围为<code>0~65535</code>。端口的读写指令<code>in</code>和<code>out</code>。只能使用<code>al</code>和<code>ax</code>来存放对端口进行读写的数据。</li></ul></blockquote><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><blockquote><p>外中断是由相关芯片发送给CPU中的。分为<strong>可屏蔽中断</strong>和<strong>不可屏蔽中断</strong>。不可屏蔽中断指那些CPU一定需要响应的中断，这种中断很少，中断类型码固定为2。大多数外中断指的是可屏蔽中断。<br>CPU要不要响应可屏蔽中断完全取决于状态寄存器的<code>IF</code>位。为1则响应，否则不响应。8086中手动设置<code>IF</code>的指令:</p><ul><li><code>sti</code>:设置为1</li><li><code>cli</code>:设置为0</li></ul></blockquote><h3 id="实验-编写9号中断例程"><a href="#实验-编写9号中断例程" class="headerlink" title="实验 编写9号中断例程"></a>实验 编写9号中断例程</h3><h4 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h4><blockquote><p>键盘中有一个芯片扫描每一个键的状态——按下还是松开。按下产生一个扫描码称为<strong>通码</strong>，松开也产生一个扫描码称为<strong>断码</strong>。<code>断码=通码+80h</code>。扫描码被送到<code>60h</code>端口中。<br><code>int 9h</code>是BIOS提供的不可屏蔽中断。一旦CPU收到该信号:</p><ul><li>读出<code>60h</code>端口的扫描码</li><li>如果是字符键的扫描码，将该扫描码和所对应的字符码送入内存中的BIOS键盘缓存区(16个字单元)。如果是控制键(Ctrl)和切换键(CapsLock)的扫描码，则将其转变为状态字节写进内存中存储状态字节的单元。</li><li>对键盘系统进行相关的控制。  </li></ul></blockquote><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><blockquote><p>在屏幕中间依次显示”a”~”z”,在显示的过程中按下Esc键后改变颜色。<br>实验有意思的地方在于:因为键盘上所有的键都会触发<code>int 9h</code>中断，<strong>需要在保证其他键无效的情况下，Esc键触发中断</strong>————就相当于出现了两个中断例程，两个中断向量。更有趣的是需要这两个中断同时有效，在一个<code>int 9h</code>中断下！<br>方法也很简单，就是使用<code>if_else</code>判断扫描码。当然汇编中没有<code>if_else</code>。    </p></blockquote><h4 id="中断向量和中断例程"><a href="#中断向量和中断例程" class="headerlink" title="中断向量和中断例程"></a>中断向量和中断例程</h4><blockquote><p>键盘无论是哪一个键当然只会触发<code>int 9h</code>中断这个不会变。不过得分别写例程:   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop ds:[0]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop ds:[2]</span><br><span class="line"></span><br><span class="line">mov word ptr es:[9*4],offset int 9</span><br><span class="line">mov es:[9*4+2],cs</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码主要就是设置了中断向量表。可以看到讲原来的<code>int 9h</code>中断例程地址保存在ds:0,ds:2地址处，换上新的例程地址<code>cs:(offset int 9)</code>。新的例程代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int9:push ax</span><br><span class="line">push bx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">in al,60h</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr ds:[0]   ;这里的实际上模拟了int 9中断例程的功能，实现子程序中的调用</span><br><span class="line"></span><br><span class="line">cmp al,1</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">;下面是Esc例程代码</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">inc byte ptr es:[160*12+40*2+1]  ;改变属性值，改变颜色</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>其中<code>cmp al,1</code>和<code>jne int9ret</code>就相当于<code>if_else</code>的功能。在主程序中有了栈，栈在中断例程中的主要作用就是保护现场，分析一下:  </p><ul><li>需要保护最开始的<code>int 9h</code>的中断向量号</li><li>因为在显示字符的主程序中，<code>ax</code>,<code>es</code>,<code>bx</code>都保存了重要的中间参数，所以需要保护<br>除此之外,栈并没有起到什么作用。这样看下来其实源程序也简单了不少。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/25.png" alt="pic25"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第五部分-中断II&quot;&gt;&lt;a href=&quot;#第五部分-中断II&quot; class=&quot;headerlink&quot; title=&quot;第五部分:中断II&quot;&gt;&lt;/a&gt;第五部分:中断II&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CPU实现I/O功能的两个问题:从何处获得外设的输入？如何解决外设输入随时可能发生的问题？首先外设芯片内部有若干寄存器，CPU将这些寄存器当做端口来访问。外设的输入输出不直接送入CPU和内存而是通过这些寄存器。第二，CPU通过外中断控制I/O的随时性。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch4</title>
    <link href="http://haotianmcihael.github.io/2018/10/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch4/"/>
    <id>http://haotianmcihael.github.io/2018/10/12/汇编语言（王爽）ch4/</id>
    <published>2018-10-11T21:11:38.000Z</published>
    <updated>2018-10-15T08:01:05.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四部分-中断I"><a href="#第四部分-中断I" class="headerlink" title="第四部分:中断I"></a>第四部分:中断I</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>在之前的实验中，我们所编写的汇编程序从编译到运行出结果都很顺利。这个过程映射到CPU层面就是<code>CS:IP</code>的跳转<strong>唯一取决于</strong>汇编程序员的代码。<code>CSAPP</code>将这个过程称为<strong>程序控制流</strong>。而<strong>中断</strong>则是将这种流程打断，建立更复杂的<strong>异常控制流</strong>。中断分为<code>内中断</code>和<code>外中断</code>两种。<br><a id="more"></a></p></blockquote><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><h4 id="中断产生"><a href="#中断产生" class="headerlink" title="中断产生"></a>中断产生</h4><blockquote><p>8086CPU使用<strong>中断类型码</strong>来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种<strong>中断信息的来源</strong>————具体指的是产生中断信息的事件，简称<strong>中断源</strong>。下面是8086中4种常见的中断源及其中断类型码:  </p><ul><li>除法错误: 0</li><li>单步执行: 1</li><li>执行<code>into</code>指令: 4</li><li>执行<code>int n</code>指令: n</li></ul></blockquote><h4 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h4><blockquote><p>CPU获得<strong>中断类型码</strong>之后，需要跳转到该<strong>中断类型码</strong>对应的<strong>中断处理程序</strong>中进行处理。如何跳转呢？使用<strong>中断向量表</strong>。而跳转通常意味着改变CPU的状态，所以需要使用栈来保存现场。所以<strong>识别</strong>，<strong>保存</strong>和<strong>跳转</strong>就是中断过程主要干的事儿————其中识别由硬件完成！<br><strong>中断向量表</strong>保存在内存<code>0000:0000</code>到<code>0000:03FF</code>的这1KB单元里。一个表项存放一个<strong>中断向量</strong>————也就是中断处理程序的地址入口。占4个字节，高地址放段地址，低地址放偏移地址。</p></blockquote><h5 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h5><blockquote><p>下图是一张8086的内存分布图:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/14.png" alt="pic14"><br>从内存0开始，所以存储<code>N号中断源对应的中断向量的偏移地址</code>的内存地址为:<code>0000:4N</code>，存储<code>N号中断源对应的中断向量的段地址</code>的内存地址为:<code>0000：4N+2</code>。看下图:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/15.png" alt="pic15">  </p></blockquote><h5 id="跳转和保存"><a href="#跳转和保存" class="headerlink" title="跳转和保存"></a>跳转和保存</h5><ul><li>获得中断类型码</li><li>标志寄存器的值入栈: <code>pushf</code></li><li>设置标志寄存器第8位TF和第9位IF的值位0: TF=0,IF=0</li><li>CS的内容入栈: <code>push CS</code></li><li>IP的内容入栈: <code>push IP</code></li><li>通过中断类型码获取入口地址: <code>(IP)=(N*4),(CS)=(N*4+2)</code></li><li>最后一步执行结束后，CPU开始执行由程序员编写的中断处理程序  </li></ul><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><blockquote><p>所谓中断处理程序就是操作系统对各种中断的反应。 由于CPU随时可能检测到中断，所以中断处理程序必须一直存储在内存某段空间中。下面的实验就是通过来实现内中断处理程序。</p></blockquote><h5 id="0号中断"><a href="#0号中断" class="headerlink" title="0号中断"></a>0号中断</h5><blockquote><p>即除法溢出错误。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000h</span><br><span class="line">mov bh,1</span><br><span class="line">div bh</span><br></pre></td></tr></table></figure><blockquote><p>该除法指令在执行的过程中会发生溢出错误，导致产生0号中断从而引发中断过程。</p></blockquote><h4 id="实验-编写0号中断的处理程序"><a href="#实验-编写0号中断的处理程序" class="headerlink" title="实验 编写0号中断的处理程序"></a>实验 编写0号中断的处理程序</h4><ul><li>中断类型码:0</li><li>中断处理程序: 选择<code>0000：0200</code>到<code>0000：02ff</code>这256个Bytes内存的区域来存放</li><li>中断向量表: 0号中断的段地址<code>0000:0002</code>偏移地址<code>0000:0000</code><h5 id="安装处理程序do0"><a href="#安装处理程序do0" class="headerlink" title="安装处理程序do0"></a>安装处理程序<code>do0</code></h5><blockquote><p>得确保中断处理程序不会变动，所以选择一块合适的内存区域将其安装进去。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,cs</span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov si,offset do0  ;设置ds:si指向被拷贝的程序地址</span><br><span class="line">   mov ax,0</span><br><span class="line">   mov es,ax  ;设置es:di指向拷贝的目的地址</span><br><span class="line">   mov di,200h</span><br><span class="line">   </span><br><span class="line">   mov cx,offset do0end-offset do0   ;设置需要拷贝的代码长度度</span><br><span class="line">   </span><br><span class="line">   cld  ;设置传输方向为正</span><br><span class="line">   rep movsb</span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">   设置中断向量表</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">   mov ax, 4c00h</span><br><span class="line">   int 21h</span><br><span class="line">   </span><br><span class="line">do0:   jmp short do0start</span><br><span class="line">   db &quot;overflow!&quot;</span><br><span class="line">   </span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,200h   ;设置ds:si指向字符串</span><br><span class="line"> </span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2 ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">mov cx,9 ;字符串的长度</span><br><span class="line">s:  mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2  </span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">   </span><br><span class="line">   do0end: nop</span><br><span class="line">   </span><br><span class="line">   code ends</span><br><span class="line">   end start</span><br></pre></td></tr></table></figure><h5 id="设置中断向量号"><a href="#设置中断向量号" class="headerlink" title="设置中断向量号"></a>设置中断向量号</h5><blockquote><p>当中断发生的时候，确保0号中断的处理程序跳转地址是上一个设置好的地址。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2], 0</span><br></pre></td></tr></table></figure><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><blockquote><p>注意，在跳转到中断处理程序之前，所有的CPU现场已经入栈保存好了，而跳转过程本身也是硬件过程，所以我们所做的仅仅只是设置好<strong>跳转的地址</strong>和<strong>该地址相应的处理代码</strong>。<br><strong>经过实验发现DOSBox的和传统的DOS还是有一些区别的，这里用一个小实验验证中断:</strong>首先我们直接在debug下面将<code>0号中断向量号改写成为0000:0200处</code>，然后在另一块内存<code>0200:0000</code>中写进了会引发0号中断的代码:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/16.png" alt="pic16"><br>然后修改好了<code>CS:IP</code>地址并开始执行:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/17.png" alt="pic17">  </p></blockquote><h6 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h6><blockquote><p><strong>单步执行,可以看到<code>CS:IP</code>的值在执行到<code>div bh</code>的时候，立马从<code>0200:0005</code>变成了<code>0000:0002</code>!,我写的中断处理<code>mov cx,ffff</code>也被执行！然后一直执行到结束退出。</strong><br>实验的整个过程实际上就是做了一个跳转，然后我们仔细对比一下跳转前后寄存器值的差距:<strong>会发现除了<code>CS:IP</code>有变化之外，<code>SS:SP</code>大小也有变化，这是<code>CPU</code>保存现场的缘故————从<code>00F7</code>到<code>00FD</code>共3个字对应<code>CS</code>，<code>IP</code>和<code>TF</code>；而且<code>状态寄存器EI也变为DI</code>,估计也和<code>TF</code>和<code>IF</code>相关;因为我们的中断处理直接退出程序所以栈中的数据没有派上用场，不过如果需要返回源程序做一些操作的时候栈就会起到恢复的作用。</strong>我还尝试过在中断产生的时候查看栈中的内容，但是每次指令刚执行就被强制退出……不知道为什么。<strong>不过这是下一个实验的内容了。</strong>另外，这里可以回过头看一下<strong>ch2</strong>中关于栈的那个猜测，基本上没有毛病。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/18.png" alt="pic18">  </p></blockquote><h5 id="1号中断"><a href="#1号中断" class="headerlink" title="1号中断"></a>1号中断</h5><blockquote><p>在CPU保存现场的时候，对状态寄存器压栈，并且将其中两个状态位设置为零:TF=0;IF=0;主要是因为当<strong>CPU</strong>每执行完一条指令<strong>的时候，就会去查看状态寄存器的TF位是否为1，如果是则引发1号中断————单步中断</strong>。整个中断的过程和其他的没有什么区别，作者提到<code>debug -t</code>的单步执行功能，实际上就是通过debug调用1号中断对CPU进行控制。这里的控制主要体现在中断处理程序上————比如<code>debug -t</code>就是设置寄存器的值显示在屏幕上。那为什么要在处理之前又将<code>TF</code>设置为零呢？注意前面的<code>每执行完一条指令</code>的意思，CPU在执行中断处理程序的时候是不能响应其他中断的，<code>TF=0</code>是防止在过程中递归的陷入。  </p></blockquote><blockquote><p>但是在有些特殊情况下中断的产生，CPU不见得马上处理。比如<code>mov ss, ax</code>和<code>MOV sp, 10</code>这两条设置堆栈的指令，在前面的实验中出现过。</p></blockquote><h3 id="int-指令"><a href="#int-指令" class="headerlink" title="int 指令"></a>int 指令</h3><h4 id="中断例程"><a href="#中断例程" class="headerlink" title="中断例程"></a>中断例程</h4><blockquote><p><code>int n</code>是一种很重要的内中断。<code>n</code>是中断类型码，该条指令功能就是可以引发中断过程。执行如下:</p><ul><li>取终端类型码n</li><li>标志寄存器入栈，IF=0,TF=0</li><li><code>push cs</code>,<code>push ip</code></li><li>(IP)=(n<em>4),(CS)=(n</em>4+2)<br><strong>注意一下这里的压栈顺序，后面的实验中会有用到。</strong><br>一般情况下，系统会将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用，通常就是使用<code>int</code>指令。将这些自己编写的中断处理程序叫做中断例程。</li></ul></blockquote><h4 id="编写loop中断例程"><a href="#编写loop中断例程" class="headerlink" title="编写loop中断例程"></a>编写<code>loop</code>中断例程</h4><blockquote><p>在屏幕中间显示80个“！”。<br>这个程序一看就知道需要使用到<code>loop</code>指令，但是该指令到底是如何实现的呢？我们知道跳转指令实际上就是改变<code>CS:IP</code>的值，而<strong>给定次数的跳转</strong>和<strong>给定目标</strong>的跳转合在一起就会比较麻烦。<br><strong>跳转指令是靠两个标号之间的相对位移而不是靠标号的地址</strong>这一点很重要。我们用<code>cx</code>存放循环次数，用<code>bx</code>存放相对位移。先看一下例程代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0b800h   </span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line"></span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:  mov byte ptr es:[di],&apos;!&apos;</span><br><span class="line">add di,2</span><br><span class="line">/*</span><br><span class="line">int 7ch例程代码:如果（cx）!=0,跳转到标号s处</span><br><span class="line">*/</span><br><span class="line">se: nop</span><br><span class="line"></span><br><span class="line">mov ax,4c00</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>至此，应该已经完全可以看懂这些汇编程序。可是核心的功能呢？如下:<br>跳转到标号s处需要知道s的段地址和偏移地址。先来分析一下在执行<code>int 7ch</code>之后发生了什么？画得不好凑活着看吧:)<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/19.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>x86中的栈是一个<strong>满堆栈</strong>。首先标志寄存器入栈，然后对se标号的CS:IP压栈。因为代码只有一个段，所以se的段地址和s的段地址一样。而<code>bx</code>中存储了<code>s-se</code>，所以对于s来说:<code>bx+se</code>就是它自己的偏移量。而se的偏移量就是栈中的<code>IP</code>。所以思路顺下来了。可以写代码了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lp: push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx      ;cx--</span><br><span class="line">jcxz lpret       ;if(cx=0) (cs:ip)=lpret</span><br><span class="line">add [bp+2],bx   ;重点</span><br><span class="line">lpret: pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中<code>add [bp+2],bx</code>就是前面刚顺下来的算法实现。将栈中的<code>IP</code>修改称为s的偏移地址。这里的重点是<code>iret</code>指令，这个指令和跳转指令经常组合在一起共同使用，相当于<code>pop ip</code>,<code>pop cs</code>,<code>popf</code>这三条指令的和。<strong>上述代码就是在栈中修改好<code>CS:IP</code>的值，然后使用<code>iret</code>出栈执行。</strong></p></blockquote><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><blockquote><p>本次实验的过程实际上就是分为两部分:<code>安装例程</code>和<code>执行例程</code>。</p></blockquote><h6 id="安装例程"><a href="#安装例程" class="headerlink" title="安装例程"></a>安装例程</h6><blockquote><p>对于<code>7ch</code>中断类型码来说，对应的中断例程地址应该在<code>0000:01f0</code>。我们<strong>首先将中断例程写进该地址，然后修改中断向量表项。</strong>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line"></span><br><span class="line">mov cx,offset do0end-offset do0   ;将中断例程写进对应的地址中</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0   ;这4行代码修改中断向量表</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">do0:    ;这是中断例程</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:pop bp</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">do0end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>我们将上述代码保存为<code>sample.asm</code>然后编译连接。然后执行<code>sample.exe</code>:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/20.png" alt="pic20"><br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/21.png" alt="pic21"><br>上图分别是地址<code>0000:0200</code>处的<strong>中断例程</strong>，和<code>0000:01f0</code>处的<strong>中断向量表</strong>。可以看到成功写入内存。</p></blockquote><h6 id="执行例程"><a href="#执行例程" class="headerlink" title="执行例程"></a>执行例程</h6><blockquote><p>执行程序就是调用<code>int 7ch</code>这个例程看是否有效。我们将执行程序保存为<code>demo.asm</code>编译连接。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12 ;确定显存的地址</span><br><span class="line"></span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:mov byte ptr es:[di],&apos;!&apos;</span><br><span class="line">add di,2</span><br><span class="line">int 7ch    ;在这里int指令充当了loop的功能</span><br><span class="line"></span><br><span class="line">se:nop</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>然后执行<code>demo.exe</code>,看现象:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/22.png" alt="pic22"></p></blockquote><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><blockquote><p>这是最简单的一个例程，不过我们可以因此得知<strong>跳转指令</strong>和<strong>栈</strong>的重要性!</p></blockquote><h4 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h4><blockquote><p>关于BIOS和DOS已经很熟悉了，从计算机加电开始，<code>CS:IP</code>会自动跳转到<code>ffff:0000</code>的地址执行程序，到底执行的是啥？有两大部分:<strong>自检程序</strong>和<strong>初始化程序</strong>。初始化程序将建立BIOS所支持的中断向量。BIOS中的中断例程主要有:  </p><ul><li>外部中断和内部中断的中断例程</li><li>用于对硬件设备进行I/O操作的中断例程</li><li>其他和硬件系统相关的中断例程  </li></ul></blockquote><blockquote><p>自检和初始化完成之后，调用<code>int 19h</code>进行操作系统的引导。而DOS也有自己的中断例程，这些中断例程是操作系统提供给程序员的资源。另外，DOS和硬件设备相关的中断例程一般都是调用了BIOS的中断例程。每一个中断例程都是由很多的子程序构成的。不管是BIOS还是DOS的中断例程都通过<code>ah</code>来传递内部子程序的编号。</p></blockquote><h5 id="BIOS中断例程"><a href="#BIOS中断例程" class="headerlink" title="BIOS中断例程"></a>BIOS中断例程</h5><blockquote><p><strong>int 10h</strong>用来设置和字符和光标。见代码:  </p></blockquote><blockquote><p>看现象:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/23.png" alt="pic23">  </p></blockquote><blockquote><p>下面是代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ah,2    ;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;行号</span><br><span class="line">mov dl,12;列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ah,9   ;在光标位置显示字符</span><br><span class="line">mov al, &apos;a&apos;  ;字符</span><br><span class="line">mov bl,11001010b   ;颜色属性</span><br><span class="line">mov bh,0    ;第0页</span><br><span class="line">mov cx,5   ;字符重复个数</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h </span><br><span class="line"></span><br><span class="line">code ends </span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="DOS中断例程"><a href="#DOS中断例程" class="headerlink" title="DOS中断例程"></a>DOS中断例程</h5><blockquote><p>DOS中断<strong>int 21h</strong>，之前一直使用<strong>4ch00</strong>参数即程序返回功能。<br>参数<strong>ah=9</strong>表示调用第21h号中断例程的9号子程序:在光标位置上显示字符串.看现象:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/24.png" alt="pic24"><br>下面是代码:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &apos;Dos is shit!&apos;,&apos;$&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:mov ah,2</span><br><span class="line">mov bh,0</span><br><span class="line">mov dl,12</span><br><span class="line">int 10h  ;BIOS 中断例程</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21h   ;DOS中断例程</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第四部分-中断I&quot;&gt;&lt;a href=&quot;#第四部分-中断I&quot; class=&quot;headerlink&quot; title=&quot;第四部分:中断I&quot;&gt;&lt;/a&gt;第四部分:中断I&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在之前的实验中，我们所编写的汇编程序从编译到运行出结果都很顺利。这个过程映射到CPU层面就是&lt;code&gt;CS:IP&lt;/code&gt;的跳转&lt;strong&gt;唯一取决于&lt;/strong&gt;汇编程序员的代码。&lt;code&gt;CSAPP&lt;/code&gt;将这个过程称为&lt;strong&gt;程序控制流&lt;/strong&gt;。而&lt;strong&gt;中断&lt;/strong&gt;则是将这种流程打断，建立更复杂的&lt;strong&gt;异常控制流&lt;/strong&gt;。中断分为&lt;code&gt;内中断&lt;/code&gt;和&lt;code&gt;外中断&lt;/code&gt;两种。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch3</title>
    <link href="http://haotianmcihael.github.io/2018/10/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch3/"/>
    <id>http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/</id>
    <published>2018-10-10T21:29:35.000Z</published>
    <updated>2018-10-13T02:06:40.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三部分-指令核心"><a href="#第三部分-指令核心" class="headerlink" title="第三部分:指令核心"></a>第三部分:指令核心</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><blockquote><p>内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，<strong>注意这里的内存指的是内存地址空间</strong>。<br>CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。<br><a id="more"></a><br>寻址的方式有很多种类 ，不过归结到底都是<code>段地址+偏移地址</code>。段地址存储在段寄存器中，而偏移地址的方式就有很多种。见下图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/%2013.png" alt="pic13">  </p></blockquote><blockquote><p>需要注意的是:</p><ul><li>上图中的<code>idata</code>表示立即数，<code>[]</code>表示偏移地址。<code>(ax)</code>表示寄存器ax的内容。</li><li><code>[]</code>中的除了立即数之外，只有<code>bx</code>,<code>si</code>,<code>di</code>和<code>bp</code>四个寄存器可以进行寻址，其他的寄存器不行。</li><li><code>[bp]</code>的段寄存器默认是<code>ss</code>。</li><li>编译器masm和调试器debug两个工具对于<code>mov ax,[idata]</code>中的<code>idata</code>处理不同，编译器会将其识别为<code>idata</code>,所以在使用编译器的时候这种形式应该写成<code>mov ax,ds:[idata]</code></li></ul></blockquote><h4 id="数据处理-总结性质"><a href="#数据处理-总结性质" class="headerlink" title="数据处理(总结性质)"></a>数据处理(总结性质)</h4><blockquote><p>计算机处理的最终还是数据，那么就有两个最基本的问题:</p><ul><li>处理的数据在什么地方？</li><li>要处理的数据有多长？</li></ul></blockquote><h5 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h5><blockquote><p>绝大部分机器指令都是进行数据处理的指令，处理大致分为三类:读取，写入，运算。在机器指令这一层来说并不关心数据的值，而关心<strong>指令执行前一秒，将要处理的数据所在的位置</strong>。指令在执行之前，所要处理的数据可以在三个地方:CPU内部，寄存器，端口。</p></blockquote><h5 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h5><blockquote><p>8086指令可以处理两种尺寸的数据:Byte和Word。所以在机器指令中需要指明是字操作和字节操作。  </p><ul><li>通过寄存器指明:<code>ax</code>，<code>al</code>等</li><li>用操作符<code>X ptr</code>指明内存单元的长度，<code>X</code>是<code>word</code>或者<code>byte</code>。比如:<code>mov byte ptr ds:[0],1</code>。</li><li>还有一些默认的操作比如栈操作默认为字操作。</li></ul></blockquote><h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4><h5 id="伪指令补充"><a href="#伪指令补充" class="headerlink" title="伪指令补充"></a>伪指令补充</h5><ul><li><code>db</code>    定义字节型数据</li><li><code>dw</code>  定义字型数据</li><li><code>dd</code>  定义双字节型数据</li><li><code>dup</code> 和前面三个伪指令结合使用，用来进行数据的重复。<code>db 3 dup(1,2,3)</code>表示定义的三个字节型数据分别为1,2,3。</li></ul><h5 id="LOOP循环指令"><a href="#LOOP循环指令" class="headerlink" title="LOOP循环指令"></a>LOOP循环指令</h5><blockquote><p>主要进行两步操作，（cx）=(cx)-1，判断cx中的值。不为零则转至标号处执行程序，如果为零则向下执行。可见<code>cx</code>中的值影响了loop指令的执行结果。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><h5 id="JMP转移指令"><a href="#JMP转移指令" class="headerlink" title="JMP转移指令"></a>JMP转移指令</h5><blockquote><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的的指令。<br>根据修改的方式，只修改IP的称为<code>段内转移</code>，修改IP和CS的称为<code>段间转移</code>。由于转移指令对IP的修改范围不同，段内转移又分为:<code>短转移（8位）</code>和<code>近转移（16位）</code>。不同的转移方式，其基本的原理确实相同的。  </p></blockquote><h6 id="1-JMP-short-offset"><a href="#1-JMP-short-offset" class="headerlink" title="1-JMP short offset"></a>1-JMP short offset</h6><blockquote><p>转移指令值得注意的点就是offset指的不是确定的地址，而是从标号到指令之间的位移。<br><code>(IP)=(IP)+8位位移</code>，段内短转移的位移范围位8位有符号数，用补码表示。<code>offset处的地址-JMP指令后的第一个字节的地址</code>。 </p></blockquote><h6 id="1-JMP-near-ptr-offset"><a href="#1-JMP-near-ptr-offset" class="headerlink" title="1-JMP near ptr offset"></a>1-JMP near ptr offset</h6><blockquote><p><code>(IP)=(IP)+16位位移</code> ,段内近转移的位移范围是16位有符号数，用补码表示。原理和前者一样。</p></blockquote><h6 id="2-JMP-far-ptr-offset"><a href="#2-JMP-far-ptr-offset" class="headerlink" title="2-JMP far ptr offset"></a>2-JMP far ptr offset</h6><blockquote><p>前面的几种类型地址都是通过offset和位移，而接下来的几种是在寄存器和内存中的给定IP或者CS。<strong>内存地址单元可以用任意的寻址方式得到。</strong><br><code>（CS）=标号所在段的段地址</code>，<code>（IP）=标号所在段中的偏移地址</code> 。段间转移，会发现其跳转地址实际上是在指令中的offset的地址。和前两个还是有区别的。</p></blockquote><h6 id="2-JMP-16位reg"><a href="#2-JMP-16位reg" class="headerlink" title="2-JMP 16位reg"></a>2-JMP 16位reg</h6><blockquote><p>最基础的跳转指令，只是修改IP=16位的寄存器中内容。 </p></blockquote><h6 id="2-JMP-word-ptr-内存单元地址"><a href="#2-JMP-word-ptr-内存单元地址" class="headerlink" title="2-JMP word ptr 内存单元地址"></a>2-JMP word ptr 内存单元地址</h6><blockquote><p>比如:<code>jmp word ptr ds:[0]</code>中<code>ptr</code>后面的就是一个地址，<code>jmp word ds:[0],0</code>后面跟两个地址。注意<strong>（CS）=(内存地址单元+2)，（IP）=（内存地址单元）</strong>。</p></blockquote><h6 id="2-jcxz"><a href="#2-jcxz" class="headerlink" title="2-jcxz"></a>2-jcxz</h6><blockquote><p>该指令为有条件转移指令，<strong>所有的有条件转移指令都是短转移</strong>。方式为:<br><code>if((cx)==0)jmp short offset</code><br>另外，所有的<code>loop</code>循环指令都是短转移。</p></blockquote><h5 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h5><h6 id="ret-近转移"><a href="#ret-近转移" class="headerlink" title="ret(近转移)"></a>ret(近转移)</h6><blockquote><p>书中说<strong>ret指令用栈中的数据修改IP中的内容</strong>。之前对栈有一个分类，这里的栈是<strong>满递减堆栈</strong>。所以由此可知堆栈指针<code>SP</code>一直指向最后一个压栈的数据。<code>ret</code>指令实际上把堆栈中的最后一个数据作为自己跳转的偏移地址。方式如下:<br><code>(IP)=((ss)*16+(sp))</code>,<code>(sp)=(sp)+2</code><br>从上面也可以看出来这两条指令等同于:<code>pop IP</code></p></blockquote><h6 id="retf-远转移"><a href="#retf-远转移" class="headerlink" title="retf(远转移)"></a>retf(远转移)</h6><blockquote><p>书中说<strong>retf指令用栈中的数据修改IP和CS中的内容</strong>。类似:<br><code>(IP)=((ss)*16+(sp))</code>,<code>(sp)=(sp)+2</code><br><code>（CS）=（（ss）*16+(sp)）</code>,<code>(sp)=(sp)+2</code><br>这四条指令等同于:<code>pop IP</code>,<code>pop CS</code></p></blockquote><h6 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h6><blockquote><p>call指令不能实现短转移，但是其转移的原理和jmp指令相同。如下：<br><code>(sp)=(sp)-2</code>,<code>((ss)*16+(sp))=(IP)</code>,<code>(IP)=(IP)+16位位移</code>这几条指令相当于:<br><code>push IP</code>和<code>jmp near ptr offset</code></p></blockquote><h6 id="call和ret指令-子程序"><a href="#call和ret指令-子程序" class="headerlink" title="call和ret指令(子程序)"></a>call和ret指令(子程序)</h6><blockquote><p>先看一段代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,1</span><br><span class="line">   mov cx,3</span><br><span class="line">   call s</span><br><span class="line">   mov bx,ax</span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">s: add ax,ax</span><br><span class="line">   loop s</span><br><span class="line">   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>程序执行到<code>call s</code>的时候，IP指向了后面的一条指令，然后CPU执行<code>call s</code>指令————<code>将当前的IP（mov bx,ax的地址）压栈，然后修改为s地址</code>。然后子程序开始执行，执行结束之后执行<code>ret</code>指令————<code>从栈中弹出一个值，将CS:IP的值指向mov bx,ax</code>。然后返回为原来的地址。这两条指令为子程序的调用提供了可能。</p></blockquote><h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><blockquote><p>寄存器是汇编程序员解决问题的最有利的手段，不仅仅在于可以存储数据，还具有辅助指令执行的功能。标志寄存器就是如此，<strong>用来存储CPU执行指令的某些执行结果。</strong>存储的信息称为“程序状态字PSW”。状态寄存器的每一位都有具体的含义。下面分别介绍:  </p></blockquote><h5 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h5><blockquote><p>零标志位，相关指令执行结束如果结果为0，zf=1；如果不为0，zf=0.</p></blockquote><h5 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h5><blockquote><p>奇偶标志位，相关指令执行结束如果结果的所有bit位中1的个数为偶数，pf=1,否则pf=0.</p></blockquote><h5 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h5><blockquote><p>符号标志位，相关指令执行结束如果结果为负，sf=1；否则sf=0。<strong>该标志是CPU对有符号数计算结果的一种记录。</strong></p></blockquote><h5 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h5><blockquote><p>进位标志位，在进行<strong>无符号</strong>数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p></blockquote><h5 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h5><blockquote><p>溢出标志位，在进行<strong>有符号</strong>数运算的时候，记录了是否发生溢出。</p></blockquote><h5 id="标志寄存器在Debug中的使用"><a href="#标志寄存器在Debug中的使用" class="headerlink" title="标志寄存器在Debug中的使用"></a>标志寄存器在Debug中的使用</h5><blockquote><p>标志寄存器是按照有意义的各个标志位单独表示的。如下。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/7.png" alt="pic7"><br>下图是已知的标志位的表示:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/13.png" alt="pic13"></p></blockquote><h4 id="其他指令（总结性质）"><a href="#其他指令（总结性质）" class="headerlink" title="其他指令（总结性质）"></a>其他指令（总结性质）</h4><blockquote><p>还有很多的指令比如<code>MOV</code>,<code>CMP</code>，<code>abc</code>等。但这里并不打算详细讲解每一条指令，就像书中所说:<strong>汇编语言只是载体，目的在于理解机器运行的原理和方式。</strong><br>至此，我们已经学习了<code>寄存器</code>，<code>内存</code>,<code>汇编指令</code>，并且掌握了一个<strong>正常的程序控制流</strong>在机器层面的运行过程。接下来的内容，就属于操作系统的层面，引入<strong>异常控制流</strong>，也就是在正常的执行过程中有外界干扰的情况，这是理解整个OS的重点，也是我写这几篇技术博客的主要学习目的。(<code>mit6.828</code>中的汇编大同小异，只是指令集换成了AT&amp;T的格式)。</p></blockquote><h3 id="实验7-寻址方式在结构化数据访问中的应用"><a href="#实验7-寻址方式在结构化数据访问中的应用" class="headerlink" title="实验7 寻址方式在结构化数据访问中的应用"></a>实验7 寻址方式在结构化数据访问中的应用</h3><h3 id="实验9-根据材料编程"><a href="#实验9-根据材料编程" class="headerlink" title="实验9 根据材料编程"></a>实验9 根据材料编程</h3><h3 id="实验10-编写子程序"><a href="#实验10-编写子程序" class="headerlink" title="实验10 编写子程序"></a>实验10 编写子程序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三部分-指令核心&quot;&gt;&lt;a href=&quot;#第三部分-指令核心&quot; class=&quot;headerlink&quot; title=&quot;第三部分:指令核心&quot;&gt;&lt;/a&gt;第三部分:指令核心&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;h4 id=&quot;内存寻址&quot;&gt;&lt;a href=&quot;#内存寻址&quot; class=&quot;headerlink&quot; title=&quot;内存寻址&quot;&gt;&lt;/a&gt;内存寻址&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，&lt;strong&gt;注意这里的内存指的是内存地址空间&lt;/strong&gt;。&lt;br&gt;CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch2</title>
    <link href="http://haotianmcihael.github.io/2018/10/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch2/"/>
    <id>http://haotianmcihael.github.io/2018/10/04/汇编语言（王爽）ch2/</id>
    <published>2018-10-03T20:26:50.000Z</published>
    <updated>2018-10-15T07:59:54.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二部分-汇编结构"><a href="#第二部分-汇编结构" class="headerlink" title="第二部分:汇编结构"></a>第二部分:汇编结构</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><h4 id="汇编语言的结构"><a href="#汇编语言的结构" class="headerlink" title="汇编语言的结构"></a>汇编语言的结构</h4><h5 id="寄存器和内存之间"><a href="#寄存器和内存之间" class="headerlink" title="寄存器和内存之间"></a>寄存器和内存之间</h5><blockquote><p>汇编语言是由不同的段构成的，这些段的功能各异不过主要分为<code>指令</code>和<code>数据</code>两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。<br><a id="more"></a><br><strong>字节存储和字存储</strong>就是两种解决办法，在8086中寄存器是16位的(16位为一字)，而存储器的最小存储单元是8位也就是一个字节，所以如果在一些读写中需要用到字存储而不是字节存储的话，就需要两块连续的内存单元才能完成数据的传输，而且是<strong>高地址存放字的高位字节，低地址存放字的低位字节</strong>。<br><strong>要读写一块内存单元的时候，必须先要给出这个内存单元的地址。</strong>在实验1中我们知道了CPU使用<code>段地址+偏移地址</code>的方式来进行寻址。而实现这些功能的就是一些具有特殊功能的寄存器。这里提到的是最简单的也最常使用的两种类型:  </p><ul><li><code>CS</code>+<code>IP</code>————在任意时刻CPU将CS:IP指向的内容当做指令执行。  </li><li><code>DS</code>+[idata]————<code>DS</code>通常用来存放需要访问的数据的段地址。<br><strong>这里主要介绍汇编语言的结构，对应到寄存器和内存寻址的方式后面会讲。</strong></li></ul></blockquote><h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5><blockquote><p>将一段内存当做数据段，是我们在编程的时候的一种安排，可以在具体操作的时候，<strong>用ds存放数据的段地址，</strong>再根据相关指令访问数据段中的具体单元。</p></blockquote><h5 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h5><blockquote><p>从硬件角度讲，CPU只认被CS:IP指向的内存单元中的内容为指令。要让CPU执行我们放在代码段的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。</p></blockquote><h5 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h5><blockquote><p>   <strong>栈是一种先进后出的数据结构</strong>，这是最基本的栈的概念。这里讲到的栈指的是内存区域。从操作系统的角度讲一个线程需要分配一个栈(stack)。相对应的一个进程需要分配一个堆(heap)。栈的大小在分配的时候就已经确定好了，其作用主要是存放一些局部和确定的变量和数据。<br>   关于栈也有两个寄存器:<code>SS:SP</code>。换句话讲CPU如何知道一段内存区域是不是栈？栈顶的段地址放在<code>SS</code>中，而偏移地址放在<code>SP</code>中。<strong>任意时刻，SS:SP指向栈顶元素</strong>。这是规定。<br>   另外，上微机原理课的时候，老师讲到栈的分类:  </p><ul><li>向高地址生长的称为递增堆栈。</li><li>向地地址生长的称为递减堆栈。<br> 地址延伸主要的影响就是内存中的大端寻址和小端寻址。<br>  <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/4.png" alt="pic4">  </li></ul></blockquote><ul><li>堆栈指针指向最后压入堆栈的有效数据项，叫做满堆栈。</li><li>堆栈指针指向下一个待压入数据的空位置，叫做空堆栈。<br>  <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/5.png" alt="pic5"></li></ul><h5 id="栈指令"><a href="#栈指令" class="headerlink" title="栈指令"></a>栈指令</h5><blockquote><p>   在i386的指令集中，栈操作都是以字为单位的。</p></blockquote><h6 id="push执行过程"><a href="#push执行过程" class="headerlink" title="push执行过程"></a>push执行过程</h6><pre><code>1. SP=SP-2;2. 向`SP:SS`指向的内存字单元中送入数据;</code></pre><h6 id="pop执行过程"><a href="#pop执行过程" class="headerlink" title="pop执行过程"></a>pop执行过程</h6><pre><code>1. 从`SP:SS`指向的内存字单元中读取数据;2. SP=SP+2;</code></pre><h5 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h5><blockquote><p>   之前讨论过关于<strong>段</strong>这个概念。我认为，还是因为在编程的时候可以通过一个系统化的结构来统一汇编语言的实现逻辑。使得这些指令看上去便于管理和协调合作。至于其物理实现，其实就是CPU的寻址方式决定的。书本中有一段话特别经典，我摘抄如下:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">比如我们将10000H~1001F安排为代码段，并在里面存储如下代码:  </span><br><span class="line"></span><br><span class="line">MOV ax,1000H  </span><br><span class="line">MOV ss,ax</span><br><span class="line">MOV sp,0020H  //初始化栈顶</span><br><span class="line">MOV ax,cs</span><br><span class="line">MOV ds,ax  //设置数据段段地址</span><br><span class="line">MOV ax,[0]</span><br><span class="line">add ax,[2]</span><br><span class="line">add bx,[4]</span><br><span class="line">add bx,[6]</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax</span><br><span class="line">pop bx  </span><br><span class="line"></span><br><span class="line">设置CS=1000，IP=0.这段代码就会被执行，但是可以看到在这段代码中，我们又将  </span><br><span class="line">10000H~1001FH安排为栈段和数据段。  </span><br><span class="line">可见不管我们如何安排，CPU将内存中的某段内存当做代码，是因CS:IP指向了那里。  </span><br><span class="line">CPU将某段内存当做栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排，  </span><br><span class="line">以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们  </span><br><span class="line">的安排运行的时候做到游刃有余。  </span><br><span class="line">一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。  </span><br><span class="line">关键是在于CPU中寄存器的设置，机CS，IP，SS，SP，DS的指向。</span><br></pre></td></tr></table></figure><h5 id="多个段的统一"><a href="#多个段的统一" class="headerlink" title="多个段的统一"></a>多个段的统一</h5><blockquote><p>以前写的汇编都是单个段，并且主要是代码段。如果内存中的一段汇编代码需要包含多个数据段，代码段，栈段。该如何设计才能保证程序正常运行呢？<br><strong>我们应该有一个概念，就是所谓和CPU对应的程序一定是<code>CS:IP</code>指向的内存地址。</strong>所以实际上这个问题是在问保证<code>CS:IP</code>正确指向程序的前提下，如何让数据段，栈段合理的加进来？<br>这里有个<code>伪指令</code>的概念，伪指令主要是为汇编器提供一些编译的前提信息比如从哪里开始执行代码，其他的段的起始地址在哪里。所以问题也就解决了。</p><ul><li>如何保证<code>CS:IP</code>指向代码段:    <code>end</code>和<code>end start</code></li><li>如何定义一个段: <code>code segment</code>和<code>code ends</code></li><li>如何将段寄存器和段相对应: <code>assume cs:code</code></li></ul></blockquote><h4 id="汇编语言的编译、连接过程及其工具的使用"><a href="#汇编语言的编译、连接过程及其工具的使用" class="headerlink" title="汇编语言的编译、连接过程及其工具的使用"></a>汇编语言的编译、连接过程及其工具的使用</h4><blockquote><p>   这部分详细见书上。  </p></blockquote><h5 id="源程序组成"><a href="#源程序组成" class="headerlink" title="源程序组成"></a>源程序组成</h5><blockquote><p>   一个汇编程序的源程序由<code>汇编指令</code>和<code>伪指令</code>构成。汇编指令指的是编译成为机器指令最终为CPU所执行的代码。伪指令没有相对应的机器指令，主要是由编译器来执行的指令。</p></blockquote><h5 id="编译、链接、执行"><a href="#编译、链接、执行" class="headerlink" title="编译、链接、执行"></a>编译、链接、执行</h5><blockquote><p>源程序经过编译成为可重定位文件，然后经过链接成为可执行文件。可执行文件是可以直接在操作系统中执行的。上述两种文件都属于ELF格式的文件，ELF是Linux下面的一种文件格式，具体的细节在后面的操作系统中会谈到，这里只是了解。<br>    <code>编程</code>（edit）————&gt;<code>1.asm</code>————&gt;<code>编译</code>(masm)————&gt;<code>1.obj</code>————&gt;<code>链接</code>(link)————&gt;<code>1.exe</code>————&gt;<code>加载</code>(shell)————&gt;<code>内存中的程序</code>————&gt;<code>运行</code>(CPU)</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/6.png" alt="pic6"></p><h3 id="工具进阶"><a href="#工具进阶" class="headerlink" title="工具进阶"></a>工具进阶</h3><h4 id="debug-d"><a href="#debug-d" class="headerlink" title="debug -d"></a>debug -d</h4><blockquote><p>第一个实验中使用的debug工具，通过各种参数来对寄存器和内存进行读写。比如<code>d 段地址:偏移地址</code>指令会列出指定内存单元中的内容。但是debug也是一个程序，而能定位内存地址的方式在8086中只有段寄存器可以做到,实际上debug就是通过将地址写入段寄存器中的方式来进行内存寻址。这个原理适用于所有的参数。<br>而使用的这个段寄存器正是<code>DS</code>寄存器。<br>根据这个原理，就可以通过修改寄存器来进阶使用这些命令，比如:<code>-r ds</code>,<code>:1000</code>,<code>-d ds:0</code>这段代码就表示查看从1000：0开始的内存空间中的内容。这里主要是认识到段寄存器DS的寻址功能，为之后的寻址方式打基础。  </p></blockquote><h4 id="debug-p"><a href="#debug-p" class="headerlink" title="debug -p"></a>debug -p</h4><blockquote><p>在整个实验中，debug工具是经常要使用的。debug有两种用法，一种就是使用<code>a</code>参数直接写入程序然后调试。还有一种就是直接调试<code>exe</code>文件。<br>第一种之前一直在用，第二种方式加载的过程有一些不一样，ds段寄存器中存放着该程序的段地址，因为偏移为零所以DS:0就是所加载程序的首地址。而加载进来的程序前256字节存放的是一段通信程序，所以真正的代码是在<code>(DS+10H:0):0</code>开始的。<br>每一段汇编指令都需要以<code>mov ax,4c00H</code>，<code>int 21H</code>结尾。在调试到<code>int 21H</code>的时候需要使用<code>P</code>命令执行。出现<code>Program terminated normally</code>程序正常退出。</p></blockquote><h3 id="实验2-用机器指令和汇编指令编程"><a href="#实验2-用机器指令和汇编指令编程" class="headerlink" title="实验2 用机器指令和汇编指令编程"></a>实验2 用机器指令和汇编指令编程</h3><blockquote><p>这个实验很有意思，一共有两部分:</p></blockquote><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><blockquote><p>使用<code>a</code>将下面的汇编指令写入内存，然后使用<code>T</code>命令调试。如下: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,10</span><br><span class="line">mov ax,3123</span><br><span class="line">push ax</span><br><span class="line">mov ax,3366</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure><blockquote><p>会发现在单步调试的时候，在<code>mov ss,ax</code>之后的下一条指令竟然不是<code>mov sp,10</code>。但是查看寄存器的时候发现实际上这条执行已经被执行结束了。这是第一个现象。</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/7.png" alt="pic7"></p><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><blockquote><p>对上面的代码继续调试，如下：<br>会发现最开始对栈初始化之后，到执行到<code>mov ss,ax</code>指令的时候，查看原来的栈段内容竟然不再是零，且这些数字还都是和段寄存器相关的。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/8.png" alt="pic8"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>下图是接下来的每一步后栈段中的内存变化。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/9.png" alt="pic9"><br>可以看到的现象是:开始的时候栈中是没有数据的，栈桢SP指向<code>2000:0010</code>的位置。<br>在<code>mov ss,ax</code>和<code>mov sp,10</code>这两步执行结束之后，发现栈中已经有数据了，这里称为初始化。初始化的一共有6字节的数据:4个字节为<code>CS:IP</code>，还有两字节在栈底确定为<code>01A3H</code>。<br>之后的每一条栈操作的指令执行结束之后栈中的<code>CS:IP</code>值也会跟着变化，这说明每一次指令都有可能产生一次中断。<br>但是在栈底的<code>01A3H</code>一直没有变化估计应该是中断相关。在正式压栈操作的过程中发现最开始初始化过的那些数据并没有被压到栈底，<strong>这就意味着堆栈指针SP应该还在栈底，然后真正有数据项压栈的时候才会SP-=2操作。</strong></p></blockquote><h5 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h5><blockquote><p>就上面的三个现象，我在想仅仅是初始化的过程就已经占据了一大半栈空间，那如果将栈大小调整成为8字节的。那会出现什么情况？<br>   我将<code>mov sp,10</code>改成<code>mov sp,08</code>；然后准备了8字节数据，所以栈会被压满。这时候我想看看现象。<br>这是一张初始化的图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/10.png" alt="pic10"></p></blockquote><blockquote><p>这是末尾压栈满了的图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/11.png" alt="pic11"><br>因为书上关于中断的详细讲解在第四部分，所以这里只是一个猜测。<strong>现象中随着栈不断被压满，之前初始化的那些数据都被挤出去了，具体去哪了不知道。那6个字节的数据到底有什么用也不知道。</strong>  </p></blockquote><h5 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h5><blockquote><p>不过可以知道的是初始化栈帧的时候会有参数压到栈里，参数有<code>CS:IP</code>和中断向量号，其中<code>CS:IP</code>还在<strong>不断变化</strong>。而随着栈中的数据越来越多，栈中的这6个字节的参数被慢慢挤出。难道这6个字节不重要吗，或者说只是在初始化的时候用了一下？但是过程中这些参数一直也在变化，所以不可能不重要.不过这些数据之所以放到栈中的原因一定不是为了存储，否则就不会被随便挤出。<br>结合第一部分实验，<code>mov sp,10</code>是紧跟着前一条指令执行的，所以我能想到的唯一一个合理的解释就是:这些参数是在指令执行过程中直接使用的，而执行过程对shell屏蔽不可见，所以在栈中数据越来越多的时候这些参数还可以随意的移动位置并且被抛弃，这些参数是过程中使用的参数，而这个过程就是中断！至于中断到底是什么，到第4章再详细学习吧。</p></blockquote><h3 id="实验3-用编程、编译、连接、跟踪"><a href="#实验3-用编程、编译、连接、跟踪" class="headerlink" title="实验3 用编程、编译、连接、跟踪"></a>实验3 用编程、编译、连接、跟踪</h3><blockquote><p>最后一个实验查看PSP（就是加载开始前256字节）的内容。<br>使用<code>u</code>来查看汇编好像又和中断有关系。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/12.png" alt="pic12"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第二部分-汇编结构&quot;&gt;&lt;a href=&quot;#第二部分-汇编结构&quot; class=&quot;headerlink&quot; title=&quot;第二部分:汇编结构&quot;&gt;&lt;/a&gt;第二部分:汇编结构&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;h4 id=&quot;汇编语言的结构&quot;&gt;&lt;a href=&quot;#汇编语言的结构&quot; class=&quot;headerlink&quot; title=&quot;汇编语言的结构&quot;&gt;&lt;/a&gt;汇编语言的结构&lt;/h4&gt;&lt;h5 id=&quot;寄存器和内存之间&quot;&gt;&lt;a href=&quot;#寄存器和内存之间&quot; class=&quot;headerlink&quot; title=&quot;寄存器和内存之间&quot;&gt;&lt;/a&gt;寄存器和内存之间&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;汇编语言是由不同的段构成的，这些段的功能各异不过主要分为&lt;code&gt;指令&lt;/code&gt;和&lt;code&gt;数据&lt;/code&gt;两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch1</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch1/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch1/</id>
    <published>2018-10-02T09:03:13.000Z</published>
    <updated>2018-10-13T02:06:21.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分-硬件模型"><a href="#第一部分-硬件模型" class="headerlink" title="第一部分:硬件模型"></a>第一部分:硬件模型</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><h4 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h4><blockquote><p>   全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————<code>冯诺依曼结构</code>。<br>   CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？<br><a id="more"></a>  </p></blockquote><ul><li>存储单元的地址（地址）</li><li>读/写操作（控制）</li><li>读/写的具体数据（数据）  </li></ul><blockquote><p> 答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它<code>内存地址空间</code>。  </p></blockquote><blockquote><p> 以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构<code>《微机原理和接口》</code>，也不是讲整个计算机系统的结构和功能<code>《组成原理》</code>。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。<br> 固有的硬件体系指的是这套<code>CPU+RAM</code>的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说<strong>不同的CPU有不同的汇编语言</strong>，用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。</p></blockquote><h4 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h4><blockquote><p>学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。<br>从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是<code>从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算</code>。但是如果我把<code>data1</code>和<code>data2</code>互换一下，其实也是可以的。但是需要考虑到的是<code>data2</code>所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。</p></blockquote><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><blockquote><p>   8086CPU有14个寄存器，都是16位的。但是这16位的寄存器也可以独立作为两个8位的寄存器使用。<br>   寄存器和内存是汇编程序猿眼中最直观的计算机样子。</p></blockquote><h5 id="汇编层面的CPU"><a href="#汇编层面的CPU" class="headerlink" title="汇编层面的CPU"></a>汇编层面的CPU</h5><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制各种器件进行工作</li><li>内部总线连接各种器件，在它们之间进行数据的传送  </li></ul><h5 id="8086架构（16位机）"><a href="#8086架构（16位机）" class="headerlink" title="8086架构（16位机）"></a>8086架构（16位机）</h5><p>具体深究到物理实现就是《组成原理》知识了。  </p><ul><li>运算器一次最多可以处理16位数据  </li><li>寄存器的最大宽度为16位      </li><li>寄存器和运算器之间的通路为16位  </li></ul><h5 id="汇编层面的内存"><a href="#汇编层面的内存" class="headerlink" title="汇编层面的内存"></a>汇编层面的内存</h5><blockquote><p>CPU在访问内存单元的时候，需要知道内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存空间在这个空间上都有唯一的地址，这个惟一的地址就叫做<code>物理地址</code>。<br>CPU首先在内部形成这个物理地址，然后通过地址总线送入存储器。这个地址一定是一个内存单元的物理地址。不同的CPU架构形成地址的方式不一样。  </p></blockquote><h5 id="CS-IP"><a href="#CS-IP" class="headerlink" title="CS:IP"></a>CS:IP</h5><blockquote><p>   前面提到了8086CPU内部需要形成物理地址，但是8086是16位机————只能处理和传输16位的地址，但是8086的地址总线有20位，所以需要两个16位来共同形成一个20位的地址。<br>    14个寄存器中，CS是段寄存器，存放基地址。而IP存放偏移量。公式:<code>CSx16+IP</code>。<br>  首先需要明白的就是，一个内存单元是8位二进制也叫一个字节。而十六进制的一位可以表示成为二进制的4位。完全只是为了方便才写成16进制的。<strong>20位的地址（5位16进制）</strong>可以写成<code>4C780H</code>，后面的H表示16进制。<code>一个X进制的数据左移一位，相当于乘以X</code>。所以为了记起来方便一些可以记成<code>CS寄存器的数据左移一位+IP寄存器的值</code>。但是<strong>两个寄存器只有16位（4位16进制)</strong>，到后面计算的时候需要注意这两个前提，避免溢出。<br>  书中特别强调了对<strong>段</strong>的理解。这里的段并不是指内存被物理上分成一段一段的。而是因为CPU在管理内存的时候，使用<code>CSx16+IP</code>的方式来进行管理。<strong>所以可以将地址连续，起始地址为16的倍数的一组内存单元看成是一个段。</strong>重点在于不是所有的起始地址都可以作为段地址————这是因为<code>CSx16</code>决定的。而且因为<code>IP</code>是16位的所以每一个段的长度最大为<code>64KB</code>。  </p></blockquote><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><blockquote><p>   <strong>在8086机中，任意时刻CPU将CS:IP指向的内容当做指令执行。</strong>汇编中使用<code>jmp 段地址:偏移地址</code>对CS:IP进行修改。或者使用<code>jmp 寄存器</code>来修改IP的值。  </p></blockquote><h6 id="8086的工作过程"><a href="#8086的工作过程" class="headerlink" title="8086的工作过程"></a>8086的工作过程</h6><ul><li>从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓存器。</li><li>IP指向下一条指令。</li><li>执行指令,从CS:IP中取指令，重复上面的过程。  </li></ul><h3 id="书中划线"><a href="#书中划线" class="headerlink" title="书中划线"></a>书中划线</h3><ul><li>汇编语言和机器语言的差别在于指令的表示方法上。</li><li>微机存储器的容量是以<strong>字节</strong>为最小单位的来计算的。</li><li>在内存和磁盘上，数据和指令没有任何区别。</li><li>在汇编语言这门课中，我们所面对的是<strong>内存地址空间</strong>。CPU向这段地址中读写数据实际上就是向相应的物理存储器中读写数据。</li><li>内存地址空间的大小受到CPU地址总线宽度的限制。</li></ul><h3 id="实验1-查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验1-查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验1 查看CPU和内存，用机器指令和汇编指令编程"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h3><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><blockquote><p>   debug是DOS,Windows都提供的实模式（8086方式）程序的调试工具。下面是本次实验将会用到的参数:  </p></blockquote><h5 id="r-读写寄存器"><a href="#r-读写寄存器" class="headerlink" title="r (读写寄存器)"></a>r (读写寄存器)</h5><ul><li><code>r</code>查看所有的寄存器的值</li><li><code>r 寄存器名称</code>修改制定寄存器的值</li></ul><h5 id="d-（读写内存）"><a href="#d-（读写内存）" class="headerlink" title="d （读写内存）"></a>d （读写内存）</h5><ul><li><code>d 段地址:偏移地址</code> 列出从指定内存单元开始的128个内存单元的内容</li><li><code>d 段地址:起始偏移地址 结尾偏移地址</code>列出在偏移地址范围之内的内存单元的内容</li></ul><h5 id="e-（读写内存）"><a href="#e-（读写内存）" class="headerlink" title="e （读写内存）"></a>e （读写内存）</h5><ul><li><code>e 段地址:偏移地址  data1  data2 data3……</code>从特定单元开始讲数据写入内存</li><li><code>e 段地址:偏移地址 回车</code>表示挨个儿修改内存，空格表示默认不修改，回车表示修改结束</li></ul><h5 id="e-u-t"><a href="#e-u-t" class="headerlink" title="e+u+t"></a>e+u+t</h5><ul><li>使用<code>e</code>参数向内存中写入机器码</li><li>使用<code>u 段地址:偏移地址</code>可以将内存中机器码翻译成为汇编语言</li><li><code>t</code>参数执行<code>CS:IP</code>指向的内存地址单元的任何指令，注意修改参数</li></ul><h5 id="a"><a href="#a" class="headerlink" title="a"></a>a</h5><ul><li><code>a 段地址:偏移地址</code>可以直接使用汇编的格式写入机器指令</li></ul><h4 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h4><blockquote><p>   一共有4个实验。写出来的都是我觉得很有意思且值得讨论的实验。  </p></blockquote><h5 id="第二个实验"><a href="#第二个实验" class="headerlink" title="第二个实验"></a>第二个实验</h5><blockquote><p>   给出起始地址为<code>2000:0000</code>的三条指令，使用这三条指令计算2的8次方。<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/2.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>   有意思的是这个算法，a += a；如果这里的a是2的话，实际上<code>a+a</code>等于<code>ax2</code>所以可以2的8次方可以通过8次这样的加法完成，但是如果a是其他的值就不行了。</p></blockquote><h5 id="最后两个实验"><a href="#最后两个实验" class="headerlink" title="最后两个实验"></a>最后两个实验</h5><blockquote><p>使用<code>e</code>参数对特定的内存单元进行读写。<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/3.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>   这两个实验间接地证明了<strong>内存地址空间</strong>的存在。<br>   我在向内存<code>B810:0000</code>中写数据的时候，发现显示器上会出现有颜色的字符和表情包，猜想这个地址应该是显存的物理地址。这也说明这里的内存不仅仅指的是主存储器，还有其他的和CPU直接相连的RAM。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一部分-硬件模型&quot;&gt;&lt;a href=&quot;#第一部分-硬件模型&quot; class=&quot;headerlink&quot; title=&quot;第一部分:硬件模型&quot;&gt;&lt;/a&gt;第一部分:硬件模型&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;h4 id=&quot;硬件基础&quot;&gt;&lt;a href=&quot;#硬件基础&quot; class=&quot;headerlink&quot; title=&quot;硬件基础&quot;&gt;&lt;/a&gt;硬件基础&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;   全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————&lt;code&gt;冯诺依曼结构&lt;/code&gt;。&lt;br&gt;   CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch0</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch0/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch0/</id>
    <published>2018-10-02T08:25:22.000Z</published>
    <updated>2018-10-10T14:01:34.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><blockquote><p>王爽老师的《汇编语言》是国内的经典教材。<br>学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。</p></blockquote><a id="more"></a>    <h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><blockquote><p>全书的实验都是在8086CPU的体系结构下展开的，这也是Intel第一块16位的处理器。<br>我们有两种办法在自己的计算机上模拟8086:一种是使用WindowsXP系统。一种是采用DOSBox模拟器，第二种比较方便。<a href="https://pan.baidu.com/s/1-Da6IPYym54QbokzFMiNvA" target="_blank" rel="noopener">这里是链接</a>。<br>本书有17个实验，2个课程设计，5个研究试验。我主要是以其中一些实验为章节展开学习。</p></blockquote><h4 id="全书架构"><a href="#全书架构" class="headerlink" title="全书架构"></a>全书架构</h4><blockquote><p>在我看来，全书应该可以分为这么几个部分:</p><ul><li>硬件模型Chapter.(1、2)————告诉你汇编编程就是程序员以<code>指令</code>为手段在<code>CPU的寄存器</code>和<code>内存地址空间</code>之间进行数据读写的的过程。</li><li>汇编结构Chapter.(3、4)————介绍了完整的汇编程序的组成部分:<code>数据段</code>，<code>代码段</code>、<code>栈段</code>。第4章介绍了汇编程序编译的全过程和基本工具的使用。</li><li>指令核心Chapter.(5~11)————从第5章作者开始引进一些新的指令，并且展开来讲汇编程序设计的核心部分。介绍了重点的指令比如<code>操作指令</code>,<code>跳转指令</code>，<code>比较指令</code>等及其用法等，并深入介绍了内存寻址的各种花式用法。</li><li>操作系统层面的应用Chapter.(12~17)和操作系统相关的概念比如中断等。</li></ul></blockquote><blockquote><p>整个学习过程中，<strong>寄存器和内存地址空间的读写是贯穿全书的核心</strong>，因为所有的操作最终都是产生了对内存或者某一个寄存器的读写。<strong>而完成这一切读写功能的就是汇编指令。</strong>这也是机器硬件的真正工作原理。<br>虽然这些部分都可以拆开来了解，但是实际上每一部分还有很多的细节和承上启下的概念，我也是站在我理解的角度对这些内容进行了划分，需要注意的是:全书还有很多的细节比如不同的存储单元和数据处理方式，这些都不是单独某一个章节可以完成的而是贯穿全书实验的前提。所以还是需要通读一遍全书来顺这些概念。</p></blockquote><h4 id="搭建实验条件"><a href="#搭建实验条件" class="headerlink" title="搭建实验条件"></a>搭建实验条件</h4><ul><li>将下载好的环境包放在<code>~/x86</code>，作为我们的工作目录。</li><li>打开DOSBox模拟器。</li><li>挂载C盘:<code>mount C ~/x86</code>。</li><li>进入C盘:<code>C:</code>。</li><li>开始实验:<code>debug</code>。</li><li>退出程序<code>quit</code>，退出模拟器<code>exit</code>。</li></ul><h4 id="安装成功展示"><a href="#安装成功展示" class="headerlink" title="安装成功展示"></a>安装成功展示</h4><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/1.png" width="300" height="200" alt="图片名称" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;王爽老师的《汇编语言》是国内的经典教材。&lt;br&gt;学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
</feed>
