<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HBlog</title>
  
  <subtitle>Haotian</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haotianmcihael.github.io/"/>
  <updated>2018-10-03T04:30:57.679Z</updated>
  <id>http://haotianmcihael.github.io/</id>
  
  <author>
    <name>haotianmichael</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编语言（王爽）ch1</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch1/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch1/</id>
    <published>2018-10-02T09:03:13.000Z</published>
    <updated>2018-10-03T04:30:57.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验1-查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验1-查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验1: 查看CPU和内存，用机器指令和汇编指令编程"></a>实验1: 查看CPU和内存，用机器指令和汇编指令编程</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h4><blockquote><p>   全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————<code>冯诺依曼结构</code>。<br>   CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？  </p><ul><li>存储单元的地址（地址）</li><li>读/写操作（控制）</li><li>读/写的具体数据（数据）<br>答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它<code>内存地址空间</code>。  </li></ul></blockquote><blockquote><p> 以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构<code>《微机原理和接口》</code>，也不是讲整个计算机系统的结构和功能<code>《组成原理》</code>。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。<br> 固有的硬件体系指的是这套<code>CPU+RAM</code>的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说<strong>不同的CPU有不同的汇编语言</strong>，王爽老师用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。</p></blockquote><h4 id="关于指令和数据"><a href="#关于指令和数据" class="headerlink" title="关于指令和数据"></a>关于指令和数据</h4><blockquote><p>学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。<br>从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是<code>从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算</code>。但是如果我把<code>data1</code>和<code>data2</code>互换一下，其实也是可以的。但是需要考虑到的是<code>data2</code>所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。</p></blockquote><h4 id="关于寄存器"><a href="#关于寄存器" class="headerlink" title="关于寄存器"></a>关于寄存器</h4><p>debug是DOS提供的实模式（8086方式）程序的调试工具。使用它可以查看CPU的各种寄存器中的内容，内存的情况和在机器码级跟踪程序的运行。<br>这里不得不佩服这个仿真器的强大，尽然可以在Mac下支持快捷键比如使用Alt+Enter键可以全屏，不过显存有点小所以分辨率不高……</p><h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实验1-查看CPU和内存，用机器指令和汇编指令编程&quot;&gt;&lt;a href=&quot;#实验1-查看CPU和内存，用机器指令和汇编指令编程&quot; class=&quot;headerlink&quot; title=&quot;实验1: 查看CPU和内存，用机器指令和汇编指令编程&quot;&gt;&lt;/a&gt;实验1: 查看CPU
      
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch0</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch0/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch0/</id>
    <published>2018-10-02T08:25:22.000Z</published>
    <updated>2018-10-02T15:22:31.565Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><blockquote><p>王爽老师的《汇编语言》是国内的经典教材。<br>学习汇编的目的在于:充分获得底层编程的体验和深刻理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。</p></blockquote><a id="more"></a>    <h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><blockquote><p>全书的实验都是在8086CPU的体系结构下展开的，这也是Intel第一块16的处理器。<br>我们有两种办法在自己的计算机上进行模拟8086:一种是使用虚拟机WindowsXP系统。一种是采用DOSBox模拟器，第二种比较方便。<a href="https://pan.baidu.com/s/1-Da6IPYym54QbokzFMiNvA" target="_blank" rel="noopener">这里是链接</a>。<br>本书有17个实验，2个课程设计，5个研究试验。我主要是以这些实验为章节展开学习。</p></blockquote><h4 id="搭建实验条件"><a href="#搭建实验条件" class="headerlink" title="搭建实验条件"></a>搭建实验条件</h4><ul><li>将下载好的环境包放在<code>~/x86</code>，作为我们的工作目录。</li><li>打开DOSBox模拟器。</li><li>挂载C盘:<code>mount C ~/x86</code>。</li><li>进入C盘:<code>C:</code>。</li><li>开始实验:<code>debug</code>。</li><li>突出程序<code>quit</code>，退出模拟器<code>exit</code>。</li></ul><h4 id="安装成功展示"><a href="#安装成功展示" class="headerlink" title="安装成功展示"></a>安装成功展示</h4><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/1.png" width="300" height="200" alt="图片名称" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;王爽老师的《汇编语言》是国内的经典教材。&lt;br&gt;学习汇编的目的在于:充分获得底层编程的体验和深刻理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
</feed>
