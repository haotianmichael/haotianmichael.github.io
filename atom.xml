<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeSaw</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haotianmcihael.github.io/"/>
  <updated>2018-12-17T03:02:10.988Z</updated>
  <id>http://haotianmcihael.github.io/</id>
  
  <author>
    <name>HaotianMichael</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux操作系统编程（线程/进程/IPC）</title>
    <link href="http://haotianmcihael.github.io/2018/12/17/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%EF%BC%88%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B-IPC%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2018/12/17/Linux操作系统编程（线程-进程-IPC）/</id>
    <published>2018-12-16T21:46:46.000Z</published>
    <updated>2018-12-17T03:02:10.988Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>总结性质。<br>进程在操作系统中通过进程控制块<strong>PCB</strong>的形式存在，而具体实现是一个叫<code>task_struct</code>的数据结构。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/14.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>进程在内核中的物理存在形式是以<code>PCB</code>队列的形式。<strong>而在逻辑上Linux系统进程都是有父子关系的树形数据结构抽象构成的。</strong><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct</span><br><span class="line">&#123;</span><br><span class="line">    long state; /*任务的运行状态（-1 不可运行，0 可运行(就绪)，&gt;0 已停止）*/</span><br><span class="line">    long counter;/*运行时间片计数器(递减)*/</span><br><span class="line">    long priority;/*优先级*/</span><br><span class="line">    long signal;/*信号*/</span><br><span class="line">    struct sigaction sigaction[32];/*信号执行属性结构，对应信号将要执行的操作和标志信息*/</span><br><span class="line">    long blocked; /* bitmap of masked signals */</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   /* various fields */</span><br><span class="line">    int exit_code;/*任务执行停止的退出码*/</span><br><span class="line">    unsigned long start_code,end_code,end_data,brk,start_stack;/*代码段地址 代码长度（字节数）</span><br><span class="line">                                    代码长度 + 数据长度（字节数）总长度 堆栈段地址*/</span><br><span class="line">    long pid,father,pgrp,session,leader;/*进程标识号(进程号) 父进程号 父进程组号 会话号 会话首领*/</span><br><span class="line">    unsigned short uid,euid,suid;/*用户标识号（用户id） 有效用户id 保存的用户id*/</span><br><span class="line">    unsigned short gid,egid,sgid; /*组标识号（组id） 有效组id 保存的组id*/</span><br><span class="line">    long alarm;/*报警定时值*/</span><br><span class="line">    long utime,stime,cutime,cstime,start_time;/*用户态运行时间 内核态运行时间 子进程用户态运行时间</span><br><span class="line">                           子进程内核态运行时间 进程开始运行时刻*/</span><br><span class="line">    unsigned short used_math;/*标志：是否使用协处理器*/</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   /* file system info */</span><br><span class="line">    int tty; /* -1 if no tty, so it must be signed */</span><br><span class="line">    unsigned short umask;/*文件创建属性屏蔽位*/</span><br><span class="line">    struct m_inode * pwd;/*当前工作目录i 节点结构*/</span><br><span class="line">    struct m_inode * root;/*根目录i节点结构*/</span><br><span class="line">    struct m_inode * executable;/*执行文件i节点结构*/</span><br><span class="line">    unsigned long close_on_exec;/*执行时关闭文件句柄位图标志*/</span><br><span class="line">    struct file * filp[NR_OPEN];/*进程使用的文件表结构*/</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   /* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span><br><span class="line">    struct desc_struct ldt[3];/*本任务的局部描述符表。0-空，1-代码段cs，2-数据和堆栈段ds&amp;ss*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* tss for this task */</span><br><span class="line">    struct tss_struct tss;/*本进程的任务状态段信息结构*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>其中主要有<strong>进程本身信息（时间等）</strong>，<strong>调度信息</strong>，<strong>文件系统管理</strong>，<strong>内存管理</strong>，<strong>IPC相关信号描述</strong>这几个大的块。<br>调度信息中的进程状态<code>volatile long state</code>有以下五种可能取值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_RUNNING 0</span><br><span class="line">//进程等待某种资源而挂起，根据是否可以响应系统异步信号分为两种</span><br><span class="line">//可以响应</span><br><span class="line">#define TASK_INTERRUPTIBLE 1   </span><br><span class="line">// 不可以响应，主要是初始化过程中，进行硬件操作的时候</span><br><span class="line">#define TASK_UNINTERRUPTIBLE 2 </span><br><span class="line">#define TASK_ZOMBIE 4      //当进程生命周期终止但是内核资源并未释放</span><br><span class="line">#define TASK_STOPPED 8</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>各个状态的转换图: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/15.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>在<code>task_struct</code>文件管理中有三张表:<br><code>fs</code>结构保存进程的<strong>根目录</strong>和<strong>当前目录</strong>。而<code>files</code>结构中就有<strong>文件描述符表</strong>，每一个文件描述符元素指向一个<strong>文件表</strong>，而每一个文件表中又都有一个指向<strong>索引节点表</strong>的指针。总的来说:<code>文件描述符表</code>————&gt;<code>文件表</code>————&gt;<code>索引节点表</code>。</p><ul><li>文件描述表(files)：描述进程打开的所有文件 </li><li>文件表：文件每一次被打开形成的一张表，主要包括的内容有<code>状态标志</code>，<code>读写偏移量</code>，<code>引用计数</code>等</li><li>索引节点表: 物理文件存储的记录表，包括有<code>文件的存储位置</code><br>下图个人觉得是最重要的表之一:</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/16.png" width="300" height="200" alt="pic2" align="center"></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote></blockquote><h3 id="线程同步和进程间通信机制"><a href="#线程同步和进程间通信机制" class="headerlink" title="线程同步和进程间通信机制"></a>线程同步和进程间通信机制</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;总结性质。&lt;br&gt;进程在操作系统中通过进程控制块&lt;strong&gt;PCB&lt;/strong&gt;的形式存在，而具体实现是一个叫&lt;code&gt;task_struct&lt;/code&gt;的数据结构。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/14.png&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;pic2&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程在内核中的物理存在形式是以&lt;code&gt;PCB&lt;/code&gt;队列的形式。&lt;strong&gt;而在逻辑上Linux系统进程都是有父子关系的树形数据结构抽象构成的。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
      <category term="C" scheme="http://haotianmcihael.github.io/tags/C/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Linux操作系统编程(文件系统)</title>
    <link href="http://haotianmcihael.github.io/2018/12/09/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>http://haotianmcihael.github.io/2018/12/09/Linux操作系统编程/</id>
    <published>2018-12-09T10:24:29.000Z</published>
    <updated>2018-12-17T01:42:23.532Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>总结性质。<br>为了6.828的Lab3能够更好的进行下去，花几天时间总结一下和Linux多线程编程相关的知识点。主要有:<strong>基础知识</strong>，<strong>文件与目录操作</strong>，<strong>线程和进程</strong>以及<strong>线程同步和进程间通信机制</strong>四个大块。博客总结为<strong>文件系统</strong>和<strong>进程/线程</strong>两部分。<br>下图为操作系统程序员眼中Linux的基本编程架构:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/1.png" width="300" height="200" alt="pic2" align="center"><br><a id="more"></a></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>多句嘴~Linux发展到今天，经历了好几个技术积累的阶段:<br><code>Multics(AT&amp;T,MIT,GE)</code> ————&gt; <code>Unix(The Unix Time Sharing System)</code> ————&gt; <code>C</code> ————&gt; <code>System V(AT&amp;T)</code>, <code>BSD(Berkeley)</code> ————&gt; <code>ANSI C(C语言标准)</code> —————&gt; <code>POSIX（1983-API接口）</code> ————&gt; <code>GNU(RMS)</code> ————&gt; <code>Minix(1984)</code> ————&gt; <code>Linux(1991)</code><br>从OS的功能角度来看Linux的体系结构，主要有<strong>内存管理</strong>,<strong>进程/线程</strong>,<strong>文件管理</strong>,<strong>设备管理</strong>四部分。多线程编程主要是后三部分的内容涉及到和用户的接口部分。</p></blockquote><h4 id="Linux体系结构"><a href="#Linux体系结构" class="headerlink" title="Linux体系结构"></a>Linux体系结构</h4><h5 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h5><ul><li>进程控制: 包括进程创建，进程撤销，进程阻塞，进程唤醒</li><li>进程协调: 包括进程运行的异步性，因此进程同步的任务是对诸多进程的运行协调，包括两种方式:进程互斥方式和进程同步方式</li><li>进程通信: 主要完成同一台机器上不同进程间通信和不同机器上进程间的通信，共同完成一相同的任务</li><li>进程调度: 操作系统按照一定的规则对等待运行的多道程序进行调度，以保证每个程序都有机会得到运行，并最终完成</li></ul><h5 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h5><ul><li>文件存储空间的管理: 为每一个文件分配必要的外存空间，为提高外部存储空间的利用率，系统应设置相应的数据结构，用于记录文件存储空间的使用情况</li><li>目录管理: 为了方便对用户的文件进行管理，对文件系统建立一定结构的目录结构，同时要求快速的目录查询手段</li><li>文件的读，写管理和存取控制: 利用一定的系统调用对文件进行读写操作。同时，为防止系统中的文件被非法访问和窃取，文件系统中必须提供有效存取控制功能</li></ul><h5 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h5><ul><li>缓冲管理: 管理各种类型的缓冲区，入字符缓冲区和快缓冲区，以缓和CPU和I/O速度不匹配的矛盾，最终达到提高CPU和I/O设备的利用率，进而提高系统吞吐量的目的</li><li>设备分配: 根据用户的I/O请求，为其分配器所需要的设备</li><li>设备处理: 又称为设备驱动程序，任务是实现CPU和设备控制器之间的通信</li><li>设备独立性和虚拟设备: 一方面保证用户程序独立于物理设备，另一方面保证多个进程能并发地共享同一个设备</li></ul><h4 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h4><blockquote><p><code>man 2 syscalls</code>系统调用时内核提供的程序接口，是应用程序和硬件设备之间的中间层。<br>系统调用主要分为:<strong>文件操作类系统调用</strong>，<strong>进程控制类系统调用</strong>，<strong>通信类系统调用</strong>，<strong>设备管理类系统调用</strong>，<strong>信息维护类系统调用</strong>。<br><strong>系统调用是操作系统的最小执行单位，</strong>直接使用Syscalls比较麻烦，应用程序开发一般使用API而不是直接使用系统调用来编程。C库遵循POSIX规范，以库函数的形式实现了很多POSIX API。<strong>系统调用和C库函数之间并不是一一对应的。比如<code>malloc</code>&amp;<code>free</code>和<code>exec</code>函数类。</strong><br>用户可以通过C库函数实现相关功能，Linux软件层次架构更好的解释了<strong>接口</strong>这一概念: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/2.png" width="300" height="200" alt="pic2" align="center"></p><h4 id="Linux程序编译调试方法"><a href="#Linux程序编译调试方法" class="headerlink" title="Linux程序编译调试方法"></a>Linux程序编译调试方法</h4><blockquote><p>GCC是GNU计划的一个项目，由原来的GNU C Compiler发展到了CUN Compiler Collection。主要包括:<code>cpp(预处理器)</code>，<code>gcc(C编译器)，g++(c++编译器)等编译器</code>,<code>binutils等二进制工具（as汇编器）（ld链接器）</code><br>编译过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpp -o hello.i hello.c 预处理</span><br><span class="line">ccl -o hello.s hello.i 编译</span><br><span class="line">as -o hello.o hello.s 汇编</span><br><span class="line">ld -o hello hello.o 链接</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h5><h6 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h6><ul><li>-O 指定输出文件名</li><li>-E 仅激活预处理</li><li>-S 激活预处理和编译</li><li>-C 编译可重定位目标文件(即.o文件)</li><li><p>-D 宏定义选项 作用于所有的源文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PI 3.14159</span><br><span class="line"></span><br><span class="line">gcc -DPI=3.14159 main.c</span><br></pre></td></tr></table></figure></li><li><p>-I 指定额外头文件的搜索路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc helloworld.c -l /usr/include/ -o helloworld</span><br></pre></td></tr></table></figure></li><li><p>-w 禁止所有警告信息</p></li><li>-Wall 打开所有警告选项，输出警告信息</li></ul><h6 id="调试指令"><a href="#调试指令" class="headerlink" title="调试指令"></a>调试指令</h6><blockquote><p><strong>调试选项的启动会让二进制文件的大小急剧增长。</strong>  </p><ul><li>-g 以操作系统的本地各式（stab, COFF, XCOFF, DWARF）产生调试信息，GDB等调试器可以使用这些调试信息</li><li>ggdb 生成更加丰富的调试信息，不过有可能不能被其他的调试器使用</li></ul></blockquote><h6 id="优化指令"><a href="#优化指令" class="headerlink" title="优化指令"></a>优化指令</h6><blockquote><p><strong>调试的时候不能使用优化选项，否则变量值和源代码无法对应。</strong></p><ul><li>-O/-O1 编译器会试图减少目标吗的大小和执行时间</li><li>-O2 除了设计速度和空间交换的优化选项，执行几乎所有的优化工作，但不进行循环展开和函数内嵌</li><li>-O3 乱序执行，循环展开的优化</li></ul></blockquote><h6 id="库文件相关"><a href="#库文件相关" class="headerlink" title="库文件相关"></a>库文件相关</h6><ul><li><p>-r 将<code>.o</code>归档成静态库<code>.a</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -r libincrease.a increase.o</span><br></pre></td></tr></table></figure></li><li><p>静态库和其他源文件链接成为可执行文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -L -static -o main</span><br></pre></td></tr></table></figure></li><li><p>生成动态链接库（名称必须以<code>lib</code>开头，<code>.so</code>结束）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-shared 生成共享文件</span><br><span class="line">-fPIC 生成位置独立的代码，此类代码可以在不同进程之间共享</span><br><span class="line">-linc 中-l参数 连接器自动加上lib和.so = libinc.so</span><br><span class="line">-L 用户自定义目录搜索共享库 比如 gcc main.c -o main -linc -L./ 指定./</span><br><span class="line">gcc -shared -fPIC -o libinc.so increase.c</span><br></pre></td></tr></table></figure></li></ul><h5 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h5><blockquote><p>GNU计划开发的程序调试工具。可以随心所欲的调试运行中的程序，并当程序停住的时候检查此时程序中所发生的事情，甚至动态的改变程序的执行环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">启动的方式:</span><br><span class="line">$ gdb</span><br><span class="line">$ file program</span><br><span class="line"></span><br><span class="line">$ gdb &lt;program-可执行文件&gt;</span><br><span class="line"></span><br><span class="line">$ gdb program core</span><br><span class="line"></span><br><span class="line">调试正在运行的进程</span><br><span class="line">$ gdb program &lt;processid&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>下面是程序调试的具体方式  </p><ul><li>break [LOCATION] [thread THREADNUM] [if CONDITION]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[LOCATION]:</span><br><span class="line">`linenum`  b 123</span><br><span class="line">`function name` b main</span><br><span class="line">`filename: linenum` b increase:123</span><br><span class="line">`filename: function` b increase:main  </span><br><span class="line">`class:function(c++)`</span><br><span class="line"></span><br><span class="line">[thread THREADNUM]调试多线程程序的时候，切换到哪个线程或者在那个线程中设置断点</span><br><span class="line">bread frik.c:13 thread 28</span><br><span class="line"></span><br><span class="line">[if CONDITION]  当条件满足时断点才生效，一般称为条件断点</span><br><span class="line">b 123 if index==2</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>watchpoint 观察点（变量），当观察对象的值发生变化的时候，程序立即停止执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch &lt;expr&gt; 一旦值有变化，马上停止程序</span><br><span class="line">  </span><br><span class="line">rwatch &lt;expr&gt;  当观察点被读时停止程序</span><br><span class="line"></span><br><span class="line">awatch &lt;expr&gt; 当观察点的值被读或者写时停止程序</span><br><span class="line"></span><br><span class="line">info  watchpoints 列出当前所有的观察点</span><br></pre></td></tr></table></figure></li><li><p>禁用调试断点和观察点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear [linenum] [function name] 清除所有断点，不会清除watchpoints</span><br><span class="line">delete &lt;num&gt; 清除编号为num的断点或者watchoint</span><br><span class="line">disable &lt;num&gt; 禁止某个断点</span><br><span class="line">enable &lt;num&gt; 开启某个断点</span><br></pre></td></tr></table></figure></li><li><p>调试手段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step 单步调试</span><br><span class="line">next 单步调试，但是跳过函数调用</span><br><span class="line">finish 单步调试直接从一个函数返回</span><br><span class="line">disassemble 显示汇编代码</span><br></pre></td></tr></table></figure></li><li><p>堆栈相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backtrace/bt 查看程序当前堆栈情况</span><br><span class="line">where 查看当前位置</span><br><span class="line">up/down 向上或者向下移动一个堆栈</span><br><span class="line">frame&lt;num&gt;/f 移动到第num个堆栈</span><br><span class="line">当移动到某个堆栈时，便可以用gdb命令查看那个堆栈中的局部变量</span><br></pre></td></tr></table></figure></li></ul><h3 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h3><blockquote><p><strong>文件系统是以合理有效的层次结构组织的文件和目录集合。主要功能是对文件存储设备的空间进行组织和分配，负责文件的存储并对存入的文件进行保护和检索的系统。</strong><br>在Linux中允许<strong>多个不同的文件系统</strong>存在，通过统一的文件I/O系统调用API即可对系统中的任意文件进行操作而无需考虑具体的文件系统格式。下图是Linux文件系统的架构图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/3.png" width="300" height="200" alt="pic2" align="center"></p><h4 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h4><blockquote><p>虚拟文件系统是Linux内核中的一个软件层，对内实现文件系统的抽象允许不同的文件系统，对外向应用程序提供统一的文件系统接口。<strong>为了能够支持不同的文件系统，VFS定义了所有文件系统都支持的基本的抽象的接口和数据结构:</strong></p><ul><li><code>超级块(super block)</code> 用于存储<strong>文件系统</strong>的控制信息的数据结构，描述文件系统状态，大小，区块数，索引接点数等，存放于磁盘的特定扇区中</li><li><code>索引节点(inode)</code> 用于<strong>存储文件</strong>的元数据（文件的基本信息）的数据结构，包含诸如文件大小，拥有者，创建时间，磁盘位置等信息</li><li><code>目录项(dentry)</code> 目录项用来容纳文件，目录可以包含子目录，层层嵌套</li><li><code>文件对象(file)</code> 一组在逻辑上具有完整意义的信息项的系列</li></ul></blockquote><h5 id="VFS-超级块"><a href="#VFS-超级块" class="headerlink" title="VFS-超级块"></a>VFS-超级块</h5><blockquote><p>每个具体文件系统都有各自的超级块，VFS超级块是各种具体的文件系统在安装时建立的，其数据结构是super_block。<strong>所有超级块对象以双向环形链表的形式链接在一起</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct super_block &#123;</span><br><span class="line">kdev_t s_dev;   // 具体文件系统的块设备标识符</span><br><span class="line">unsigned long s_blocksize; //以字节为单位数据块的大小</span><br><span class="line">unsigned char s_blocksize_bits;   //块大小的值占用的位数</span><br><span class="line">...</span><br><span class="line">struct list_head s_list;  //指向超级块链表的指针</span><br><span class="line">struct file_system_type *s_type;  //指向文件系统file_system_type数据结构的指针</span><br><span class="line">struct super_operation *s_op; //指向具体文件系统的用于超级块操作的函数集合</span><br><span class="line">u;  //一个共用体，其成员是各种文件系统的fsname_sb_info的数据结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="VFS-索引结点"><a href="#VFS-索引结点" class="headerlink" title="VFS-索引结点"></a>VFS-索引结点</h5><blockquote><p>FS处理文件所需要的信息都在inode中。<strong>具体FS的iNode是存放在磁盘上的，是一种静态结构。要使用它必须调入内存，填写VFS的索引节点。因此VFS索引接点是动态节点。</strong><br>文件名称可以随时更改，但是索引节点是唯一的，并随文件存在而存在。<br>每个iNode大小默认为128字节或者256字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct inode &#123;</span><br><span class="line">struct list_head i_hash;  //指向哈希链表的指针 </span><br><span class="line">struct list_head i_list;   //指向索引接点链表的指针</span><br><span class="line">struct list_head i_dentry;   //指向目录项链表的指针</span><br><span class="line">...</span><br><span class="line">struct inode_operations *i_op;  //指向对该节点操作的函数</span><br><span class="line">struct super_block *i_sb; //指向该文件系统超级块的指针</span><br><span class="line">atomic_t i_count; //当前使用该节点的进程数</span><br><span class="line">struct file_operation *i_fop;  //指向文件操作的指针</span><br><span class="line">... </span><br><span class="line">unsigned long i_state;  //索引接点的状态标志</span><br><span class="line">unsigned int i_flags; //文件系统的安装标志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="VFS-目录项"><a href="#VFS-目录项" class="headerlink" title="VFS-目录项"></a>VFS-目录项</h5><blockquote><p>每个文件除了有一个索引节点inode数据结构外，还有一个目录项dentry数据结构。<br>dentry代表逻辑意义上的文件，描述的是文件逻辑上的属性，在磁盘上并没有对应的映像。<strong>只存在于内存中的目录项缓存，是为了提高查找性能而存在的。</strong><br>iNode代表的是物理意义上的文件，其inode结构在磁盘上就有相应的映像。<br><strong>一个索引节点对象可能对应多个目录项对象。</strong><br><strong>一个有效的dentry必然与一个iNode关联，但是iNode不仅仅只有一个dentry因为有链接文件存在。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct dentry &#123;</span><br><span class="line">atomic_t d_count;  //目录项引用计数器</span><br><span class="line">unsigned int d_flags;  //目录项标志</span><br><span class="line">struct inode *d_inode; //与文件名关联的索引节点</span><br><span class="line">struct dentry *d_parent;  //父目录的目录项</span><br><span class="line">struct list_head d_hash;  //目录项形成的哈希表</span><br><span class="line">struct list_head d_lru;   //未使用的LRU链表</span><br><span class="line">struct list_head d_child;  //父目录的子目录项所形成的链表</span><br><span class="line">struct list_head d_subdirs; //该目录项的子目录所形成的链表</span><br><span class="line">struct list_head d_alias;   //索引节点别名的链表</span><br><span class="line">int d_mounted;  //目录项的安装点（一个目录下可以有不同的文件系统）</span><br><span class="line">struct qstr d_name;   //目录项名（可快速查找）</span><br><span class="line">struct dentry_operation *d_op;  //操作目录项的函数</span><br><span class="line">struct super_block *d_sb; //目录项的树（即文件的超级块）</span><br><span class="line">unsigned long d_vfs_flags;  </span><br><span class="line">void * d_fsdata;  //具体文件系统的数据</span><br><span class="line">unsigned char d_iname[DNAME_INLINE_LEN];  //短文件名</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="VFS-文件对象"><a href="#VFS-文件对象" class="headerlink" title="VFS-文件对象"></a>VFS-文件对象</h5><blockquote><p><strong>进程是通过文件描述符来访问文件的。</strong><br>Linux中专门用了一个fs_struct文件对象来保存<strong>打开文件的位置</strong>，这个对象被称为<strong>打开的文件描述（open file description）</strong>。file结构中主要保存了文件位置，此外还把指向文件索引节点的指针也放在其中，file结构形成了一个双链表，称为系统打开文件表。  </p></blockquote><blockquote><p>文件描述符是用来描述打开的文件的，每一个进程用一个files_struct结构来记录文件描述符的使用情况，这个files_struct结构称为用户打开文件表，它是进程的私有数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;</span><br><span class="line">struct list_head f_list;  //所有打开的文件形成的链表</span><br><span class="line">struct dentry *f_dentry;   //与该文件相关的dentry</span><br><span class="line">struct vfsmount *f_vfsmnt;  //该文件在这个文件系统中的安装点</span><br><span class="line">struct file_operation *f_op;   //文件操作</span><br><span class="line">atomic_t f_count;    //引用计数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int f_flags;    //打开文件时指定的标识</span><br><span class="line">mode_t f_mode;   //件的访问模式</span><br><span class="line">loff_t f_pos;    //目前文件的相对开头的偏移</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned long f_reada, f_ramax, f_raend, f_ralen, f_rawin; </span><br><span class="line">//预读标志  要预读的最多页面数  上次预读后的文件 指针，预读的字节数以及预读的页面数</span><br><span class="line">struct fown_struct;  //进程ID  信号</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct files_strut &#123;</span><br><span class="line">atomic_t count; //引用计数</span><br><span class="line">rwlock_t file_lock;  //锁，保护下面的字段</span><br><span class="line">int max_fds;  //当前文件对象的最大数量</span><br><span class="line">int max_fdset; //文件描述符的最大数</span><br><span class="line">int next_fd; //已分配的最大文件描述符</span><br><span class="line">struct file **fd;  // 指向文件对象指针数组的指针</span><br><span class="line">fd_set *close_on_exec; //执行exec()时候需要关闭的文件描述符</span><br><span class="line">fd_set *open_fds;   //指向打开的文件描述符的指针</span><br><span class="line">fd_set close_on_exec_init;  //执行exec()时候需要关闭的文件描述符初始化值</span><br><span class="line">fd_set open_fds_init; //文件描述符初值集合</span><br><span class="line">struct file *fd_array[NR_OPEN_DEFAULT]; //文件对象指针的初始化数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="数据结构之间的关系"><a href="#数据结构之间的关系" class="headerlink" title="数据结构之间的关系"></a>数据结构之间的关系</h5><ul><li>超级块是对一个文件系统的描述</li><li>索引节点是对一个文件物理属性的描述</li><li>目录项是对一个文件逻辑属性的描述</li><li>一个进程所处的位置是由fs_struct来描述的，而一个进程（或者用户）打开的文件是由files_struct来描述的（用户打开文件表），而整个系统所打开的文件是由file结构来描述的（系统打开文件表）</li></ul><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/4.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="文件系统的注册和注销"><a href="#文件系统的注册和注销" class="headerlink" title="文件系统的注册和注销"></a>文件系统的注册和注销</h5><ul><li>内核被编译的时候就已经确定了可以支持哪些文件系统，这些文件系统在VFS中尽心注册</li><li>VFS的初始化函数用来向VFS注册，就填写文件注册表file_system_type数据结构</li><li>注册调用register_filesystem()函数</li><li>注销即删除一个file_system_type结构，需调用unregister_filesystem()函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct file_system_type &#123;</span><br><span class="line">const char *name; //文件系统的类型名</span><br><span class="line">int fs_flags; // 文件系统的一些特性</span><br><span class="line">struct super_block *(*read_super)   //文件系统读入其超级块的函数指针</span><br><span class="line">(struct super_block*, void*, int); </span><br><span class="line">struct module *owner; //确定是否把文件系统作为模块来安装</span><br><span class="line">struct file_system_type * next;</span><br><span class="line">&#125;</span><br><span class="line">安装一个文件系统：（挂在到根文件系统的指定安装点，初始化超级块对象）</span><br><span class="line"></span><br><span class="line">$ mount -t iso9660 /dev/hdc /mnt/cdrom   文件系统名称  包含文件系统的物理块设备  文件系统在已有文件系统中的安装点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">卸载文件系统:</span><br><span class="line">$ umount</span><br><span class="line">正在使用中的文件系统不可以被卸载</span><br><span class="line">查看对应的VFS超级块，如果有脏位，必须将超级块信息协会磁盘。</span><br><span class="line">然后释放VFS超级块，vfsmount数据结构将从vfsmntlist链表中断开并被释放</span><br></pre></td></tr></table></figure></li></ul><h4 id="文件I-O操作"><a href="#文件I-O操作" class="headerlink" title="文件I/O操作"></a>文件I/O操作</h4><h5 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h5><blockquote><p>系统调用运行在内核空间。<br>系统调用本质上并不是直接与程序员进行交互的，通过一个<strong>软中断机制</strong>向内核提交请求，以获取内核服务的接口systemCall并跳转到该地址。<strong>在Linux中使用中断0x80实现。</strong><br>在实际上程序员调用的是用户编程接口————API比如<code>read,write函数等</code>；程序员一般的调用过程是:<br>在应用程序中的系统命令（用户态） ————&gt; <strong>在libc标准库</strong>中的API（用户态） ————&gt; 系统调用处理程序（内核态） ————&gt; 系统调用服务例程（内核态）  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/5.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h5><blockquote><p><strong>文件描述符是一个非负整数，一个索引值并指向在内核中每个进程打开文件的记录表。当打开一个现存文件或创建一个新文件时，内核就向进程返回一个文件描述符，当需要读写文件时，也需要把文件描述符作为参数传递给相应的函数。</strong><br>当一个进程启动的时候，通常会打开3个<strong>文件</strong>:<code>标准输出（默认为键盘）--描述符为0</code>，<code>标准输出（默认为屏幕）--描述符为1</code>,<code>标准错误输出（默认是屏幕）--描述符为2</code>。  </p></blockquote><h5 id="Linux文件I-O"><a href="#Linux文件I-O" class="headerlink" title="Linux文件I/O"></a>Linux文件I/O</h5><h6 id="open"><a href="#open" class="headerlink" title="open"></a>open</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">pathname: 欲打开的文件路径字符串</span><br><span class="line">sub_flags:</span><br><span class="line">O_RDONLY 以只读方式打开文件</span><br><span class="line">O_WRONLY 以只写方式打开文件</span><br><span class="line">O_RDWR 以可读可写方式打开文件</span><br><span class="line">下面三种标识互斥，不可以同时使用。但是可以和par_flags使用OR（|）运算符组合: </span><br><span class="line">par_flags:</span><br><span class="line">O_CREAT 若欲打开的文件不存在则自动创建该文件</span><br><span class="line">O_TRUNC 若文件存在并以可写的方式打开时，该标识符会令文件长度清零，而原来存在于该文件的资料也会消失</span><br><span class="line">O_APPEND 当读写文件时会从文件尾开始移动，也就是所写入的数据会以附加的方式加入到文件后面</span><br><span class="line">O_NONBLOCK 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中</span><br><span class="line">O_EXCL 如果同时指定O_CREAT，。而该文件又是存在的，报错；也可以测试一个文件是否存在，不存在则创建</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">文件打开成功返回文件的描述符，失败返回-1</span><br></pre></td></tr></table></figure><h6 id="creat"><a href="#creat" class="headerlink" title="creat"></a>creat</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/stat.h&gt;</span><br><span class="line">#include&lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int creat(const char *pathname, mode_t mode)</span><br><span class="line"></span><br><span class="line">pathname 指向欲建立的文件路径字符串，creat()相当于使用下列的调用函数:</span><br><span class="line">open(const char *pathname, (O_CREAT|O_WRONLY|O_TRUNC));</span><br><span class="line">返回值</span><br><span class="line">creat()会返回新的文件描述符，若有错误发生则会返回-1，并把错误代码设给errno</span><br><span class="line">creat函数的一个不足之处是他以只写方式打开所创建文件</span><br></pre></td></tr></table></figure><h6 id="close"><a href="#close" class="headerlink" title="close"></a>close</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int close(int fd);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">当使用完文件后若不再需要则可使用close关闭该文件；close()会让数据写回磁盘，并释放该文件所占用的资源。参数fd为先前由open或者creat所返回的文件描述符</span><br><span class="line">返回值</span><br><span class="line">若文件顺利关闭则返回0，发生错误返回-1</span><br><span class="line">虽然在进程结束时系统会自动关闭以打开的文件，但仍建议自行关闭文件，并检查返回值</span><br></pre></td></tr></table></figure><h6 id="read"><a href="#read" class="headerlink" title="read"></a>read</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">read会把参数fd所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read不会有作用并返回0；返回值为实际读取到的字节数，如果返回值为零，说明已经到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动</span><br><span class="line">返回值</span><br><span class="line">返回读取的字节数</span><br><span class="line">出错返回-1</span><br><span class="line">read函数实际上读到的字节数少于要求读到的字节数时：</span><br><span class="line">读普通文件，在读到要求字节数之前就到达文件尾</span><br><span class="line">当从终端读取，最多一次读取一行</span><br><span class="line">当从网络中读取数据的时候，网络中的返回值可能会小于所要求的读取的字节数</span><br><span class="line">某些面向记录的设备，比如磁带，一次最多返回一个记录</span><br><span class="line">读操作完成后，文件的当前位置将从读之前的位置加上实际读取的字节数</span><br><span class="line">当有错误发生的时候，错误代码存入errno中，而文件读写位置则无法预期</span><br></pre></td></tr></table></figure><h6 id="write"><a href="#write" class="headerlink" title="write"></a>write</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">write()会把参数buf所指向的内存写入count个字节到参数fd所指向的文件内，当然，文件读写位置也会随之移动</span><br><span class="line">返回值</span><br><span class="line">如果顺利write()会返回实际上写入的字节数，当有错误发生时候则返回-1，错误代码存入errno中。write函数出错的原因可能是磁盘满，没有访问权限，或写超过文件长度限制等</span><br><span class="line">将数据写入已经打开的文件中，对于普通文件，写操作从文件当前位置开始写（除非打开文件时指定了o_APPEND选项），写操作完成后，文件的当前位置将从写之前的位置加上实际上写的字节数。</span><br><span class="line"></span><br><span class="line">数据无法一次性读写完时</span><br><span class="line">第二次读buf中数据时，读位置指针并不会自动移动</span><br><span class="line">按如下格式实现读位置移动，write(fp, p1+len, (strlen(p1)-len));直至指针恢复</span><br><span class="line"></span><br><span class="line">Write一次可以写的最大数据范围是8192</span><br><span class="line">写数据大小最好小于buff中的值</span><br><span class="line">Count参数值大于SSIZE_MAX，则write()调用的结果未定义</span><br><span class="line">Count参数值为0时，write()调用会立即返回零</span><br><span class="line">Write()调用返回时，内核已经将缓冲区提供的数据复制到内核的缓冲区中，但是无法保证数据已经写到预定的目的地</span><br></pre></td></tr></table></figure><h6 id="ioctl-设备驱动程序中毒设备的I-O通道进行管理"><a href="#ioctl-设备驱动程序中毒设备的I-O通道进行管理" class="headerlink" title="ioctl(设备驱动程序中毒设备的I/O通道进行管理)"></a>ioctl(设备驱动程序中毒设备的I/O通道进行管理)</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">int ioctl(int fd, int cmd, ...);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">ioctl()能对一些特殊的文件（主要是设备）进行一些底层参数的操作，许多字符设备都使用ioctl请求来完成对设备的控制</span><br><span class="line">返回值</span><br><span class="line">成功返回0，当有错误发生的时候，错误代码存入errno中</span><br><span class="line">ioctl是设备驱动程序中对设备I/O通道进行管理的函数，所谓对I/O通道进行管理就是对设备的一些特性进行控制，例如串口的传输波特率，马达的转速等</span><br></pre></td></tr></table></figure><h5 id="Linux标准I-O"><a href="#Linux标准I-O" class="headerlink" title="Linux标准I/O"></a>Linux标准I/O</h5><blockquote><p>文件I/O又叫做直接I/O，表明应用程序直接和磁盘进行数据交换而不用经过内核的缓冲区。而标准I/O在用户区增加了缓冲区。<br>标准I/O相对于文件I/O来说。分离了应用程序空间和实际的物理设备，减少直接读盘次数，提高了性能。</p></blockquote><h6 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FILE *fopen(const char *restrict pathname, const char *restrict type);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">type             说明</span><br><span class="line">r或rb           为读而打开</span><br><span class="line">w或wb           使文件长度为0，或为写而创建</span><br><span class="line">a或ab           添加，为在文件尾而打开，或为写而创建</span><br><span class="line">r+或r+b或rb+    为读和写而打开</span><br><span class="line">w+或w+b或wb+    使文件长度为0，或为读和写而打开</span><br><span class="line">a+或a+b或ab+    为在文件尾读和写而打开或创建</span><br></pre></td></tr></table></figure><h6 id="setbuf和setvbuf"><a href="#setbuf和setvbuf" class="headerlink" title="setbuf和setvbuf"></a>setbuf和setvbuf</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开和关闭缓冲机制</span><br><span class="line">void setbuf(FILE *steam, char *buf);</span><br><span class="line">void setvbuf(FILE *steam, char *buf, int mode, size_t size);</span><br></pre></td></tr></table></figure><h6 id="fdopen"><a href="#fdopen" class="headerlink" title="fdopen"></a>fdopen</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">去一个现存的文件描述符，并使一个标准I/O流与该描述符相结合</span><br><span class="line">FILE *fdopen(int fd, char *type);</span><br><span class="line"></span><br><span class="line">fdopen常用于由创建管道及网络通信函数返回的描述符</span><br><span class="line">这些特殊类型的文件不能用fdopen打开</span><br><span class="line">因此必须先调用设备专用函数已获得一个文件描述符，然后使用fdopen使一个标准I/O流与该描述符相关联</span><br><span class="line">对于fdopen函数，type参数的意义稍有区别</span><br><span class="line">因为该文件描述符已被打开，所以fdopen为写而打开并不截短该问价</span><br><span class="line">不能用于创建该文件，（因为如若一个描述符引用一个文件，则该文件一定已经存在的）</span><br></pre></td></tr></table></figure><h5 id="Linux文件定位"><a href="#Linux文件定位" class="headerlink" title="Linux文件定位"></a>Linux文件定位</h5><h6 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h6><blockquote><p>lseek常用于找到文件的开头，找到文件的末端，判定文件描述符的当前位置；<br>lseek仅将当前的文件偏移量记录在内核中，它并不引起任何I/O操作，然后该偏移量用于下一次读，写操作。<br>文件偏移量是可以大于文件的当前长度，但并不改变相应的i节点信息。在这种情况下的下一次写将延长该文件，并在文件中构成一个空洞，但文件大小并不是文件的最大偏移量。对空洞位置的读操作将返回0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">off_t lseek(int filedes, off_t offset, int origin);</span><br><span class="line">函数说明</span><br><span class="line">filedes 文件描述符</span><br><span class="line">offset 必须与origin一同解析</span><br><span class="line">origin 为SEEK_SET， 则offset从文件的开头位置算起</span><br><span class="line">origin 为SEEK_CUR, 则offset从当前位置算起，既新偏移量为当前偏移量加上offset</span><br><span class="line">origin 为SEEK_END, 则offset从文件末尾算起</span><br><span class="line">返回值</span><br><span class="line">如果失败，返回值为-1，成功返回移动后的文件偏移量，可用Lseek确定当前偏移量</span><br><span class="line">currpos = lseek（fd, 0, SEEK_CUR）;</span><br></pre></td></tr></table></figure></p></blockquote><h6 id="pread"><a href="#pread" class="headerlink" title="pread"></a>pread</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">函数说明</span><br><span class="line">在给定的偏移量读取一个文件描述符</span><br><span class="line">size_t pread(int fd, void *buf, size_t count, off_t pos);</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">返回读到的字节数，出错；返回-1</span><br><span class="line">到文件结尾，返回零</span><br><span class="line"></span><br><span class="line">由于lseek和read调用之间，内核可能会临时挂起进程，所以对同步问题造成了问题，调用</span><br><span class="line">pread函数相当于调用了lseek和read,这两个操作相当于捆绑的原子操作</span><br><span class="line"></span><br><span class="line">调用pread时，无法中断其定位和读操作，另外不更新文件指针</span><br></pre></td></tr></table></figure><h6 id="pwrite"><a href="#pwrite" class="headerlink" title="pwrite"></a>pwrite</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">函数说明</span><br><span class="line">在给定的偏移量写入一个文件描述符</span><br><span class="line">ssize_t pwrite(int fd, const void *buf, size_t count, off_t pos);</span><br><span class="line"></span><br><span class="line">返回值</span><br><span class="line">返回已写的字节数；出错返回-1</span><br><span class="line">由于lseek和write调用之间内核可能会临时挂起进程，所以读同步问题造成了问题，调用pwrite相当于顺序调用了lseek和write函数，这两个相当于一个捆绑的原子操作</span><br><span class="line">调用pwrite函数时，无法中断其定位和读操作，另外不更新文件指针</span><br></pre></td></tr></table></figure><h5 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h5><blockquote><p>Linux支持不同进程之间共享文件。内核使用的三种表（文件描述符表，文件表，索引节点表）之间的关系决定了在文件共享过程中一个进程对另一个进程产生的影响。  </p><ul><li>每个进程在进程表中有一个文件描述符表，每一个描述符表项指向一个文件表</li><li>内核为每一个被打开的文件维护一张文件表，文件表项包括:<code>文件的状态标志（读，写，同步，非阻塞）</code>，<code>文件当前位置</code>，<code>指向该文件索引节点表的指针</code></li><li>每个文件（或设备）都有一个索引节点，它包含了文件类型属性及文件数据</li></ul></blockquote><h6 id="不同进程打开同一文件"><a href="#不同进程打开同一文件" class="headerlink" title="不同进程打开同一文件"></a>不同进程打开同一文件</h6><blockquote><p><strong>如果两个进程分别打开了同一个文件(物理文件)，则它们有不同的文件表，因此每个进程有自己的文件当前位置，因此其读写操作互不影响。</strong>  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/6.png" width="300" height="200" alt="pic2" align="center"></p><h6 id="不同进程共享同一文件"><a href="#不同进程共享同一文件" class="headerlink" title="不同进程共享同一文件"></a>不同进程共享同一文件</h6><blockquote><p><strong>也存在不同进程共享同一个文件表（父子进程），或统一进程共享同一个文件表（dup操作）。此时两个进程对该文件的读写操作将基于同一个文件当前位置。</strong>  </p></blockquote><p> <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/7.png" width="300" height="200" alt="pic2" align="center"></p><h6 id="同一进程共享相同文件"><a href="#同一进程共享相同文件" class="headerlink" title="同一进程共享相同文件"></a>同一进程共享相同文件</h6><blockquote><p>同一个进程用open函数打开一个文件两次，那么会有两张不同的文件表和不同的文件描述符。后一种读写会覆盖前一种读写的内容。</p></blockquote><p> <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/8.png" width="300" height="200" alt="pic2" align="center"></p><h6 id="dup和dup2"><a href="#dup和dup2" class="headerlink" title="dup和dup2"></a>dup和dup2</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unistd.h</span><br><span class="line"></span><br><span class="line">int dup(int oldfd);</span><br><span class="line">int dup2(int oldfd, int targetfd);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">复制一个文件的描述符，dup2函数跟dup函数相似，但是dup2函数允许调用者规定一个有效描述符和目标描述符</span><br><span class="line">sample.c：</span><br><span class="line"></span><br><span class="line">int fd1, fd2;</span><br><span class="line">int oldfd; </span><br><span class="line">oldfd = open(&quot;app_log&quot;, (O_RDWR|O_CREATE), 0644);</span><br><span class="line">fd2 = dup(fd1);</span><br><span class="line">dup2(oldfd, 1);</span><br><span class="line">close(oldfd);</span><br></pre></td></tr></table></figure><p> <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/9.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="进程间文件描述符的传递"><a href="#进程间文件描述符的传递" class="headerlink" title="进程间文件描述符的传递"></a>进程间文件描述符的传递</h5><ul><li>传递描述符的函数的参数是fd，fd是打开文件指针在数组中的下表</li><li>将一个文件描述符传递给另一个进程后，文件的“访问计数”会增加</li><li>进程间传递文件描述符可以看做跨进程的dup调用，也就是同一个file对象在不同进程间的映射</li><li>对于网络接口返回的描述符，只能采取传递文件描述符的方法</li><li>进程间传递文件描述符时，发送进程和接受进程共享同一个文件表项</li><li>进程间文件描述符的传递，只是通过将内核接收文件的一个新file指针指向和发动进程的同一个file对象，并使这个file对象的引用计数增加</li></ul><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/10.png" width="300" height="200" alt="pic2" align="center"></p><h6 id="线程共享文件"><a href="#线程共享文件" class="headerlink" title="线程共享文件"></a>线程共享文件</h6><blockquote><p>应用程序可以通过一个统一的clone()系统调用接口，用不同的参数指定创建轻量级进程还是普通进程。</p><ul><li>clone()调用do_fork()创建线程，do_fork()参数为: (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND)<br><strong>CLONE_VM:</strong>do_fork()需要调用copy_mm()来设置task_struct中的mm和active_mm项，这两个mm_struct数据与进程所关联的内存空间相对应。如果do_Fork()时指定了CLONE_VM开关，copy_mm()将把新的task_struct中的mm和active设置为与current的相同，同时提高该mm_struct的使用者数目(mm_struct::mm_users)。也就是说轻量级进程与父进程共享内存地址空间。<br><strong>CLONE_FS:</strong>task_struct中利用fs(struct fs_struct <em>)记录了进程所在文件系统的根目录和当前目录信息，do_fork()时调用copy_fs()复制了这个结构，对于轻量级进程则增加fs-&gt;count计数，与父进程共享相同的fs_struct。也就是说，轻量级进程没有独立的文件系统相关的信息，进程中任何一个线程改变当前目录，根目录等信息将直接影响到其他线程。<br><strong>CLONE_FILES:</strong>一个进程可能打开了一些文件，在进程结构task_struct中利用files(struct files_struct </em>)来保存进程打开的文件结构(struct file)信息，do_fork()中调用了copy_files()来处理这个进程属性，轻量级进程与父进程是共享结构的，copy_files()时进增加files-&gt;count计数。这一共享使得任何线程都能访问进程所维护的打开文件，对他们的操作会直接反应到进程中的其他线程。<br><strong>CLONE_SIGHAND:</strong>每一个Linux进程都可以自行定义对信号的处理方式，在task_struct中的sig(struct signal_struct)中使用一个struct k_sigaction结构的数组来保存这个配置信息。do_fork()中的copy_sighand()负责复制该信息；轻量级进程不进行复制，而仅仅增加signal_struct::count计数，与父进程共享该结构。也就是说子进程与父进程的信号处理方式完全相同，而且可以相互更改。<br><strong>总结:线程间的所有文件结构都为共享文件，不但“文件表项”(file对象)是共享的，就连“文件描述符”(files_struct)也是共享的。线程的创建仅仅增加的是files和fs的引用计数，“文件打开数”(files对象的引用计数)并没有增加，所以任何一个线程对打开的文件执行close操作，文件都讲关闭(文件打开计数为1的情况)。但是如果线程不进行打开文件的关闭，则文件直到进程结束时才会关闭，这就是使用多线程实现tcp服务时，服务线程必须要显示调用close的原因。否则永远不会发送FIN终止链接(因为主线程一直处于监听不会结束)</strong>  </li></ul></blockquote><h4 id="Linux目录操作"><a href="#Linux目录操作" class="headerlink" title="Linux目录操作"></a>Linux目录操作</h4><blockquote><p>我们看一下简单的目录操作<code>ls</code>的实现:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/11.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd"></a>getcwd</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">getcwd函数说明</span><br><span class="line">将当前的工作目录绝对路径字符串复制到参数buf所指的缓冲区，参数size为buf缓冲区大小</span><br><span class="line">返回值</span><br><span class="line">成功调用返回指向buf的指针，失败返回NULL</span><br><span class="line">#define MAX_SIZE 255</span><br><span class="line">char path(MAX_SIZE);</span><br><span class="line">getcwd(path, sizeof(path));</span><br><span class="line">puts(path);</span><br><span class="line"></span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">char* get_current_dir_name(void);</span><br><span class="line">函数说明</span><br><span class="line">调用后会返回一个字符串指针，指向当前工作目录绝对路径字符串</span><br><span class="line">返回值</span><br><span class="line">成功返回字符串指针，失败则返回空，错误代码存放于errno中</span><br></pre></td></tr></table></figure><h5 id="opendir"><a href="#opendir" class="headerlink" title="opendir"></a>opendir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt; </span><br><span class="line">#include&lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">打开参数name指定的目录</span><br><span class="line">返回值</span><br><span class="line">成功则返回DIR形态的目录流，失败则返回空。错误代码存放于errno中</span><br><span class="line">错误代码</span><br><span class="line">EACCESS，代表权限不足，也就是对这个目录没有执行权限</span><br><span class="line">EMFILE表示目前同时打开这个文件的进程数目已经达到了系统上限</span><br><span class="line">ENFILE代表已经达到系统可以同时打开的文件数上限</span><br><span class="line">ENOTDIR代表参数name指向的不是一个真正的目录</span><br><span class="line">EOENT表示参数name指向的目录不存在，或者参数name是一个空的字符串</span><br><span class="line">ENOMEM表示核心内存不足</span><br></pre></td></tr></table></figure><h5 id="closedir"><a href="#closedir" class="headerlink" title="closedir"></a>closedir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;dirent.h&gt;</span><br><span class="line">int closedir(DIR *dir);</span><br><span class="line">函数说明</span><br><span class="line">关闭参数dir指定的目录</span><br><span class="line">返回值</span><br><span class="line">关闭成功就返回零，失败的话返回-1.错误原因存在于errno中</span><br><span class="line">错误代码</span><br><span class="line">EBADF，代表参数dir是一个无效的目录流</span><br></pre></td></tr></table></figure><h5 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">struct dirent readdir(DIR *dirp);</span><br><span class="line">函数说明</span><br><span class="line">读取目标流dir标的目录</span><br><span class="line">返回值</span><br><span class="line">每执行一次readdir，这个函数返回指向当前读取目录项结构的指针，有错误发生或读取到目录文件尾的时候就返回NULL</span><br><span class="line">错误代码</span><br><span class="line">EBADF 代表参数dir是一个无效的目录流</span><br></pre></td></tr></table></figure><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/sta.h&gt;</span><br><span class="line">int mkdir(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">以mode方式创建一个以参数pathname命名的目录，mode定义新创建目录的权限</span><br><span class="line">返回值</span><br><span class="line">若目录创建成功返回0，否则返回-1；并将错误记录到全局变量errno中</span><br><span class="line">注意事项</span><br><span class="line">创建775权限的目录，需要先执行umask(0)，然后在调用mkdir函数</span><br></pre></td></tr></table></figure><h5 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int rmdir(const char *pathname);</span><br><span class="line">函数说明</span><br><span class="line">删除一个目录，该目录必须是空的</span><br><span class="line">返回值</span><br><span class="line">若目录删除成功，则返回0；否则返回-1，并将错误记录到去全局变量errno中</span><br><span class="line">注意事项</span><br><span class="line">pathname不能超过255，不能以“.”开头，目录没有被其他目录占用</span><br></pre></td></tr></table></figure><h5 id="chdir"><a href="#chdir" class="headerlink" title="chdir"></a>chdir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int chdir(const char* path);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">chdir函数用于改变当前工作目录，调用参数是指向目录的指针，调用进程需要有搜索整个目录的权限</span><br><span class="line">返回值</span><br><span class="line">成功返回零；失败返回-1；并将错误记录到全局变量errno中</span><br><span class="line">错误信息</span><br><span class="line">EFAULT:path指向了非法地址</span><br><span class="line">ENAMTTOOLNG:路径过长</span><br><span class="line">ENOENT:文件不存在</span><br><span class="line">ENOMEM:内核内存不足</span><br><span class="line">ENOTDIR:给出路径不是目录</span><br><span class="line">EACCES:无法访问某个目录的权限</span><br><span class="line">ELOOP:解析路径中太多的符号链接</span><br><span class="line">EIO:发生I/O错误</span><br></pre></td></tr></table></figure><h5 id="rewinddir"><a href="#rewinddir" class="headerlink" title="rewinddir"></a>rewinddir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/tyoes.h&gt;</span><br><span class="line">#nclude&lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">void rewinddir(DIR *dir);</span><br><span class="line"></span><br><span class="line">函数说明:</span><br><span class="line">设置参数dir指向的目录目前的读取位置为原开头的读取位置</span><br><span class="line">返回值</span><br><span class="line">无返回值，函数执行失败之后会将错误记录到全局变量errno中</span><br><span class="line">错误信息</span><br><span class="line">EBADF表示dir指向的目录流无效</span><br></pre></td></tr></table></figure><h5 id="seekdir"><a href="#seekdir" class="headerlink" title="seekdir"></a>seekdir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">void seekdir(DIR *dir, off_t offset);</span><br><span class="line">函数说明</span><br><span class="line">设置参数dir指向的目录流目前的读取位置为offset，在调用readdir()时便从此新位置开始读取，参数offset代表距离目录文件开头的偏移量</span><br><span class="line">返回值</span><br><span class="line">无返回值，函数执行失败后会将错误记录到全局变量errno中</span><br><span class="line">错误信息</span><br><span class="line">EBADF 表示dir指向的目录流无效</span><br></pre></td></tr></table></figure><h5 id="telldir"><a href="#telldir" class="headerlink" title="telldir"></a>telldir</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;dirent.h&gt;</span><br><span class="line">off_t telldit(DIR *dir);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">取得目录流dir读取位置</span><br><span class="line">返回值</span><br><span class="line">返回参数目录流目前的读取位置，此返回值代表距离目录文件开头的偏移量，有错误发生时返回-1</span><br><span class="line">错误参数</span><br><span class="line">EBADF 表示dir指向的目录流无效</span><br></pre></td></tr></table></figure><h4 id="Linux文件属性管理"><a href="#Linux文件属性管理" class="headerlink" title="Linux文件属性管理"></a>Linux文件属性管理</h4><h5 id="设置文件属性"><a href="#设置文件属性" class="headerlink" title="设置文件属性"></a>设置文件属性</h5><blockquote><p>Linux系统中常见的文件类型由: </p><ul><li>普通文件： 包含了某种形式的数据</li><li>目录文件： 包含了其他文件的名字以及指向与这些文件有关信息的指针</li><li>字符特殊文件： 提供对设备不带缓冲的访问</li><li>块特殊文件： 提供对设备带缓冲的访问</li><li>FIFO文件： 用于进程间的通信，命名管道</li><li>套接字文件： 用于网络通信</li><li>符号链接: 是文件指向另一个文件<br>下面是描述Linux文件系统属性的重要数据结构: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct stat&#123;</span><br><span class="line">mode_t st_mode; //文件类型和访问权限</span><br><span class="line">/*</span><br><span class="line">不同类型的文件</span><br><span class="line">S_ISREG() 普通文件</span><br><span class="line">S_ISDIR() 目录文件</span><br><span class="line">S_ISCHR() 字符特殊文件</span><br><span class="line">S_ISBLK() 块特殊文件</span><br><span class="line">S_ISFIFO()  管道或FIFO</span><br><span class="line">S_ISLINK()  符号链接</span><br><span class="line">S_ISSOCK() 套接字</span><br><span class="line">*/</span><br><span class="line">ino_t st_ino; //i节点号</span><br><span class="line">dev_t st_dev; //文件的主，次设备号信息</span><br><span class="line">dev_t st_rdev; //设备文件的设备号</span><br><span class="line">nlink_t st_nlink;  //文件的硬链接数</span><br><span class="line">uid_t st_uid;   //文件所有者用户ID</span><br><span class="line">gid_t st_gid;    //文件所有组ID</span><br><span class="line">off_t st_size;   //文件大小（以字节为单位）</span><br><span class="line">time_t st_atime   //最后一次访问该文件的时间</span><br><span class="line">time_t st_mtime; //最后一次修改该文件时间</span><br><span class="line">time_t st_ctime;   //最后一次改变该文件状态的时间</span><br><span class="line">blksize_t st_blksize; //包含该文件的磁盘快的大小</span><br><span class="line">blkcnt_t st_blocks;    //该文件所占的磁盘块数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h6 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h6><blockquote><p>其中最重要的一个数据结构是<code>st_mode</code>，一个无符号整数。只是用其低16位。从低到高分别为:<code>其他用户权限</code>，<code>组权限</code>，<code>所有者权限</code>,<code>文件特殊属性</code>和<code>文件类型</code>。见下图:  </p></blockquote><p> <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/12.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>高三位分别是<strong>黏着位</strong>,<strong>设置组ID</strong>和<strong>设置用户ID</strong>位。若<strong>设置用户ID位</strong>被设置，<strong>表示执行该文件时候进程的有效用户ID变成文件的所有者。</strong>设置组ID类似。<br>可以通过命令行设置用户ID为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s filename; chmod u-s filename;</span><br><span class="line">chmod g+s filename; chmod u-s filename;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>若文件所有者是超级用户，且设置了设置用户ID位，则执行此文件的进程拥有了超级用户权限。<br>Passwd（1）允许任一用户改变其口令，该程序是一个设置用户ID程序。分别用常量<code>S_ISUID</code>和<code>S_ISGID</code>测试。<br>如果一个目录设置了黏着位，那只有对该目录具有写许可权限的用户并且满足下列条件之一，才能删除或更名该目录下的文件:</p><ul><li>拥有此文件</li><li>是超级用户</li></ul></blockquote><h6 id="文件时间"><a href="#文件时间" class="headerlink" title="文件时间"></a>文件时间</h6><blockquote><p>每个文件都有三个时间:</p></blockquote><p> <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/13.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>对文件进行一次读操作，它的访问时间就会变；<br>修改时间是文件最后一次被修改的时间。<br>状态时间是<strong>该文件索引节点</strong>最后一次被修改的时间。而影响索引节点的操作有:  </p><ul><li>更改文件访问权限</li><li>更改文件用户ID</li><li>更改文件链接数</li></ul></blockquote><h6 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h6><blockquote><p><code>st_size</code>包含了以字节为单位的该文件的长度，此字段只对普通文件，目录和链接文件有用。</p></blockquote><h6 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h6><blockquote><p>每个文件系统所在的存储设备都是由其主<code>st_dev</code>，次设备号<code>st_rdev</code>表示。设备号所用的数据结构是基本系统数据类型<code>dev_t</code>；<br>主设备号表示设备驱动程序，次设备号标识特定的子设备。<br>通常可以使用两个宏定义<code>major</code>和<code>minor</code>来访问主次设备号。</p></blockquote><h5 id="文件属性操作相关函数"><a href="#文件属性操作相关函数" class="headerlink" title="文件属性操作相关函数"></a>文件属性操作相关函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int stat(const char *path, struct stat *buf);</span><br><span class="line">int lstat(const char *path, struct stat *buf);</span><br><span class="line">int fstat(int fileds, struct stat *buf);</span><br><span class="line">int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flags);</span><br><span class="line"></span><br><span class="line">函数说明</span><br><span class="line">stat和lstat参数相同，功能类似；读取path参数指定文件的文件属性并将其填充到buf参数所指向的结构体中； 对于符号链接文件, lstat返回符号链接的文件属性，stat返回符号链接引用文件的文件属性；</span><br><span class="line">fstat与前两个函数功能类似，指定文件的方式改为通过文件描述符；</span><br><span class="line">fstatat函数为一个相对于当前打开目录（由fd参数指向）的路径名返回文件统计信息。</span><br><span class="line">四个函数中的buf都是指向stat结构体的指针，是与文件属性相关的重要结构体</span><br><span class="line"></span><br><span class="line">struct passwd *getpwuid(uid_t uid);</span><br><span class="line">函数说明输入用户ID，返回用户属性信息（passwd结构）</span><br><span class="line">struct passwd &#123;</span><br><span class="line">char *pw_name;  //用户名</span><br><span class="line">char *pw_passwd;  //密码</span><br><span class="line">_uid_t pw_uid;  //用户ID</span><br><span class="line">_gid_t pw_gid;   //组ID</span><br><span class="line">char *pw_gecos;   //真实名</span><br><span class="line">char *pw_dir;   //主目录</span><br><span class="line">char *pw_shell;  //使用的shell</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct passwd *getgrgid(gid_t gid);</span><br><span class="line">输入用户ID， 返回用户组属性信息</span><br><span class="line"></span><br><span class="line">int utime(const char * pathname, const struct utimbuf *times);</span><br><span class="line">设置存取和修改文件的时间</span><br><span class="line"></span><br><span class="line">int truncate(const char *pathname, off_t length);</span><br><span class="line">int ftruncate(int fd, off_t length);</span><br><span class="line">函数说明改变文件的长度</span><br></pre></td></tr></table></figure><h4 id="Linux文件权限管理"><a href="#Linux文件权限管理" class="headerlink" title="Linux文件权限管理"></a>Linux文件权限管理</h4><blockquote><p>权限是文件属性的一部分，<code>st_mode</code>是<code>stat</code>数据结构的一部分。<br>Linux系统是通过进程的<strong>有效用户ID</strong>和<strong>有效用户组ID</strong>来决定进程对系统资源的访问权限。<br>一个进程的用户ID有<strong>实际用户ID</strong>和<strong>有效用户ID</strong>两种，其中有效用户ID用于权限检查。通常情况下，有效用户ID等于实际用户ID。在可执行文件的权限位中有两位“设置用户ID”和“设置用户组ID”用来改变文件的权限。对于文件/目录的访问权限都是读/写/执行三种。</p></blockquote><h5 id="文件权限检查及相关函数"><a href="#文件权限检查及相关函数" class="headerlink" title="文件权限检查及相关函数"></a>文件权限检查及相关函数</h5><blockquote><p>进程访问文件时，内核就进行文件权限检查。这种检查涉及到文件的所有者，文件的所有者所在组，进程有效用户，进程的有效组及进程的附加组。<strong>两个所有者都是文件的性质，而有效用户与有效组是进程的性质。</strong><br>当进程对某个文件进行操作时，内核按照顺序执行下列步骤来检查文件权限: </p><ul><li>若进程的有效用户为root(ID=0)，则允许任何操作</li><li>若进程的有效用户等于文件的所有者（ID相同）（即该进程拥有文件），按照文件所有者具有的权限判定操作是否合法</li><li>若进程的有效组或进程的附加组之一等于文件的所有者所有组，按照文件所有者所在组具有的权限判定操作是否合法</li><li>按照其他用户具有权限判定操作是否合法<br>而对于新文件和新目录，系统将其所有者设置为进程的有效用户。</li></ul></blockquote><h6 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">按照前述问价权限检查的4个步骤测试存取文件是否具有相应权限</span><br><span class="line">int access(const char *pathname, int mode);</span><br><span class="line">Mode: </span><br><span class="line">R_OK 测试读许可权 </span><br><span class="line">W_OK 测试写许可权</span><br><span class="line">X_OK 测试执行许可权</span><br><span class="line">F_OK 测试文件是否存在</span><br></pre></td></tr></table></figure><h6 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int chmod(const char* pathname, mode_t mode);  //chmod针对文件或目录</span><br><span class="line">int fchmode(int fd, mode_t mode);   //fchmod主要针对文件</span><br><span class="line">函数说明</span><br><span class="line">改变指定文件的权限位</span><br><span class="line">修改时，进程的有效用户ID必须为文件的所有者ID，或者是root运行的此进程</span><br></pre></td></tr></table></figure><h6 id="更改文件所有者"><a href="#更改文件所有者" class="headerlink" title="更改文件所有者"></a>更改文件所有者</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int chown(const char *pathname, uid owner, gid_t group);</span><br><span class="line">int fchown(int filedes, uid_t owner, gid_t group);</span><br><span class="line">int lchown(const char *pathname, uid_t owner, gid_t group);</span><br><span class="line"></span><br><span class="line">函数用途</span><br><span class="line">更改文件的用户ID和组ID，成功返回零，出错返回-1</span><br></pre></td></tr></table></figure><h6 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int link(const char *pathname, const char* newpath);</span><br><span class="line">函数用途</span><br><span class="line">任何一个文件可以有多个目录项指向其索引节点，创建一个指向现有问价的新目录项</span><br><span class="line">函数说明</span><br><span class="line">创建一个新目录项newpath,他指向pathname指向的文件。如果newpath已经存在，则返回出错</span><br><span class="line">创建新目录项以及增加连接计数是一个原子操作</span><br></pre></td></tr></table></figure><h6 id="unlink和remove"><a href="#unlink和remove" class="headerlink" title="unlink和remove"></a>unlink和remove</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int unlink(const char* pathname);  (unistd.h)</span><br><span class="line">int remove(const char* pathname);   (stdio.h)</span><br><span class="line"></span><br><span class="line">函数用途</span><br><span class="line">unlink删除目录项，并将由pathname所引用文件的链接计数减一</span><br><span class="line">remove删除一个目录中的一个或多个文件或目录，也可以将某个目录及其他的所有文件及子目录均删除</span><br></pre></td></tr></table></figure><h6 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rename(const char *oldname, const char *newname);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;总结性质。&lt;br&gt;为了6.828的Lab3能够更好的进行下去，花几天时间总结一下和Linux多线程编程相关的知识点。主要有:&lt;strong&gt;基础知识&lt;/strong&gt;，&lt;strong&gt;文件与目录操作&lt;/strong&gt;，&lt;strong&gt;线程和进程&lt;/strong&gt;以及&lt;strong&gt;线程同步和进程间通信机制&lt;/strong&gt;四个大块。博客总结为&lt;strong&gt;文件系统&lt;/strong&gt;和&lt;strong&gt;进程/线程&lt;/strong&gt;两部分。&lt;br&gt;下图为操作系统程序员眼中Linux的基本编程架构:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/多线程编程/1.png&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;pic2&quot; align=&quot;center&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
      <category term="C" scheme="http://haotianmcihael.github.io/tags/C/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Xv6 CPU Alarm</title>
    <link href="http://haotianmcihael.github.io/2018/12/08/Mit6-828-Fall-2018-Xv6-CPU-Alarm/"/>
    <id>http://haotianmcihael.github.io/2018/12/08/Mit6-828-Fall-2018-Xv6-CPU-Alarm/</id>
    <published>2018-12-08T08:19:21.000Z</published>
    <updated>2018-12-08T00:23:02.261Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Lazy Page Allocation</title>
    <link href="http://haotianmcihael.github.io/2018/12/08/Mit6-828-Fall-2018-Lazy-Page-Allocation/"/>
    <id>http://haotianmcihael.github.io/2018/12/08/Mit6-828-Fall-2018-Lazy-Page-Allocation/</id>
    <published>2018-12-08T08:19:20.000Z</published>
    <updated>2018-12-08T00:23:10.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HW-Lazy-Page-Allocation"><a href="#HW-Lazy-Page-Allocation" class="headerlink" title="HW:Lazy Page Allocation"></a>HW:Lazy Page Allocation</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HW-Lazy-Page-Allocation&quot;&gt;&lt;a href=&quot;#HW-Lazy-Page-Allocation&quot; class=&quot;headerlink&quot; title=&quot;HW:Lazy Page Allocation&quot;&gt;&lt;/a&gt;HW:Lazy Page Allo
      
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="OS - Shell" scheme="http://haotianmcihael.github.io/tags/OS-Shell/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) System Calls</title>
    <link href="http://haotianmcihael.github.io/2018/12/08/Mit6-828-Fall-2018-System-Calls/"/>
    <id>http://haotianmcihael.github.io/2018/12/08/Mit6-828-Fall-2018-System-Calls/</id>
    <published>2018-12-08T08:19:19.000Z</published>
    <updated>2018-12-09T02:15:34.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HW-System-Calls"><a href="#HW-System-Calls" class="headerlink" title="HW: System Calls"></a>HW: System Calls</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HW-System-Calls&quot;&gt;&lt;a href=&quot;#HW-System-Calls&quot; class=&quot;headerlink&quot; title=&quot;HW: System Calls&quot;&gt;&lt;/a&gt;HW: System Calls&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
      <category term="C" scheme="http://haotianmcihael.github.io/tags/C/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="Shell" scheme="http://haotianmcihael.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Lab2</title>
    <link href="http://haotianmcihael.github.io/2018/11/22/Mit6-828-Fall-2018-Lab2/"/>
    <id>http://haotianmcihael.github.io/2018/11/22/Mit6-828-Fall-2018-Lab2/</id>
    <published>2018-11-21T20:51:42.000Z</published>
    <updated>2018-12-14T01:17:08.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><h3 id="Before-Lab"><a href="#Before-Lab" class="headerlink" title="Before Lab"></a>Before Lab</h3><blockquote><p>Lab2的主要内容:<code>Physical Page Management</code>,<code>Virtual Memroy</code>,<code>Kernel Address Space</code>;<strong>代码实现JOS中的内存分页管理功能，有页面管理和页表管理两部分。</strong>和理论相比，代码实现需要考虑的细节真是太多。实验最终的目的是通过几个检测函数:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/1.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>Lab1完成时整个JOS内存布局如下图:</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/9.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>切换合并Git分支的时候可能会出现冲突，需要手动注释掉Lab1中的一些测试代码来解决，这里不再赘述。<br><a id="more"></a></p></blockquote><h3 id="memlayout-h和pmap-h"><a href="#memlayout-h和pmap-h" class="headerlink" title="memlayout.h和pmap.h"></a>memlayout.h和pmap.h</h3><blockquote><p>掌握这两个文件中的函数是完成Lab2必不可少的条件，在此进行总结。  </p></blockquote><h4 id="pmap-h"><a href="#pmap-h" class="headerlink" title="pmap.h"></a>pmap.h</h4><blockquote><p>Lab2中需要重点关注的对象有三个:物理内存，虚拟内存，空闲链表<strong><code>struct PageInfo</code></strong>。该头文件中的函数实现了三者之间的相互转化。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/2.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>另外还有几个外部变量也需要重点关注一下: </p><ul><li><code>bootstack</code> 内核栈</li><li><code>pages</code> 所有物理内存按照4KB划分的对应映射数组</li><li><code>npage</code> 数组元素个数</li><li><code>kern_pgdir</code> 页目录<br><strong>注意pages不是空闲链表，仅仅只是一个数组而已。而pages数组索引就是所有页式物理内存的索引。</strong>所以<code>struct PageInfo *pp</code>和物理内存关系很紧密：<strong>(pp-pages)*4KB就是该数组元素对应的物理页面page的物理地址</strong>，这也是<code>page2pa</code>函数的原型。</li></ul></blockquote><h4 id="memlayout-h"><a href="#memlayout-h" class="headerlink" title="memlayout.h"></a>memlayout.h</h4><blockquote><p>介绍了JOS虚拟内存的详细布局，定义了所有需要使用的宏。<strong>在Lab2中，我们需要完成的是内核部分虚拟地址到物理的映射。所以重点关注的是UTOP之上的布局.</strong>当然需要注意的细节就很多了，比如大小，权限，每一部分内存的作用等。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/3.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>上图只是一个简化图，结合源码看会好很多，比如一些和大小有关的宏定义: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define PGSIZE          4096            // bytes mapped by a page</span><br><span class="line">#define KSTKSIZE        (8*PGSIZE)              // size of a kernel stack</span><br><span class="line">#define PTSIZE          (PGSIZE*NPTENTRIES) // bytes mapped by a page directory entry</span><br><span class="line">#define NPTENTRIES      1024            // page table entries per page table</span><br></pre></td></tr></table></figure><blockquote><p>其中阴影部分指的是<code>page_init()</code>函数之前已经初始化好的。这是因为在<code>page_init()</code>函数之前分页机制还没有建立好，所以只能用字节分配的方法分配物理内存。这些阴影部分的物理内存都是<code>boot_alloc(uing32_t n)</code>函数分配的；而<code>page_init()</code>函数之后，所有的物理内存分配都是以页<strong>Page</strong>为单位，所以字节分配函数<code>boot_alloc()</code>也被禁用了。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>我觉得整个Lab2就是在实现两种映射：<strong>物理内存到空闲链表的映射</strong>和<strong>虚拟内存到物理内存的映射</strong>。而上述的两个头文件基本讲清楚了映射需要实现的步骤和原理，应该反复阅读。初此之外还应该对C语言的<strong>强转</strong>，<strong>指针</strong>，<strong>位运算</strong>有一个很深的了解，最好先看一下TCPL。</p></blockquote><h3 id="Physical-Page-Management"><a href="#Physical-Page-Management" class="headerlink" title="Physical Page Management"></a>Physical Page Management</h3><blockquote><p>理论课很大的一部分缺失就是没有对物理内存布局进行讲解。而没有物理内存的基础，映射（Mapping）根本无从谈起。页面管理分析如下:<br>从代码角度看，Lab2接上Lab1中<code>kern/entry.S</code>跳转到<code>kern/init.c</code>中的<code>i386_init()</code>开始执行。可以发现<code>mem_init()</code>函数，整个Lab2就是完善这个内存函数的过程。而第一部分物理内存就是完成将物理内存映射到空闲链表上。<br>PartOne需要<strong>完成物理内存的管理，并实现物理内存的布局。</strong>这里的布局指的是对空闲链表的管理。所以<strong>我们首先要创建空闲链表，然后用空闲链表对这一整块物理内存进行管理，当然管理的单位是Page（4K）</strong>。<br>基本上需要实现的代码都在<code>pmap.c</code>中。我们用Taglist统筹一下该文件中所有的函数和宏定义: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/4.png" width="300" height="200" alt="pic2" align="center">  </p><h4 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc"></a>boot_alloc</h4><blockquote><p>彼时<code>mem_init()</code>函数中还只有一个函数————<code>i386_detect_memory()</code>。用来检测物理内存的硬件状态及其参数，其中有几个比较重要的变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npages: 未分配</span><br><span class="line">npages_basemem: 160</span><br><span class="line">kern_pgdir: 未分配</span><br><span class="line">basemem: 640KB</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>其中<code>basemem=640K</code>是因为在<code>inc/memlayout.h</code>中定义过一个宏:<code>#define IOPHYSMEM 0xA0000</code>。在Lab1的内存布局中有详细的分布，在这个宏定义的地址往上是 实模式下IDT和第一部分bootsector。所以将宏定义以下到<code>0x00000000</code>的内存称为base_mem。而这部分需要被映射到空闲链表中，所以按照页式单位可以映射640K/4K=160个pages。<br>接下来就是实现代码。因为代码太多不打算贴出来，主要是做Lab的思路并分享一些完善内存布局过程中画的草稿。<br>从<code>mem_init()</code>的进度来看，首先需要实现<code>boot_alloc()</code>函数，然后用该函数直接分配物理内存给<code>kern_pgdir</code>和<code>pages</code>两个数据结构。而<code>boot_alloc</code>中值得一提就是<code>extern char end[]</code>和对齐函数<code>ROUNDUP(a, n)</code>。<strong>在Lab1完成之后，我们将内核放到<code>0x10000000</code>这个位置直到<code>end</code>结束，所以<code>end</code>是链接器做链接时内核加载结束的地址。</strong>而<code>ROUNDUP(a, n)</code>的功能是向上对齐。因为我们的操作都是4KB对齐的，所以需要在<code>end</code>后面进行对齐操作。详细见Lab1的内存布局。<strong>最后函数返回的是已分配内存的虚拟首地址。</strong><br>指导书中推荐使用断言<strong>assert</strong>进行调试的方法。不过我一般使用输出调试<strong>cprintf+return</strong>。当分配好<code>kern_pgdir</code>和<code>pages</code>之后，我们使用输出调试看一下这两个数据结构的虚拟地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void boot_alloc() &#123;</span><br><span class="line">cprintf(&quot;before allocating nextfree is %x\n&quot;, nextfree);</span><br><span class="line">/*</span><br><span class="line">address allocator</span><br><span class="line">*/</span><br><span class="line">cprintf(&quot;after allocating nextfree is %x\n&quot;, nextfree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>看一下输出结果: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/5.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>然后就是实现<code>page_init()</code>函数。<strong>此时我们已经建立了一个和全部物理内存相对应的数组pages</strong>。这为接下来空闲链表的实现奠定了基础:<strong><code>page_init()</code>函数就是按照Hints中提示的物理内存的基本布局，找到那些空闲的物理内存并将其对应的pages数组元素链接起来形成一个链表。</strong>可能不好理解，直接上图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/6.jpeg" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>这个功能是由下面简单的几句C语言实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Part of the code:</span><br><span class="line"></span><br><span class="line"> for (i = 1; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">                pages[i].pp_ref = 0;</span><br><span class="line">                pages[i].pp_link = page_free_list;</span><br><span class="line">                page_free_list = &amp;pages[i];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><code>page_init</code>函数实现了空闲链表。至此内存的布局已经很清楚了：  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/8.jpeg" width="300" height="200" alt="pic2" align="center">  </p><h4 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc"></a>page_alloc</h4><blockquote><p><code>page_alloc</code>函数实现物理内存的页式分配————分配一页空闲的物理内存。根据上面的思路:<strong>pages数组就是全部物理内存的映射，而page_free_list是空闲物理内存的映射所以是部分pages元素链成的。</strong>所以我们实际上可以通过<code>page_free_list</code>指针来确定具体的物理地址:<strong>(page_free_list-pages)*4K</strong>。<br>实现很简单，当中需要注意的细节初始化函数<code>memset(void *v, int c, size_t n)</code>中需要的地址是虚拟地址。这里先参考一下<code>kern_pgdir</code>的实现和初始化。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/7.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>所以在实现中<strong>需要将page_free_list指向的pages元素映射到具体的物理地址<code>page2pa</code>, 然后将物理地址转化为虚拟地址<code>PADDR</code></strong>并返回。</p></blockquote><h4 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h4><blockquote><p>至此物理映射到空闲链表的过程已经实现。<code>boot_alloc</code>和<code>page_alloc</code>最终返回的都是<strong>虚拟地址</strong>。还有一些宏定义和函数比如<code>PGNUM(la)</code>，<code>memset(void *v, int c, size_t n)</code>的参数也是虚拟地址。在Lab2中一个核心问题就是区分<strong>物理地址</strong>还是<strong>虚拟地址</strong>。<br>因为mmu的缘故，访问内存的时候会进行一次线性地址到物理地址的转换。所不能直接使用物理地址。<strong>我们索性所有自定义用到地址的地方都使用虚拟地址，如果需要物理地址再使用<code>PADDR(la)</code>转化。</strong></p></blockquote><h3 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h3><h4 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h4><blockquote><p>首先区分<strong>逻辑地址</strong>，<strong>线性地址</strong>和<strong>物理地址</strong>的概念。Lab2屏蔽了逻辑地址到线性地址的转化，也就是GDT段式存储管理。直接从线性地址开始。<br>指导书中重点讲解了虚拟内存，物理内存和指针这几个概念。觉得有一些意思，就把翻译贴上了:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/10.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>另外，在之后的Lab中会遇到很多<strong>一个物理页面同时被映射到好几块虚拟内存中</strong>的情况。JOS使用<code>struct PageInfo-&gt;pp_ref</code>来管理页目录对页表页的引用的数量。见下面代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mystery_t x;</span><br><span class="line">char* value = return_a_pointer();</span><br><span class="line">*value = 10;</span><br><span class="line">x = (mystery_t) value;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>根据上面的分析，指针<code>value</code>是虚拟地址。而对value进行强转并赋值的只能是虚拟地址了。</p></blockquote><h4 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk"></a>pgdir_walk</h4><blockquote><p>在实现下面的代码之前，默认熟悉<code>inc/mmu.h</code>中的所有内容。<br>该函数的作用很关键。<strong>给定一个虚拟地址，pgdir_walk函数返回一个指向该地址对应页表项的指针。而这个函数主要是为完成一部分虚拟地址到一部分物理地址的映射函数<code>boot_map_region</code>做准备的。所以只需要定位到页表项就可以，而不需要加上后12位偏移量。</strong>JOS的页目录（表）项<strong>PDE&amp;PTE</strong>的格式见下:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/11.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>该函数的分析如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pte_t *</span><br><span class="line">pgdir_walk(pde_t *pgdir, const void *va, int create)</span><br><span class="line">&#123;</span><br><span class="line">        uintptr_t ptIndex = PTX(va);    //PTX取出页表项的偏移量</span><br><span class="line">        struct  PageInfo * newAlloc;     //空闲链表指针</span><br><span class="line">        if(!(pgdir[PDX(va)] &amp; PTE_P)) &#123;   //&amp;位运算是取出PTE_P这一位，看页表是否存在</span><br><span class="line">                if(create) &#123;</span><br><span class="line">                        if((newAlloc = page_alloc(1)) == NULL)</span><br><span class="line">                                return NULL;</span><br><span class="line">                        newAlloc-&gt;pp_ref++;</span><br><span class="line">// |位运算是合并位； 【20】+【12】分别为页目录项（注意不是页表项）20位的地址，后12位的标志位</span><br><span class="line">                        pgdir[PDX(va)] = page2pa(newAlloc) | PTE_P | PTE_U | PTE_W;             </span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                        return NULL;</span><br><span class="line">                &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        pte_t * pdPtr = KADDR(PTE_ADDR(pgdir[PDX(va)])); //取出页目录项的前20位</span><br><span class="line">        return pdPtr + ptIndex;   //具体的指向具体页表项的指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>其中对页表项进行重新映射是关键的操作，便于理解还可以先取出前20位地址然后再加上标志位:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if(create) &#123;</span><br><span class="line">                        if((newAlloc = page_alloc(1)) == NULL)</span><br><span class="line">                                return NULL;</span><br><span class="line">                  newAlloc-&gt;pp_ref++;</span><br><span class="line">                      pgdir[PDX(va)] = page2pa(newAlloc);   </span><br><span class="line">                      test = KADDR(pgdir[PDX(va)]);   //先取出20位</span><br><span class="line">  pgdir[PDX(va)] = page2pa(newAlloc) | PTE_P | PTE_U | PTE_W;</span><br><span class="line">                      return test + ptIndex;//直接返回</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                        return NULL;</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>分页机制原理见下图，而<code>pgdir_walk</code>函数完成的是前两部分的，最后的<code>offset</code>并不在其中:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/12.png" width="300" height="200" alt="pic2" align="center">  </p><h4 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region"></a>boot_map_region</h4><blockquote><p>接上<code>pgdir_walk</code>函数返回虚拟地址相对应的页表项指针。注意该函数的参数中有一项是权限<code>perm</code>是和<code>PTE_P</code>一起的，一旦映射就存在了。因为是页表项所以是4KB对齐的（因为屏蔽掉后12位）。我们使用页表项完成虚地址到物理地址的映射:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">        for(i=0; i&lt;size/PGSIZE; i++, va+=PGSIZE, pa+=PGSIZE) &#123;  //4K 对齐</span><br><span class="line">                pte_t *pte = pgdir_walk(pgdir,(void*)va, 1);   </span><br><span class="line">                if(pte == NULL) panic(&quot;boot_map_region panic : out of memory!\n&quot;);</span><br><span class="line">                *pte = pa | perm | PTE_P;    //完成映射，并设置标志位来确定页表权限</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>后面几个函数实现都很简单，不再赘述。<br>至此，我们实现了内存页式管理的页表管理部分。</p></blockquote><h3 id="Kernel-Address-Space"><a href="#Kernel-Address-Space" class="headerlink" title="Kernel Address Space"></a>Kernel Address Space</h3><h4 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h4><blockquote><p>关于学习JOS对虚拟内存空间的整体布局。JOS是32位的操作系统，一共有4G的虚拟空间。<strong>以<code>ULIM</code>为分界线，界限以下为用户空间，以上为内核空间。</strong>其中从<code>ULIM</code>到<code>KERNBASE</code>部分作为内核的系统栈共4M空间。对于内存详细的布局可以从<code>inc/memlayout.h</code>中看到，这里的重点是因为内核和用户空间同时被映射到物理内存中，所以需要一种方式来避免两者之间相互读写。<strong>而且JOS和其他现代操作系统不同的是，整个OS只有一个页目录<code>kern_pgdir</code>（应该是每一个进程有一套完整的页表系统）。</strong><br>方法是权限位:</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/13.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>当一个程序试图访问一个虚拟地址的数据的时候，x86系统的保护机制运行为: </p><ul><li>先检查短权限位DPL，不过和页式分配无关</li><li>再检查页目录相应表项的访问权限，如果不过也产生异常</li><li>最后检查二级页表相应页表的访问权限，不够就产生异常<br>x86对权限的原则是<strong>不在页目录这一环节限制太多，让最终的访问控制在二级页表这一环节上在设置。</strong>实际上Intel手册上给出了一个页目录加页表的访问控制的组合控制效果:</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/15.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>实现<code>mem_init</code>函数的最后一部分内容，实现JOS的虚拟映射:<br>首先我们将虚拟地址中<strong>[UPAGES, sizeof(pages)]</strong>部分映射到物理地址<strong>[pages, sizeof(pages)]</strong>上。<br>然后我们将虚拟地址中<strong>[KSTACKTOP-KSTKSIZE, KSTACKTOP]</strong>部分映射到<strong>[bootstack, KSTKSIZE]</strong>上。<br>最后将<code>KERNBASE</code>以上的虚拟地址映射到所有物理地址上。<br>这里注意一下一个细节:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void mem_init() &#123;</span><br><span class="line">...</span><br><span class="line">// Permissions: kernel R, user R</span><br><span class="line">kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>这是在<code>mem_init</code>函数申请<code>kern_pgdir</code>之后就发生的映射，而这句代码本质上就是映射函数<code>boot_map_region</code>。目的很简单————<strong>完成<code>kern_pgdir</code>自身到<code>UVPT</code>的映射</strong>。我们不难明白，整个JOS只有一个页目录。Lab基本结束，这时候的JOS内存整体布局如下: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/14.png" width="300" height="200" alt="pic2" align="center">  </p><h4 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h4><blockquote><p>第一个问题上面刚回答过了，就是映射的细节问题。<br>在映射的时候设置了<code>PTE_U</code>的用户才有读写权限。<br>我们的<code>UPAGES</code>有4MB的空间，一个<code>struct PageInfo</code>大小8B。所以能管理的物理块为<strong>4MB/8*4KB = 2GB</strong>。<br>管理内存的开销一共有<strong>物理映射pages</strong>,<strong>页目录</strong>,<strong>页表</strong>。如果第三个问题成立也就是说物理内存最大一共有2G的话，那pages大小一共有2G/4K*8=4M。而页目录<code>kern_pgdir</code>一共有4KB大小；相应的页表是4MB。一共有8MB+4KB。</p></blockquote><h5 id="entry-S"><a href="#entry-S" class="headerlink" title="entry.S"></a>entry.S</h5><blockquote><p>这部分是在Lab1的时候遗留下来的问题，因为在系统刚启动的时候初始化过一个页目录<code>entry_pgdir</code>。关于细节可以参看<code>kern/entrypgdir.c</code>和<code>kern/entry.S</code>。这里介绍一些QEMU的新用法来进行调试（其实也在Lab2中是要求掌握的）: </p><ul><li><code>xp/Nx paddr</code> 输出从paddr物理地址开始的N个字节的值</li><li><code>info register</code> 输出当前寄存器的状态</li><li><code>info mem</code> 输出当前完成映射的虚拟地址和对应权限</li><li><code>info pg</code> 输出当前页表，页目录和页表项是分开的<br>其实我们从Lab1的时候已经调试过，<code>movl    %eax,%cr0</code>执行结束的时候<strong>打开分页机制</strong>。但是这次可以直接看到分页的结果和映射的结果还是很爽的，结合<code>kern/entrypgdir.c</code>来看一下便很容易回答最后一个问题: </li></ul></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/16.png" width="300" height="200" alt="pic2" align="center">  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// The entry.S page directory maps the first 4MB of physical memory</span><br><span class="line">// starting at virtual address KERNBASE (that is, it maps virtual</span><br><span class="line">// addresses [KERNBASE, KERNBASE+4MB) to physical addresses [0, 4MB)).</span><br><span class="line">// We choose 4MB because that&apos;s how much we can map with one page</span><br><span class="line">// table and it&apos;s enough to get us through early boot.  We also map</span><br><span class="line">// virtual addresses [0, 4MB) to physical addresses [0, 4MB); this</span><br><span class="line">// region is critical for a few instructions in entry.S and then we</span><br><span class="line">// never use it again.</span><br><span class="line">//</span><br><span class="line">// Page directories (and page tables), must start on a page boundary,</span><br><span class="line">// hence the &quot;__aligned__&quot; attribute.  Also, because of restrictions</span><br><span class="line">// related to linking and static initializers, we use &quot;x + PTE_P&quot;</span><br><span class="line">// here, rather than the more standard &quot;x | PTE_P&quot;.  Everywhere else</span><br><span class="line">// you should use &quot;|&quot; to combine flags.</span><br><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line">pde_t entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">        // Map VA&apos;s [0, 4MB) to PA&apos;s [0, 4MB)</span><br><span class="line">        [0]</span><br><span class="line">                = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">        // Map VA&apos;s [KERNBASE, KERNBASE+4MB) to PA&apos;s [0, 4MB)</span><br><span class="line">        [KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">                = ((uintptr_t)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>不难发现其实在<code>entry_pgdir</code>中已经完成了<code>0x00000000-0x00400000</code>到<code>0xf0000000-0xf0400000</code>和到<code>0x00000000-0x00400000</code>的映射。而实现映射的方式也是直接讲地址写到页表项<code>entry_pgdir</code>中。<br>通过调试，发现两次页目录的创建过程中，映射的地址都不一样: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/17.png" width="300" height="200" alt="pic2" align="center">  </p><blockquote><p>至此Lab2完成，Challenge时间关系不做了。这是<a href="https://github.com/haotianmichael/JOS" target="_blank" rel="noopener">源代码</a>.</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/18.png" width="300" height="200" alt="pic2" align="center">  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lab2&quot;&gt;&lt;a href=&quot;#Lab2&quot; class=&quot;headerlink&quot; title=&quot;Lab2&quot;&gt;&lt;/a&gt;Lab2&lt;/h2&gt;&lt;h3 id=&quot;Before-Lab&quot;&gt;&lt;a href=&quot;#Before-Lab&quot; class=&quot;headerlink&quot; title=&quot;Before Lab&quot;&gt;&lt;/a&gt;Before Lab&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Lab2的主要内容:&lt;code&gt;Physical Page Management&lt;/code&gt;,&lt;code&gt;Virtual Memroy&lt;/code&gt;,&lt;code&gt;Kernel Address Space&lt;/code&gt;;&lt;strong&gt;代码实现JOS中的内存分页管理功能，有页面管理和页表管理两部分。&lt;/strong&gt;和理论相比，代码实现需要考虑的细节真是太多。实验最终的目的是通过几个检测函数:  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/1.png&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;pic2&quot; align=&quot;center&quot;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lab1完成时整个JOS内存布局如下图:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828Lab2/9.png&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;pic2&quot; align=&quot;center&quot;&gt;  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;切换合并Git分支的时候可能会出现冲突，需要手动注释掉Lab1中的一些测试代码来解决，这里不再赘述。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
      <category term="C" scheme="http://haotianmcihael.github.io/tags/C/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Shell</title>
    <link href="http://haotianmcihael.github.io/2018/11/17/Mit6-828-Fall-2018-Shell/"/>
    <id>http://haotianmcihael.github.io/2018/11/17/Mit6-828-Fall-2018-Shell/</id>
    <published>2018-11-17T07:48:07.000Z</published>
    <updated>2018-12-09T11:38:22.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HW-Shell"><a href="#HW-Shell" class="headerlink" title="HW:Shell"></a>HW:Shell</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>6.828除了Lab之外还有针对小型操作系统XV-6的Readings和HomeWork。整个6.828也是围绕这两条线（Lab和HW）在走。Lab1让我适应了JOS的实验环境和调试技巧，但是Shell和System Calls才是真正属于操作系统的知识。关于XV-6的HomeWork都是建立在Readings基础之上的，本次HW<strong>需要实现一个小型的Shell</strong>，需要阅读的Readings有:    </p></blockquote><ul><li>XV-6.Chapter.0（重点资料）</li><li>man  fork, (3)exec，open， close</li><li>TCPL</li></ul><blockquote><p>学习过程中最有意思的当属斩获新技能和新工具了:)介绍一个新的vim插件神器————<a href="http://vim-taglist.sourceforge.net/manual.html#taglist-using" target="_blank" rel="noopener">Taglist</a>。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/27.png" width="300" height="200" alt="pic2" align="center"></p><a id="more"></a><blockquote><p>简单来讲，它以目录树的形式列出当前文件中的symbol:函数名，宏定义和变量。帮助我们从宏观上快速了解源码。本身支持跳转。安装manual中讲的很清楚，就不再赘述了。下面是我的配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;silent&gt; &lt;F8&gt; :TlistToggle&lt;CR&gt;&lt;CR&gt;   &quot;按f8开启Taglist</span><br><span class="line">let Tlist_Show_One_File=0                    </span><br><span class="line">let Tlist_Exit_OnlyWindow=1                  </span><br><span class="line">let Tlist_Use_Left_Window=1                 </span><br><span class="line">let Tlist_File_Fold_Auto_Close=1             </span><br><span class="line"></span><br><span class="line">     add the above Configs to your ~/.vimrc</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="操作系统调用——System-Calls"><a href="#操作系统调用——System-Calls" class="headerlink" title="操作系统调用——System Calls"></a>操作系统调用——System Calls</h3><blockquote><p>操作系统的工作总结起来就是<strong>抽象</strong>和<strong>资源分配</strong>。<br>资源有内存分配，CPU调度等。而抽象指的就是系统调用。实验需要实现Shell中的命令，重定向和管道。每一个功能都是使用系统调用来实现的，所以将System Calls称为操作系统的接口一点都不过分。</p></blockquote><h3 id="Executing-Simple-Commands"><a href="#Executing-Simple-Commands" class="headerlink" title="Executing Simple Commands"></a>Executing Simple Commands</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><blockquote><p><code>fork</code>系统调用创建一个子进程，对于父进程返回子进程的pid，对于子进程返回0。见下面代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int pid = fork(); //创建了子进程</span><br><span class="line">if(pid == 0) &#123;   //父子进程都从这里开始执行，唯一区别就是pid不一样</span><br><span class="line">   printf(&quot;child: existing!\n&quot;);</span><br><span class="line">   exit();</span><br><span class="line">&#125;else if(pid &gt; 0) &#123;</span><br><span class="line">printf(&quot;parent: %d&quot;, pid);</span><br><span class="line">wait();  //父进程等待</span><br><span class="line">printf(&quot;child is done\n&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">fprintf(stdeer, &quot;fork error!\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>其中<code>wait()</code>系统调用返回一个退出的子进程。</strong>上面这段代码其实就是整个Shell执行指令的原理:<strong>Shell提示符由父进程提供，然后创建一个子进程执行真正的命令，而父进程则<code>wait()</code>直到子进程返回,然后父进程等待下一条命令。</strong><br>执行效果如下:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/28.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>回到Shell中来，我们需要修改子进程中的代码，能够正确执行简单的命令。涉及到<code>exec()</code>函数族。</p></blockquote><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><blockquote><p>exec提供了在一个进程中执行另一个进程的方法: 根据参数提供的文件路径和名称找到可执行文件，并执行。执行结束之后原调用进程的内容除进程号之外其他的全部被替换。<strong>通常和fork一起联合实现进程中执行程序。</strong><code>exec</code>函数族是由6个以exec开头的函数构成的，这6个函数的用法根据名称的不同会有些微的区别:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/29.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="查找可执行文件的方式"><a href="#查找可执行文件的方式" class="headerlink" title="查找可执行文件的方式"></a>查找可执行文件的方式</h5><blockquote><p>其中<code>execlp</code>，<code>execvp</code>在查找可执行文件的时候不用写文件的<strong>绝对路径</strong>，系统会自动根据环境变量“$PATH”查找。<code>env</code>命令可以列出系统中当前的$PATH。</p></blockquote><h5 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h5><blockquote><p>其中<code>execlp</code>,<code>execl</code>,<code>execle</code>这三个第五个字母是<code>l</code>的函数参数只能分别列出来————<code>const char *argv...</code>。而<code>execv</code>,<code>execve</code>,<code>execvp</code>这三个第五个字母是<code>v</code>的函数参数可以整体构造数组传递————<code>char *const argv[]</code>。<strong>所有的参数都应该以<code>NULL</code>结尾</strong>。</p></blockquote><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><blockquote><p>其中<code>execle</code>和<code>execle</code>可以在使用指定的环境变量。通过在参数末尾加上<code>char *const envp[]</code>的方法。</p></blockquote><blockquote><p>总结见下图: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/30.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="exec函数族使用注意事项"><a href="#exec函数族使用注意事项" class="headerlink" title="exec函数族使用注意事项"></a>exec函数族使用注意事项</h5><ul><li>因为exec函数经常调用失败，所以需要加上判断语句</li><li>最后参数一定用<code>NULL</code>结尾<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int exec() &#123;</span><br><span class="line">int ret;</span><br><span class="line">if( fork() == 0 )&#123;</span><br><span class="line">if((ret = execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-al&quot;, NULL)) &lt; 0)  //参数以NULL结束</span><br><span class="line">fprintf(stderror, &quot;execlp error!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="实现命令"><a href="#实现命令" class="headerlink" title="实现命令"></a>实现命令</h4><blockquote><p><a href="https://pdos.csail.mit.edu/6.828/2018/homework/sh.c" target="_blank" rel="noopener">Shell代码</a>分为两个部分:词法分析和命令执行；<br>实验需要修改<code>runcmd()</code>函数代码，实现具体的EXEC。需要关注函数类型，参数两个细节。根据调试知道<code>&#39; &#39;</code>为EXEC，而<code>execcmd</code>结构体中argv[0]中存储的是命令的名称，所以我们使用<code>execvp</code>来实现，<code>execvp</code>函数的第一个参数是可执行文件的名称，往后的参数可以用数组表示，这样可以保证该命令的可变参数得到实现。代码如下:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">case &apos; &apos;:</span><br><span class="line">           ecmd = (struct execcmd*)cmd;</span><br><span class="line">           if(ecmd-&gt;argv[0] == 0)</span><br><span class="line">               _exit(0);</span><br><span class="line">           int pid, ret;</span><br><span class="line">           if ((pid = fork()) == 0) &#123;</span><br><span class="line">               if((ret = execvp(ecmd-&gt;argv[0], ecmd-&gt;argv)) &lt; 0) &#123;</span><br><span class="line">                   fprintf(stderr, &quot;Bash: command not found:%s\n&quot;, ecmd-&gt;argv[0]);</span><br><span class="line">                   exit(-1);</span><br><span class="line">               &#125;</span><br><span class="line">               exit(0);</span><br><span class="line">           &#125; else if (pid &gt; 0) &#123;</span><br><span class="line">               wait(0);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br></pre></td></tr></table></figure><blockquote><p>注意因为是多线程编程，所以调试的时候会出现很多不可思议的现象。<strong>可以先将fork()部分注释掉，进入执行函数看一下现象，然后输出调试。</strong>执行效果如下:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/31.png" width="300" height="200" alt="pic2" align="center"></p><h3 id="I-O-Redirection"><a href="#I-O-Redirection" class="headerlink" title="I/O Redirection"></a>I/O Redirection</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><blockquote><p>文件描述符是很重要的概念，它使得重定向成为可能。<code>File Descriptor</code>是一个整数，常常把其指向的对象称为文件。本实验中需要了解<code>open</code>，<code>creat</code>，<code>close</code>，<code>dup2</code>等系统调用返回值就是一个文件描述符。<strong>我们需要做的就是将Shell本身的文件描述符指向其他的文件描述符，从而实现重定向。</strong>Shell保证在任何时候都有3个打开的文件描述符————<code>0-标准输入</code>,<code>1-标准输出</code>,<code>2-错误输出</code>。<br>下面是会用到的几个系统调用: </p><ul><li><code>open(&quot;file_name&quot;, O_RDWR):</code> 打开文件，打开成功返回值最小的文件描述符————标准输入0，打开失败返回-1</li><li><code>create(&quot;file_name&quot;, 0777):</code> 创建文件，返回值同open</li><li><code>close(fd):</code> 释放一个文件描述符</li><li><code>dup2(oldfd, newfd):</code> 将oldfd复制给newfd  </li></ul></blockquote><blockquote><p>重定向不需要考虑子进程的问题，但还是需要深入了解<code>fork</code>函数的机理，<strong>一旦fork，父进程拥有和子进程一模一样的文件描述符</strong>。而重定向需要考虑的是在子进程中将标准输入（输出）定向到其他文件即可。  </p></blockquote><h4 id="lt-输入重定向"><a href="#lt-输入重定向" class="headerlink" title="&lt; 输入重定向"></a>&lt; 输入重定向</h4><blockquote><p>较简单，一旦文件不存在直接报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case &apos;&lt;&apos;:</span><br><span class="line">           rcmd = (struct redircmd*)cmd;</span><br><span class="line">           close(0);//关掉父进程的标准输入</span><br><span class="line">           if(open(rcmd-&gt;file, O_RDONLY) &lt; 0) &#123;</span><br><span class="line">               fprintf(stderr, &quot;Bash: No such file or directory:  %s\n&quot;, rcmd-&gt;file);  //输入不存在直接报错</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">//一旦open函数执行成功，它返回得文件描述符就是0，所以这时候该文件就变成了输入,定向成功</span><br><span class="line">               runcmd(rcmd-&gt;cmd);  //这里就是执行EXEC部分，所以fork的时候标准输入也是关闭的（和父进程一样close）</span><br><span class="line">           &#125;</span><br><span class="line">           break;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="gt-输出重定向"><a href="#gt-输出重定向" class="headerlink" title="&gt; 输出重定向"></a>&gt; 输出重定向</h4><blockquote><p>如果文件不存在。创建新的文件时需要注意文件的权限。<code>creat</code>函数的参数0777权限为<code>-rwx rwx rwx</code>。关于umask的知识见<a href="https://my.oschina.net/alphajay/blog/112428" target="_blank" rel="noopener">这里</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case &apos;&gt;&apos;:</span><br><span class="line">rcmd = (struct redircmd*)cmd;</span><br><span class="line">int fd;</span><br><span class="line">if((fd = open(rcmd-&gt;file, O_RDWR)) &lt; 0) &#123;  //fd为新打开文件的文件描述符</span><br><span class="line">if((fd = creat(rcmd-&gt;file, 0777)) &lt; 0 ) &#123;</span><br><span class="line">fprintf(stderr, &quot;Bash: No such file or directory:  %s\n&quot;, rcmd-&gt;file);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dup2(fd, 1);   //将标准输出指向到新打开的文件fd上，所以输出就到了该文件上（实现了重定向）</span><br><span class="line">runcmd(rcmd-&gt;cmd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dup2(fd, 1);</span><br><span class="line">runcmd(rcmd-&gt;cmd);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>执行效果如下: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/32.png" width="300" height="200" alt="pic2" align="center"></p><h3 id="Implement-pipes"><a href="#Implement-pipes" class="headerlink" title="Implement pipes"></a>Implement pipes</h3><blockquote><p>管道是一个小小的内和缓冲区，它以<strong>文件描述符对</strong>的形式提供给进程，从管道的一端写数据可以从管道的另一端读取。系统调用<code>pipe</code>将数组<code>int p[2]</code>初始化为管道的文件描述符。接下来做的无非就是重定向了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> case &apos;|&apos;:</span><br><span class="line">pcmd = (struct pipecmd*)cmd;</span><br><span class="line">int p[2];</span><br><span class="line">pipe(p);    //管道初始化</span><br><span class="line">if(fork() == 0) &#123;    </span><br><span class="line">dup2(p[0], 0);   //将标准输入重定向到管道的输入p[0]上</span><br><span class="line">close(p[0]);</span><br><span class="line">close(p[1]);</span><br><span class="line">runcmd(pcmd-&gt;right);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">dup2(p[1], 1);  //讲标注输出重定向奥管道额输出p[1]上</span><br><span class="line">runcmd(pcmd-&gt;left);  </span><br><span class="line">close(p[0]);</span><br><span class="line">close(p[1]);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>执行效果如下:   </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/33.png" width="300" height="200" alt="pic2" align="center"></p><h3 id="Make-grade"><a href="#Make-grade" class="headerlink" title="Make grade"></a>Make grade</h3><blockquote><p>6.828对于HW的测试是直接在主机上测试的，编译Shell文件:<code>gcc Shell</code>得到<code>a.out</code>。已知该文件t.sh:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; y</span><br><span class="line">cat &lt; y | sort | uniq | wc &gt; y1</span><br><span class="line">cat y1</span><br><span class="line">rm y1</span><br><span class="line">ls |  sort | uniq | wc</span><br><span class="line">rm y</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在主机上，执行<code>./a.out &lt; t.sh</code>与在主机Shell上执行<code>source t.sh</code>对比结果，如下: </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/34.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>本次实验的源代码在<a href="https://github.com/haotianmichael/JOS/tree/master/Shell" target="_blank" rel="noopener">Github</a>上。<br>第一次接触Linux系统编程，很多零碎的知识和细节学起来很是吃力。不过在独立搞懂Shell的机制之后又觉得很爽，还是很期待之后的挑战:)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HW-Shell&quot;&gt;&lt;a href=&quot;#HW-Shell&quot; class=&quot;headerlink&quot; title=&quot;HW:Shell&quot;&gt;&lt;/a&gt;HW:Shell&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;6.828除了Lab之外还有针对小型操作系统XV-6的Readings和HomeWork。整个6.828也是围绕这两条线（Lab和HW）在走。Lab1让我适应了JOS的实验环境和调试技巧，但是Shell和System Calls才是真正属于操作系统的知识。关于XV-6的HomeWork都是建立在Readings基础之上的，本次HW&lt;strong&gt;需要实现一个小型的Shell&lt;/strong&gt;，需要阅读的Readings有:    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;XV-6.Chapter.0（重点资料）&lt;/li&gt;
&lt;li&gt;man  fork, (3)exec，open， close&lt;/li&gt;
&lt;li&gt;TCPL&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;学习过程中最有意思的当属斩获新技能和新工具了:)介绍一个新的vim插件神器————&lt;a href=&quot;http://vim-taglist.sourceforge.net/manual.html#taglist-using&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Taglist&lt;/a&gt;。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/27.png&quot; width=&quot;300&quot; height=&quot;200&quot; alt=&quot;pic2&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
      <category term="C" scheme="http://haotianmcihael.github.io/tags/C/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="Shell" scheme="http://haotianmcihael.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Lab1</title>
    <link href="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/"/>
    <id>http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall2018-Lab1/</id>
    <published>2018-11-04T21:31:02.000Z</published>
    <updated>2018-12-04T08:55:46.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><h3 id="Before-Lab"><a href="#Before-Lab" class="headerlink" title="Before Lab"></a>Before Lab</h3><blockquote><p>Lab1一共有三部分:<code>Bootstrap</code>,<code>BootLoader</code>,<code>Kernel</code>;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分<code>monitor</code>中<strong>test_backtrace</strong>的功能。<br>如果<code>GDB</code>调试出错，可能是因为调试器没有链接到操作系统上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add </span><br><span class="line">add-auto-load-safe-path /Your Working Dir/.gdbinit</span><br><span class="line">line to your configuration file &quot;/root/.gdbinit&quot;</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><h3 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h3><h4 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h4><h5 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h5><blockquote><p>JOS中使用AT&amp;T格式的汇编语言，在Lab0中介绍了相关资料。实验要求熟悉<strong>x86汇编</strong>和<strong>Inline汇编</strong>两种写法。</p></blockquote><h4 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h4><blockquote><p>Lab1的工作目录:</p><ul><li><code>/boot</code>目录包含和启动相关的文件。</li><li><code>/kern</code>目录包含内核和监视器相关的文件。</li><li><code>/lib</code>目录包含一些链接使用的库函数比如printf。</li><li><code>/inc</code>目录包含头文件，申明了需要使用的数据结构。</li><li><code>/obj</code>目录是make之后相应的反汇编代码，供调试使用。<br>Lab1主要分析<code>/obj/kern/kern.asm</code>和<code>obj/boot/boot.asm</code>两个文件。这两个文件分别是<code>/boot</code>和<code>/kern</code>目录下的文件编译连接后的目标文件被反汇编而生成的。之所以这样做是因为反汇编之后可以看到每一条指令在内存中的绝对地址。这样调试的时候非常方便。至于<strong>实模式</strong>和<strong>保护模式</strong>下的地址转换在后续的实验中也会重点关注。</li></ul></blockquote><h4 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h4><blockquote><p>最早的8086机器只有1Mb的寻址空间，后面的80x86系列机器为了向后兼容所以衍生出实模式和保护模式这两种概念，但是BIOS一直都存在于从<code>0x00000000</code>到<code>0x00100000</code>这1Mb的空间中。JOS的内存布局也是规定只有<code>0x00000000</code>到<code>0x10000000</code>这256MB大小的空间，但是默认地址线是32位的。<strong>这个很重要，因为后面实验对JOS进行虚拟内存分配的时候页框地址最大也只能是<code>0x10000000</code>，内核如何处理映射就是一个问题。</strong>具体布局见下图:   </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/6.png" width="300" height="200" alt="pic2" align="center"></p><h4 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h4><h5 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h5><blockquote><p>这里介绍一下常用的GDB调试参数: </p><ul><li><code>si</code>: 单步调试</li><li><code>info register</code>: 查看当前各寄存器的值</li><li><code>x/Nx Addr</code>: 查看内存地址Addr之后<strong>N字</strong>的内容</li><li><code>x/Ni Addr</code>: 查看内存地址Addr之后的N条反汇编指令</li><li><code>x/Ni $eip</code>: 查看CPU当前执行的下N条指令（其中$eip可以换成不同的寄存器，这里就不一一列举了）<br>通过分析前面的JOS内存的布局，BIOS作为固件存在于<code>0xf0000</code>到<code>0xfffff</code>这64KB的空间上。<strong>注意启动为实模式，CPU的地址线寻址都是20位的。</strong>启动仿真器之后看到第一条代码停在了<code>0xffff0</code>的地址上，说明这是BIOS程序的入口。<code>0xffff0</code>到BIOS程序顶部<code>0xfffff</code>只有16字节的空间，需要更大的运行空间，因此第一条指令<code>ljmp   $0xf000,$0xe05b</code>；也就是跳转到<code>0xfe05b</code>这个地址正式开始运行BIOS的程序。<br>BIOS本身也是一个很复杂的系统，但是和OS关系不大。通过调试BIOS的代码我们知道了它的功能:</li><li>建立中断向量表及相应的中断例程</li><li>初始化部分硬件及自检(POST)</li><li>激活<code>INT 19</code>中断来加载启动盘第一扇区512字节的内容到内存(Linux)<br>这里应该说明第一扇区的内容是<code>/boot</code>目录下的内容:<code>boot.S</code>和<code>main.c</code>,这两个文件最后被编译链接成为可执行目标文件(这里需要ELF的知识)。在Linux系统中，这个可执行目标文件大小就是512字节，正好放在启动盘的第一个sector中,被称为<strong>bootsect</strong>。而BIOS的主要工作之一就是将<code>bootsect</code>加载到内存中，执行完任务之后，BIOS跳转到<code>bootsect</code>的初始位置。至此BIOS将权限交给操作系统，OS继续完成剩下的启动过程。<br>这里发现了一个小问题:就是在查看<code>/obj/boot</code>目录的时候，发现出现了<code>boot.out</code>和<code>boot</code>两个文件，如下:</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/7.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p><code>strip</code>命令将ELF文件中的符号表信息等调试信息删掉，减少文件本身的大小。理论上讲<code>bootsect</code>最后应该被链接到启动盘<code>kernel</code>的第一个扇区上，换句话讲最后的<strong>操作系统启动盘</strong>只有一个。查看<code>/obj/boot</code>目录下生成的这个两个文件:<code>boot.out</code>的格式为<strong>可执行目标文件</strong>，<code>boot</code>是<strong>x86 boot sector</strong>的格式，这两个文件中一定有一个作为<code>bootsect</code>链接使用。见下图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/8.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>可是经过分析这两个文件大小都是<strong>8K</strong>,经过优化之后也要<strong>4K</strong>大小，和<code>512Bytes</code>相差太远。而且文件<code>boot</code>还不可以使用二进制工具分析。这个细节方面应该和<strong>链接</strong>关系很大，<a href="https://book.douban.com/subject/3652388/" target="_blank" rel="noopener">《程序员的自我修养》</a>这本书是国内少有的讲链接装载的好书，有时间再拜读吧。</p></blockquote><h3 id="The-Boot-Loader"><a href="#The-Boot-Loader" class="headerlink" title="The Boot Loader"></a>The Boot Loader</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><h5 id="分析boot-boot-S"><a href="#分析boot-boot-S" class="headerlink" title="分析boot/boot.S"></a>分析boot/boot.S</h5><blockquote><p>分析一下<code>/boot/boot.S</code>这个文件:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">##############1.申明部分###############</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8       </span><br><span class="line">.set PROT_MODE_DSEG, 0x10       </span><br><span class="line">.set CR0_PE_ON,      0x1        </span><br><span class="line"></span><br><span class="line">#################2.16位实模式部分##########</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     </span><br><span class="line">  cli                      %禁止中断   </span><br><span class="line">  cld                        </span><br><span class="line"></span><br><span class="line">  xorw    %ax,%ax            %清零段寄存器</span><br><span class="line">  movw    %ax,%ds            </span><br><span class="line">  movw    %ax,%es            </span><br><span class="line">  movw    %ax,%ss            </span><br><span class="line">  </span><br><span class="line">###开启A20地址线##</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al          % 将64号端口的内容读到%al寄存器中   </span><br><span class="line">  testb   $0x2,%al           %检测%al的第二位是否为零（代表输入缓冲区是否为满，可以对端口继续读写）</span><br><span class="line">  jnz     seta20.1           %不为零则重复执行seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al          %将$0xd1写入%al寄存器</span><br><span class="line">  outb    %al,$0x64          %将%al寄存器的值写入64号端口</span><br><span class="line"></span><br><span class="line">seta20.2:                     %同样的方式</span><br><span class="line">  inb     $0x64,%al              </span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al              </span><br><span class="line">  outb    %al,$0x60          %两个端口读写   激活A20地址线</span><br><span class="line">###实模式————&gt;保护模式##</span><br><span class="line">  lgdt    gdtdesc    %加载GDT</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax    %取出%CR0寄存器的第零位并置1</span><br><span class="line">  movl    %eax, %cr0      %实模式向保护模式的转换</span><br><span class="line"></span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###########3.32位保护模式部分#############</span><br><span class="line"></span><br><span class="line">  .code32</span><br><span class="line">protcseg:</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax   </span><br><span class="line">  movw    %ax, %ds               </span><br><span class="line">  movw    %ax, %es               </span><br><span class="line">  movw    %ax, %fs               </span><br><span class="line">  movw    %ax, %gs               </span><br><span class="line">  movw    %ax, %ss               </span><br><span class="line"></span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spin:   %BUG Point！</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line">###########4.数据区################</span><br><span class="line">.p2align 2                       </span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)   </span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                     </span><br><span class="line">  .long   gdt</span><br></pre></td></tr></table></figure><blockquote><p><strong>申明部分</strong>两个宏定义是在保护模式下的段描述符的申明，对于保护模式后面还有介绍，这里权把它们看成是<code>CS</code>和<code>DS</code>段寄存器。<br><strong>实模式部分</strong>首先关掉了中断<code>cli</code>，因为接下来就要进行实模式下中断服务例程向保护模式下IDT中断描述符的交接。期间系统无法响应正常的中断服务。<code>cld</code>将标志位DF置零，DF和字符串操作相关;清零段寄存器。并打开了第21（A20）到第32根地址线，在没打开之前高于1MB的地址总是会“回滚”到0，这也是Linux检测保护模式和实模式的一个方法。<strong>接下来加载GDT，<code>movl %eax, %cr0</code>这句话是将系统控制寄存器<code>%CR0</code>的第0位（PE位）置一，意味着处理器工作方式变为保护模式。</strong>这里没有直接对<code>%CR0</code>进行操作，而是通过<code>%eax</code>来实现主要是为了不破坏寄存器的其他位，值得借鉴。最后<code>ljmp $PROT_MODE_CSEG, $protcseg</code>是跳转指令，<strong>需要注意的是现在已经是保护模式了，而在实模式下和保护模式下对于地址的转换方式已经从段寻址变成GDT寻址。</strong>这里只需要知道跳转到了<code>protcseg</code>这个地址。<br><strong>保护模式</strong>初始化了重要的段寄存器，然后跳转到<code>boot/main.c/bootmain</code>函数，开始将启动盘剩余的内核部分载入内存。<strong>注意在AT&amp;T格式的汇编语言中，操作数的字长是由操作符的最后一个字母决定的，后缀’b’,’w’,’l’分别表示字节（byte:8位），字（word:16位）和长字（long:32位）。</strong><br><strong>数据区部分</strong>都是在保护模式下建立GDT全局描述符的时候相关的宏定义。  </p></blockquote><h5 id="分析boot-main-c"><a href="#分析boot-main-c" class="headerlink" title="分析boot/main.c"></a>分析boot/main.c</h5><blockquote><p>分析一下<code>boot/main.c</code>这个文件:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define SECTSIZE 512</span><br><span class="line">#define ELFHDR ((struct Elf *) 0x100000)</span><br><span class="line"></span><br><span class="line">void readsect(void*, uint32_t);</span><br><span class="line">void readseg(uint32_t, uint32_t, uint32_t);</span><br><span class="line">void bootmain(void);</span><br></pre></td></tr></table></figure><blockquote><p>先看这两个宏定义，<code>SECTSIZE</code>是磁盘一个<code>sector</code>的大小，一般读写操作都要求地址对齐，这个宏定义就会派上用场。<code>ELFHDR</code>是一个指向ELF文件结构体的指针，不得不说<strong>强转</strong>是C语言最有力的工具之一，由此可知<code>0x100000</code>便是内存载入的首地址。这个地址也是BIOS程序结束的地方，可见JOS对于内存的规划分配还是很精确的。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">readseg(uint32_t pa, uint32_t count, uint32_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    //pa是加载地址    count是加载文件大小    offset是在内核文件中的偏移量</span><br><span class="line">        uint32_t end_pa;</span><br><span class="line">        end_pa = pa + count;   //结束地址</span><br><span class="line">        pa &amp;= ~(SECTSIZE - 1);  //将加载地址与最小单位512对齐</span><br><span class="line">        offset = (offset / SECTSIZE) + 1;   //计算加载部分在启动盘中的哪一个sector中，因为sector从1开始算起</span><br><span class="line">        while (pa &lt; end_pa) &#123;</span><br><span class="line">                readsect((uint8_t*) pa, offset);  </span><br><span class="line">                pa += SECTSIZE;    //这句话表明 最终分配的内存有可能是大于实际需要内存的，因为总是以512为最小分配单元分配的</span><br><span class="line">                offset++;  </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>readseg</code>函数中的对齐，看下面这个sample函数:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">long SECSIZE = 0x200;  </span><br><span class="line">long pa = 0x30301;</span><br><span class="line">long to = 0x10387;</span><br><span class="line"></span><br><span class="line">to &amp;= ~(SECSIZE - 1);</span><br><span class="line">pa &amp;= ~(SECSIZE - 1);</span><br><span class="line"></span><br><span class="line">printf(&quot;secsize is : %lx\n&quot;, SECSIZE);</span><br><span class="line">printf(&quot;pa is : %lx\n&quot;, pa);</span><br><span class="line">printf(&quot;to is : %lx\n&quot;, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之所以需要对齐，因为磁盘和内存之间读写如果按照规定的最小粒度进行，CPU的访问性能会提高。具体见<a href="https://www.ibm.com/developerworks/library/pa-dalign/" target="_blank" rel="noopener">IBM.alignment</a>。上述函数的执行结果见下图:</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/9.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p><code>readsect</code>函数都是一些端口操作。也没仔细研究Orz。下面主要看一下<code>bootmain</code>函数剩下的部分:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">   eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   for (; ph &lt; eph; ph++)</span><br><span class="line">            readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure><blockquote><p>关于JOS对于ELF文件的申明见<code>/inc/elf.h</code>。一共有三个结构体，<code>Elf</code>代表文件头；<code>Proghdr</code>代表加载时候segment的信息；<code>Secthdr</code>代表运行时section的信息；<br>在Lab0中，我们分析过对一个程序加载的时候是以<code>segments</code>为最小粒度的。所以我们重点关注<code>Elf</code>和<code>Proghdr</code>这两个结构体的细节。  </p><ul><li><code>e_phoff</code>: segment表在整个程序中的偏移量</li><li><code>e_phnum</code>: segment表项的个数</li><li><code>ph-&gt;p_pa</code>: 该segment在内存中的加载地址</li><li><code>ph-&gt;p_memsz</code>: 该segment的大小</li><li><code>ph-&gt;p_offset</code>: 该segment相对于表起始地址的偏移量<br>所以<code>ph</code>就是segment段表的开始地址。而<code>eph</code>就是segment段表的项数。这个循环是把所有的segments都加载到相对应的内存地址中。<br>加载结束后，再次跳转<code>((void (*)(void)) (ELFHDR-&gt;e_entry))()</code>,通过调试反汇编代码，发现跳转的这个地址为<code>call *0x10018</code>,注意这里是一个指针，可以看到内核函数真正的入口在<code>0x0010000c</code>。所以正确的操作见下图:</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/10.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h5><blockquote><p>在上面分析的过程基本上回答了所有的问题: </p><ul><li><code>%CR0</code>标志位的改变意味着实模式切换到保护模式</li><li><code>call *0x10018</code>是最后一条BootLoader执行的指令，<code>movw $0x1234, 0x472</code>是内核第一条指令，这条指令在<code>0x0010000c</code>这个入口地址。</li><li>通过读取ELF文件中关于加载segments的信息，因为main函数最开始加载了8个sectors的内容到内存中，这部分内容就是和ELF格式和细节信息有关系。</li></ul></blockquote><h4 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h4><h5 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h5><blockquote><p>重温C语言指针，实验中推荐<a href="https://book.douban.com/subject/1236999/" target="_blank" rel="noopener">TCPL</a>。分析实验中给出的部分示例代码，体会指针的魅力:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = (int *) ((char *) c + 1);</span><br><span class="line">*c = 500;</span><br><span class="line">printf(&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;,</span><br><span class="line">a[0], a[1], a[2], a[3]);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码将c强转成为char类型的指针之后加一，然后赋值为500；问题就出现在char类型和int类型的指针大小是不一样的。int类型为4个字节，而char类型只有1个字节;所以这样势必会导致赋值的时候改变数组中原来的布局。已知a[1]原来的值400，16进制为0x190;a[2]的值原来为301，16进制为0x12D;500的16进制为0x1F4;一个地址单元为一个字节，为见下图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/11.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>可以看到读写操作是按照字节为最小单元，最后导致a[1]的值变成0x1F490也就是十进制的128144；而a[2]由于被抹掉以个字节，所以变成0x100也就是256。下图是最终的运行结果:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/12.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h5><blockquote><p>关于链接器和加载器，最经典的当然是这本<a href="https://www.iecc.com/linker/" target="_blank" rel="noopener">loader and linker</a>。这是中译本<a href="https://paper.seebug.org/papers/Archive/refs/elf/《链接器和加载器》中译本.pdf" target="_blank" rel="noopener">ll.Ch</a>。不过我做实验的时候没有想明白他们为什么要在这里引入这两个复杂的概念；题目很简单，但是不知道<code>LMA</code>和<code>VMA</code>是和虚拟内存有关系还是和链接器，加载器有关系。后来用<code>readelf -h kernel</code>发现<code>VMA</code>就是虚拟地址，所以这里他们所谓的linking address和loading address只是实验中自行定义的字面意思<strong>加载的地址</strong>和<strong>执行的地址</strong>，和链接器加载器没有关系！！另外在Lab0中已经分析过加载时候的<code>section</code>是所有<code>sections</code>组合成的一个聚合节，这里不考虑链接时候的单个<code>section</code>的概念。<strong>这样的话，就可以明白实验讲解的思路————引入使用ELF中<code>segments</code>的概念来解释加载过程，而加载过程时候已经开启了分页机制，所以这时候用<code>loading address</code>和<code>linking address</code>来解释<code>0xf0100000</code>和<code>0x00100000</code>的区别。而实际上<code>0xf0100000</code>就是映射到<code>0x00100000</code>上，相关细节在Kernel部分会继续分析。</strong><br>readelf和objdump的操作见下图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/14.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>将链接地址改掉之后，第一条报错的应该是和链接地址直接相关的指令，跳转指令<code>ljmp $PROT_MODE_CSEG, $protcseg</code>;</p></blockquote><h5 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h5><blockquote><p>前面分析过<code>#define ELFHDR ((struct Elf *) 0x100000)</code>所以我们可以知道，内核的装载地址(load address)就是<code>0x00100000</code>，而内核开始执行的地址应该是<code>e_entry</code>也就是<code>0x0010000c</code>。从BIOS到BootLoader的时候，内核还没有开始装载。所以<code>0x00100000</code>是空的。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/13.png" width="300" height="200" alt="pic2" align="center"></p><h3 id="The-Kernel"><a href="#The-Kernel" class="headerlink" title="The Kernel"></a>The Kernel</h3><h4 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h4><blockquote><p>Lab1中的地址映射: <code>0x00000000</code>————<code>0x00400000</code>映射到<code>0x00000000</code>————<code>0x00400000</code>；<code>0xf0000000</code>————<code>0xf0400000</code>映射到<code>0x00000000</code>————<code>0x00400000</code>;<br>在实验过程中关注了一下地址: 在执行到<code>kern/entry.S</code>文件之前，所有的内存地址都是物理地址（书中代言为线性地址，但是线性地址=物理地址所以没有太大区分）。直到<code>%CR0</code>寄存器的PG标志位被置零。这时候分页机制才被激活。<code>0x00100000</code>和<code>0xf0100000</code>都映射到<code>0x00100000</code>，所有两个地址存储的数值是一样的。而在映射还没有建好之前是不一样的。  </p></blockquote><h5 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h5><blockquote><p><code>%CR0</code>寄存器PG位控制分页机制的实现。看到<code>mov %eax, %cr0</code>执行结束之后，索引地址变成了<code>0xf0100010</code>。地址映射不对，第一条错误的指令一定会是跳转指令<code>jmp *%eax</code>。具体的分页细节在Lab2中分析。实验操作见下图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/15.png" width="300" height="200" alt="pic2" align="center"></p><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><h5 id="分析kern-printf-c"><a href="#分析kern-printf-c" class="headerlink" title="分析kern/printf.c"></a>分析kern/printf.c</h5><blockquote><p>下面分析一下<code>kern/printf.c</code>这个文件:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void putch(int ch, int *cnt)</span><br><span class="line">&#123;</span><br><span class="line">        cputchar(ch);//显示屏输出函数console</span><br><span class="line">        *cnt++;   //每进行一次显示屏输出，参数自加</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int vcprintf(const char *fmt, va_list ap)</span><br><span class="line">&#123;</span><br><span class="line">        int cnt = 0;   //cnt将自身指针传给putch(int, int*)，在函数里进行自加</span><br><span class="line">        vprintfmt((void*)putch, &amp;cnt, fmt, ap);  //格式判断</span><br><span class="line">        return cnt;                  //返回最终输出的参数个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int cprintf(const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">        va_list ap;</span><br><span class="line">        int cnt;</span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        cnt = vcprintf(fmt, ap);//变参传递</span><br><span class="line">        va_end(ap);</span><br><span class="line">        return cnt;  //返回参数个数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>cprintf</code>是主函数，这里用到了C语言的变参特性。变参在C库<code>stdarg.h</code>中定义至少要有一个固定的参数:<code>fun(const char *fmt, ...)</code>。主要有三个宏组成: </p><ul><li><code>va_list</code>: 申明可变参数指针ap，依次指向省略号表示的可变参数</li><li><code>va_start(ap, lastFix)</code>:  初始化ap，开始指向第一个可变参数</li><li><code>va_arg(ap, type)</code>: 将ap指向下一个可变参数</li><li><code>va_end(ap)</code>: 清除ap指针，结束函数<br>可以看到变参<code>fmt</code>和变参指针<code>ap</code>被一路传到<code>vcprintf</code>———&gt;<code>vprintfmt</code>。在<code>vprintfmt</code>中使用。该文件中重点关注两个函数:</li><li>在<code>lib/printfmt.c</code>中的函数: <code>vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)</code></li><li>在<code>kern/console.c</code>中的函数: <code>cputchar(int c)</code><br>经过观察之后就可以知道: <strong><code>vprintfmt</code>函数判断字符串输出参数的类型并调用<code>cputchar</code>函数将相应的输出显示到显示屏上</strong>。<br>在函数分析之前再介绍一个vim的新技能:搜索高亮<code>:match Search /xxx/</code>,可以对现在正在关注的关键字进行高亮显示，调试的时候很有用:  </li></ul></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/22.png" width="300" height="200" alt="pic2" align="center"></p><h6 id="分析函数vprintfmt"><a href="#分析函数vprintfmt" class="headerlink" title="分析函数vprintfmt"></a>分析函数vprintfmt</h6><blockquote><p><code>vprintfmt</code>函数其实很简单，主体就是一个while循环:在遇到<code>%</code>之前直接输出，遇到<code>%</code>之后开始判断格式并输出。</p></blockquote><h6 id="分析函数cputchar"><a href="#分析函数cputchar" class="headerlink" title="分析函数cputchar"></a>分析函数cputchar</h6><blockquote><p><strong>在<code>vprintfmt</code>函数中需要注意一个变量:<code>ch = *(unsigned char *) fmt++</code>。<code>ch</code>代表了当前ap指针指向的变参，也就是我们需要输出的内容。</strong><code>cputchar(ch)</code>中的参数正好就是这个<code>ch</code>。我们使用Ctags跟踪这个<code>ch</code>参数经过的函数:<code>putch(int ch, int *)</code>————&gt;<code>cputchar(int ch)</code>————&gt;<code>cons_putc(int ch)</code>。现在基本上可以看清所有的控制台输出操作都是定义在<code>console.c</code>文件中的。我们直接分析一下<code>cons_putc(int ch)</code>这个函数:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void cons_putc(int c)</span><br><span class="line">&#123;</span><br><span class="line">        serial_putc(c);</span><br><span class="line">        lpt_putc(c);</span><br><span class="line">        cga_putc(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上三个子函数都涉及到的内联汇编<code>inb()</code>和<code>outb()</code>两个函数在<code>inc/x86.h</code>中有定义。其中<code>serial_putc</code>是串口输出，<code>lpt_putc</code>是并口输出，而<code>cga_putc</code>是显示屏输出，具体不细分析了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; !(inb(0x378+1) &amp; 0x80) &amp;&amp; i &lt; 12800; i++)</span><br><span class="line">       delay();    //判断数据缓冲区寄存器是否为空，为空则一直循环</span><br><span class="line">   outb(0x378+0, c);     //将C参数代表的内容写到端口中</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>另外，在<code>cga_putc(c)</code>函数中，有一段代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">    for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">        crt_buf[i] = 0x0700 | &apos; &apos;;</span><br><span class="line">    crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>我们知道<code>cga_putc(c)</code>函数是用于显示屏输出的函数，而查看这几个宏定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static uint16_t crt_pos //光标</span><br><span class="line">#define CRT_ROWS        25   //显示屏行</span><br><span class="line">#define CRT_COLS        80    //显示屏列</span><br><span class="line">#define CRT_SIZE        (CRT_ROWS * CRT_COLS)  //显示屏面积</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>简单来讲就是如果输出满屏之后，需要页面向上滚动一行。</p></blockquote><h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h4><h5 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h5><blockquote><p>经过上面的分析之后，知道格式化输出是在<code>kern/printfmt.c/vprintfmt()</code>这个函数中。找到相应的位置修改就行。</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/16.png" width="300" height="200" alt="pic2" align="center"></p><h5 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h5><blockquote><p>这是Exercise.8后面的一些问题，当然很简单了:<br>1.cputchar(int c)         2.一句话，就是满屏时候的处理方法          3.主要是变参指针<code>ap</code>和格式化变参<code>fmt</code>的指向问题，之前分析过<br>4.将代码加到<code>kern/monitor.c</code>中，输出见下图。因为57616的十六进制就是ell。而0x0x00646c72在小端存储的机器上用char*表示就是<code>rld\0</code>。如果想要用大端存储的话，只要反过来就行0x726c6400。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/17.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>5.根据变参的定义，如果fmt参数不够，那最终ap指针会指向一个未知内存区域。所以输出的数不一定。见下图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/18.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>6.关于变参的定义是在<code>inc/stdarg.h</code>中,我们看一下<code>va_arg</code>是如何一次一次取出变参的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define va_arg(ap, type) __builtin_va_arg(ap, type) //Fall 2018</span><br><span class="line"></span><br><span class="line">#define va_arg(ap, type) \</span><br><span class="line">(*(type *)((ap) += __va_size(type), (ap) - __va_size(type)))  //Fall 2015</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>可以看到va_arg是通过地址往后增长来取出下一个变参的。<strong>而正常编译器是从右往左的顺序将参数入栈的（因为栈是从高地址向低地址延伸的）。</strong>如果这时候栈的顺序变了，那只需要将va_arg函数中的对地址的加法改为减法就行。  </p></blockquote><h4 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h4><h5 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h5><blockquote><p>关于栈的定义在<code>kern/entry.S</code>中。见下图:</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/19.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>因为栈是从高地址向低地址延伸的，所以<code>mov $(bootstacktop) %esp</code>将栈顶地址赋值给<code>%esp</code>寄存器。而在数据段中对栈大小的定义也很清楚了————<code>KSTKSIZE</code>是一个宏定义，大小为8x4KB=32KB。</p></blockquote><h5 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h5><blockquote><p>需要深入了解栈调用的机制，就需要了解<strong>stack pointer</strong><code>%esp</code>和<strong>base pointer</strong><code>%ebp</code>这两个寄存器的用法。我们通过调试<code>test_backtrace()</code>函数来深入了解。(实际上只要有函数调用就会有栈，但很明显test_backtrace不是第一个调用的函数。当然你也可以从第一个函数i386_init开始，这个时候%esp也刚刚完成初始化0xf0110000,感觉会更爽一些)。<br><code>test_backtrace</code>函数的调用发生在<code>kern/init.c/i386_init()</code>中，所以我们第一个断点设置在<code>0xf01000de</code>。从反汇编代码中可以看出，开始调用<code>test_backtrace</code>之前，还有两条指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl $0x5, (%esp)</span><br><span class="line">call f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在还没有开始执行的时候，查看一下寄存器的状态<code>info registers</code>:<code>%esp</code>的值为<code>0xf010ffe0</code>，<code>%ebp</code>的值为<code>0xf010fff8</code>。<br>然后开始执行第一句，将参数5<strong>movl</strong>到栈顶，注意这里不是压栈而是直接存进去的，所以栈指针<code>%esp</code>是不会移动的。但是这时候栈顶元素应该是0x5。我们可以通过<code>info registers</code>命令和<code>x/8x $esp</code>来分别验证，效果如下:</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/20.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>在看一下第二条指令<code>call f0100040</code>。<code>call</code>指令可以分成两条指令:<code>push %eip</code>和<code>jmp 0xf0100040</code>。所以看到<code>push</code>指令是正宗的压栈指令，这时候<code>%esp</code>寄存器的值是要-4的，而且递减满堆栈的顺序是<strong>先-4，再压栈</strong>。这次栈顶元素应该是下一条指令的地址<code>0xf01000ea</code>，而且<code>%esp</code>的值还得-4。我们可以通过<code>info registers</code>和<code>x/8x $esp</code>来分别验证:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/21.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>第三条指令就正式进入到<code>test_backtrace</code>函数内部了。分析一下函数内部的<strong>调用代码</strong>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void test_backtrace(int x)</span><br><span class="line">&#123;</span><br><span class="line">f0100040:       55                      push   %ebp</span><br><span class="line">f0100041:       89 e5                   mov    %esp,%ebp</span><br><span class="line">f0100043:       53                      push   %ebx</span><br><span class="line">f0100044:       83 ec 14                sub    $0x14,%esp</span><br><span class="line">f0100047:       8b 5d 08                mov    0x8(%ebp),%ebx</span><br><span class="line">        cprintf(&quot;entering test_backtrace %d\n&quot;, x);</span><br><span class="line">f010004a:       89 5c 24 04             mov    %ebx,0x4(%esp)</span><br><span class="line">f010004e:       c7 04 24 20 1a 10 f0    movl   $0xf0101a20,(%esp)</span><br><span class="line">f0100055:       e8 c1 09 00 00          call   f0100a1b &lt;cprintf&gt;</span><br><span class="line">        if (x &gt; 0)</span><br><span class="line">f010005a:       85 db                   test   %ebx,%ebx    </span><br><span class="line">f010005c:       7e 0d                   jle    f010006b &lt;test_backtrace+0x2b&gt;</span><br><span class="line">                test_backtrace(x-1);</span><br><span class="line">f010005e:       8d 43 ff                lea    -0x1(%ebx),%eax</span><br><span class="line">f0100061:       89 04 24                mov    %eax,(%esp)</span><br><span class="line">f0100064:       e8 d7 ff ff ff          call   f0100040 &lt;test_backtrace&gt;</span><br><span class="line">f0100069:       eb 1c                   jmp    f0100087 &lt;test_backtrace+0x47&gt;</span><br><span class="line">        else</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>基本上所有被调用的函数开头都会有这两条指令:<code>push %ebp</code>;<code>mov %esp, %ebp</code>;<br>实验指导书上也解释了<code>%ebp</code>寄存器的作用:<strong>On entry to a C function, the function’s prologue code normally saves the previous function’s base pointer by pushing it onto the stack, and then copies the current esp value into ebp for the duration of the function.</strong>每一个函数都有一个<code>%ebp</code>值，作为函数的栈帧，需要在每次调用新函数的时候压栈以保存上一个函数的返回地址。<br>这个时候莫名其妙的压栈了一个寄存器<code>%ebx</code>。我们将<code>%ebx</code>全局高亮显示发现，后面紧接着会有<code>mov 0x8(%ebp), %ebx</code>。那<code>0x8(%ebp)</code>存储的到底是啥？不难想到就是参数5。然后<code>%esp</code>指针接着扩展当前函数的栈空间。关注一下第二次调用<code>test_backtrace()</code>，前一条指令<code>mov %eax, (%esp)</code>和第一次调用的时候完全一样，而<code>%eax</code>中存的也是参数5-1=4;当然调用指令<code>call</code>也需要一次压栈。总结一下，如果是从<code>push %ebp</code>开始算起是函数栈的开头的话，那我们每一个函数调用会花费<code>4（push %ebp）+4(push %ebx)+20(sub $0x14,%esp)+4(call)</code>一共是32Bytes字节的空间。所以整个栈的布局见下图:   </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/23.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>当然在调用过程中还调用了<code>cprintf()</code>这个函数，不过20字节用来分配栈空间也够了。</p></blockquote><h5 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h5><blockquote><p>经过上面的分析，栈的布局已经很清楚了。所以我们需要知道对于<code>read_ebp()</code>函数来说读出的是当前<code>%ebp</code>指针指向的地址，所以按照上面栈的布局:<code>(%ebp)--&gt;上一个%ebp</code>,<code>0x4（%ebp）--&gt;%eip</code>,<code>0x8(%ebp)--&gt;参数1</code>…当然这里的参数比5个少。<br>下面就是考验C语言的时刻，一定要注意格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">mon_backtrace(int argc, char **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">        // Your code here.</span><br><span class="line">        /*</span><br><span class="line">         parameter &quot;argc&quot; indicates numbers of paras passed by the command-line;  parameter &quot;argv&quot; indicates specific paras accordingly.</span><br><span class="line">        */</span><br><span class="line">        struct Eipdebuginfo info;</span><br><span class="line">        cprintf(&quot;Stack backtrace:\n&quot;);</span><br><span class="line">        uint32_t *ebp = (uint32_t*)read_ebp();</span><br><span class="line">        while(ebp) &#123;</span><br><span class="line">                uint32_t eip = ebp[1];</span><br><span class="line">                cprintf(&quot;  ebp %x  eip %x  args &quot;, ebp, eip);</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+2));//这里提一下指针的用法，指导书中有讲解</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+3));</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+4));</span><br><span class="line">                cprintf(&quot;%08.x &quot;, *(ebp+5));</span><br><span class="line">                cprintf(&quot;%08.x\n&quot;, *(ebp+6));</span><br><span class="line"></span><br><span class="line">                ebp = (uint32_t*)*(ebp);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h5><blockquote><p>对每一个<code>%eip</code>，尝试着给出其<strong>文件名称</strong>，<strong>函数名称</strong>和<strong>行号</strong>。这些信息都属于调试的信息。实验要做的是找到这些调试信息，并按照规定格式将它们输出。这里需要了解<a href="https://sourceware.org/gdb/onlinedocs/stabs.html#Stab-Sections" target="_blank" rel="noopener">STAB</a>符号表的概念。<br>首先查看下<code>kern/kernel.ld</code>链接脚本。发现了有关<code>_STAB_*</code>的两个信息————<code>.stab</code>和<code>.stabstr</code>。其中stab是今天的重点。<code>kern/kdebug.c</code>中的宏定义说明了stab和stabstr的关系。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern const struct Stab __STAB_BEGIN__[];      // Beginning of stabs table</span><br><span class="line">extern const struct Stab __STAB_END__[];        // End of stabs table</span><br><span class="line">extern const char __STABSTR_BEGIN__[];          // Beginning of string table</span><br><span class="line">extern const char __STABSTR_END__[];            // End of string table</span><br></pre></td></tr></table></figure><blockquote><p>再看一下<code>inc/stab.h</code>对stab定义的数据结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Entries in the STABS table are formatted as follows.</span><br><span class="line">struct Stab &#123;</span><br><span class="line">        uint32_t n_strx;        // index into string table of name    该项对应的在stabstr节内的索引偏移</span><br><span class="line">        uint8_t n_type;         // type of symbol   该项描述的符号类型   重点关注</span><br><span class="line">        uint8_t n_other;        // misc info (usually empty)   </span><br><span class="line">        uint16_t n_desc;        // description field  源文件的行号  重点关注</span><br><span class="line">        uintptr_t n_value;      // value of symbol   地址值   重点关注</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>通过<code>objdump -G obj/kern/kernel</code>来查看当前ELF文件中的符号表信息。见下图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/24.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>仔细观察上图，发现每一列的分类就是按照stab数据结构分类的。重点关注一下<code>n_type</code>这个关键字，它表示该描述项的符号类型，上图中出现有很多<code>SO</code>，<code>FUN</code>…等符号类型。将这些列单独列出来进行对比:   </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/25.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>很明显<code>SO</code>指的是文件名，<code>FUN</code>指的是函数名。<strong>注意这是objdump对应的符号表，JOS对符号表有自己定义的数据结构见<code>inc/stab.h</code></strong>。输出的顺序都是按照地址来排序的，很整齐。所以<code>stab_binsearch()</code>查找函数原理也就猜的差不多了，<strong>这些调试信息和相应地址的关系是通过符号表来连接的。当然所有的这些知识都可以通过<code>kern/kdebug.c</code>这个文件中对<code>stab</code>的注释（见过最全的注释了）学习到。所以我们最后分析一下这个文件:</strong><br>整个文件一共有两个函数<code>debuginfo_eip</code>和<code>stab_binsearch</code>。JOS建立了一个数据结构<code>Eipdebuginfo</code>用来存放调试信息，<code>debuginfo_eip</code>调用<code>stab_binsearch</code>函数完成一个实例化的<code>Eipdebuginfo</code>，所有的输出信息其实最后都存储在这个实例中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Eipdebuginfo &#123;</span><br><span class="line">        const char *eip_file;           // Source code filename for EIP</span><br><span class="line">        int eip_line;                   // Source code linenumber for EIP</span><br><span class="line"></span><br><span class="line">        const char *eip_fn_name;        // Name of function containing EIP</span><br><span class="line">                                        </span><br><span class="line">        int eip_fn_namelen;             // Length of function name</span><br><span class="line">        uintptr_t eip_fn_addr;          // Address of start of function</span><br><span class="line">        int eip_fn_narg;                // Number of function arguments</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><code>stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right, int type, uintptr_t addr)</code>函数本质上就是一个二分查找。<strong><code>type</code>指的就是符号表项的符号类型，该函数每次查找的时候都需要确定查找的符号类型</strong>。我们需要完成的部分是行号，通过检查<code>inc/stab.h</code>文件，很容易知道行号的宏定义是<code>S_LINE</code>。二分查找失败的标志就是<code>LeftA &gt; rightA</code>。所以代码也很简单了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Your code here.</span><br><span class="line">       stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);   </span><br><span class="line">       if(lline &lt;= rline)&#123;</span><br><span class="line">               info-&gt;eip_line = stabs[lline].n_desc;  //确定行号</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">               return -1;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>最后将monitor的命令补充完整就更简单了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add :</span><br><span class="line">debuginfo_eip(eip, &amp;info);</span><br><span class="line">                cprintf(&quot;\t%s:%d: %.*s+%d\n&quot;, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, info.eip_fn_addr);</span><br><span class="line">to kern/monitor.c/mon_backtrace()</span><br><span class="line"></span><br><span class="line">add :</span><br><span class="line">        &#123;&quot;backtrace&quot;, &quot;Display each stack frame called&quot;, mon_backtrace &#125;,</span><br><span class="line">to kern/monitor/commands[]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>运行结果见下图:</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/26.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>实验过程中有几处细节涉及到编译器的优化，因为还不是很了解编译链接的细节和原理，所以被我忽略掉了。<br>至此Lab1结束。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lab1&quot;&gt;&lt;a href=&quot;#Lab1&quot; class=&quot;headerlink&quot; title=&quot;Lab1&quot;&gt;&lt;/a&gt;Lab1&lt;/h2&gt;&lt;h3 id=&quot;Before-Lab&quot;&gt;&lt;a href=&quot;#Before-Lab&quot; class=&quot;headerlink&quot; title=&quot;Before Lab&quot;&gt;&lt;/a&gt;Before Lab&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Lab1一共有三部分:&lt;code&gt;Bootstrap&lt;/code&gt;,&lt;code&gt;BootLoader&lt;/code&gt;,&lt;code&gt;Kernel&lt;/code&gt;;前两部分都是GDB调试为主，熟悉GDB的调试技巧和操作系统的启动流程。最后实现一小部分&lt;code&gt;monitor&lt;/code&gt;中&lt;strong&gt;test_backtrace&lt;/strong&gt;的功能。&lt;br&gt;如果&lt;code&gt;GDB&lt;/code&gt;调试出错，可能是因为调试器没有链接到操作系统上：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;add &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;add-auto-load-safe-path /Your Working Dir/.gdbinit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;line to your configuration file &amp;quot;/root/.gdbinit&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
      <category term="C" scheme="http://haotianmcihael.github.io/tags/C/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Mit6.828(Fall 2018) Lab0</title>
    <link href="http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/"/>
    <id>http://haotianmcihael.github.io/2018/11/05/Mit6-828-Fall-2018-Lab0/</id>
    <published>2018-11-04T16:35:45.000Z</published>
    <updated>2018-11-21T12:49:19.257Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab0"><a href="#Lab0" class="headerlink" title="Lab0"></a>Lab0</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>从<code>8086汇编</code>实验之后，前后两周的时间勉强通过Lab1。<br>最大的感触是<strong>基础太差</strong>:对C语言的理解，对程序编译链接本质的理解，对<code>GDB</code>等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。<br>但是这次触动中却又多了一丝<code>见山不是山，见山又是山</code>的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如<code>printf</code>函数的实现就涉及C语言中变参的特性。有理由相信这种<strong>血浓于水</strong>的关系在后续的Lab中还会进一步加强，所以我也希望这会是我学习OS最完美的方法论——————<strong>Talk is cheap, show me the code.</strong>。<br>截止到Lab1，整个学习的过程显得很清晰————就是<strong>通过调试<code>kernel</code>的反汇编代码来理解运行原理并加以修改</strong>。Lab0是我在实验过程中掉进的坑，查阅的资料和逐渐点亮的技能树，缩短实验前的准备时间对理解OS本身还是很有帮助的。<br><a id="more"></a></p></blockquote><h3 id="6-828实验环境的搭建"><a href="#6-828实验环境的搭建" class="headerlink" title="6.828实验环境的搭建"></a>6.828实验环境的搭建</h3><ul><li>虚拟机环境: Ubuntu14.4 (<strong>32位</strong>)</li><li>仿真器: Qemu <code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></li><li>实验代码: Lab <code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code><blockquote><p>虚拟机环境<code>32位</code>，因为<code>JOS</code>就是32位的操作系统。<br>仿真器使用MIT进行patched过的(见上链接)。原因是实验中分页机制是有意修改过的，使用<code>patched version</code>的话在后面<code>Exercise</code>中不需要手动转换地址。<br>关于实验代码，默认熟悉<code>Git</code>和<code>MakeFile</code>。每做完一个<code>Exercise</code>可以使用<code>make grade</code>进行测试。<br>在整个实验环境搭建的过程中，可能会因为虚拟机发型版本的不同而出现不同的链接库丢失，Google一下。详细的搭建过程见<a href="https://pdos.csail.mit.edu/6.828/2018/tools.html#" target="_blank" rel="noopener">Tools Guide</a></p></blockquote></li></ul><h3 id="关于6-828"><a href="#关于6-828" class="headerlink" title="关于6.828"></a>关于6.828</h3><blockquote><p>MIT的OS课程。学习共有三条主线:<code>Lectures</code>,<code>Readings</code>,<code>Labs</code>。<br>当然最重要的就是<code>Labs</code>。关于剩余的两部分，主要围绕一个叫做<code>xv6</code>的小型OS展开的。简单来讲，这是一个<strong>麻雀虽小五脏俱全</strong>的OS。有<code>Documents</code>和<code>Source Code</code>两份资料。知乎上评价很高，有人将其翻译成为中文版本上传至Github.<a href="https://github.com/ranxian/xv6-chinese" target="_blank" rel="noopener">XV6_Ch</a>，传说看懂源码之后可以超神……<br>做<code>Lab</code>的过程中，课程会提供大量的Readings来阅读，当然都是英文的。详细见<a href="https://pdos.lcs.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">Reference</a>。</p></blockquote><h3 id="80386汇编和内联汇编"><a href="#80386汇编和内联汇编" class="headerlink" title="80386汇编和内联汇编"></a>80386汇编和内联汇编</h3><h4 id="AT-amp-T-80386"><a href="#AT-amp-T-80386" class="headerlink" title="AT&amp;T-80386"></a>AT&amp;T-80386</h4><blockquote><p>在之前的汇编实验中，我们学习了16位的<code>Intel-8086</code>汇编。而在32位机器上需要使用32位的<code>80386</code>汇编语言。虽然对于<code>Linux</code>来说，<code>8086</code>和<code>80386</code>的机器是有很大的差别的，主要体现在实模式和保护模式上。但是就语言本身而言，更多的是递进的关系而语法差别并不大。目前还没有遇到保护模式相关的障碍。<br><code>x86</code>的汇编主要有两种格式:<code>Intel</code>和<code>AT&amp;T</code>。<code>6.828</code>使用的是<code>AT&amp;T</code>,而实际上Linux中的汇编也是后者居多。<strong>汇编语言本身主要有指令集<code>Instruction Set</code>和伪指令<code>Directives</code>两大部分内容</strong>。当然最全的文献是Intel自家的Documents，不过我觉得有些太杂和多了。下面的的资料在实验过程中帮了我很多。值得细看。</p></blockquote><ul><li>MIT—-<a href="https://pdos.lcs.mit.edu/6.828/2018/readings/pcasm-book.pdf" target="_blank" rel="noopener">pcasm-book</a>。</li><li>Wikipedia—-<a href="https://en.wikipedia.org/wiki/X86_instruction_listings#Added_with_80386" target="_blank" rel="noopener">x86 Instruction Set</a></li><li>Oracle—-<a href="https://docs.oracle.com/cd/E26502_01/html/E28388/eoiyg.html" target="_blank" rel="noopener">x86 Assembler Directives</a></li></ul><h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><blockquote><p>因为操作系统本身就是和硬件打交道最频繁的系统软件，有些地方需要使用到汇编来简单粗暴的完成工作。<strong>内联汇编</strong>就是嵌入在C语言中的汇编语言，格式和原来的有很大的不同。不过IBM的那份资料可以解决一大半问题，也是难得的中文文档……  </p></blockquote><ul><li>MIT—-<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">Brennan’s Guide to Inline Assembly</a></li><li>IBM—-<a href="https://www.ibm.com/developerworks/cn/linux/l-assembly/index.html" target="_blank" rel="noopener">汇编语言开发指南</a></li></ul><h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><blockquote><p>实名Diss网上各种对ELF的讲解，故意弄混<code>section</code>和<code>segment</code>的概念。加上对二进制工具使用的不熟练，让我一度以为链接的难度系数是整个实验过程中最高的……直到我看到<code>CSAPP</code>中关于链接部分的讲解。</p></blockquote><h4 id="编译驱动程序"><a href="#编译驱动程序" class="headerlink" title="编译驱动程序"></a>编译驱动程序</h4><blockquote><p><code>Compiler driver</code>指的是从C文件变成二进制文件的机器操作过程。我们从两个角度理解这个过程:<strong>机器运行的角度和C文件类型变化的角度</strong>。编译器和汇编器将多个<code>C</code>文件编译成相应的多个<strong>可重定位目标文件</strong>，也就是平时的<code>.o</code>文件，这种文件由不同的代码节和数据节构成，<strong>节</strong>在原文中是<code>section</code>。而链接器将多个<code>.o</code>文件链接成为一个<strong>可执行目标文件</strong>也就是平时的二进制文件。见下图:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/3.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>熟悉一个程序的第一步是关注其输入输出。一句话总结链接器的功能:<strong>以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</strong><br>站在机器的角度，编译器和汇编器将ASCII格式的C文件编译成为字节块<strong>section</strong>的集合，而链接器做的就是将<strong>不同</strong>可重定位目标文件中的各种<code>sections</code>做归类，<strong>确定被链接块的运行时的内存位置</strong>。这是重点，目标文件纯粹是字节块的集合，而链接器本身对程序也所知甚少，她做的仅仅是对<strong>字节文件</strong>做处理，将多个文件的字节块放到了一个文件中。</p></blockquote><h4 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h4><blockquote><p>链接器做两件事:</p><ul><li>符号解析: 输入文件的符号引用都对应到其定义上。</li><li>重定位: 编译器和汇编器生成的文件地址都是从0开始的，并没有和内存挂上关系。而链接器将这些不同的<code>section</code>定位到内存中的一个地址。也就是其加载地址。<br>重点关注第二步重定位，本质上就是将多个可重定位文件中同类型的<code>.section</code>合并为一个大的聚合节。但是注意这时候还没有<code>segment</code>的概念,聚合节还是叫做<code>.section</code>。我查阅了<code>CSAPP</code>的英文版，全书第一次提到<code>segment</code> 是在链接器部分的最末尾，也就是讲重定位的时候。下面是原文:  </li></ul></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/4.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>明显看到<code>segment</code>还是内存的概念而非可执行文件中的部分。所以从头到尾链接过程都没有生成过<code>segment</code>这样一种东西，其只是多个<code>sections</code>对应于内存中的<strong>映射</strong>。全书对链接部分的讲解也很少提及<code>segment</code>，<strong>所以我们对链接的理解最小单位应该是<code>section</code>，链接过程就是对<code>section</code>进行操作;而最后重定位的时候将多个大的<code>section</code>映射到一段内存中，映射的单位才是<code>segment</code></strong>。现在看下图就很清楚了:  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/5.png" width="300" height="200" alt="pic2" align="center"></p><blockquote><p>从文件类型的角度来看: 目前我们谈到的ELF文件有可重定位目标文件和可执行目标文件。可以使用二进制工具ELF文件进行分析。关于链接更本质的过程还是很复杂的，Lab1后面会有一部分和<strong>符号表</strong>相关的实验，建议先详细看看<code>CSAPP</code>和下面提供的资料。</p><ul><li>MIT—-<a href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf" target="_blank" rel="noopener">The definitive standard for the ELF format</a></li><li>Wikipedia—-<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="noopener">Executable and Linkable Format</a></li><li>ELF中文文档—-<a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf" target="_blank" rel="noopener">ELF.Ch</a></li></ul></blockquote><h3 id="二进制分析工具"><a href="#二进制分析工具" class="headerlink" title="二进制分析工具"></a>二进制分析工具</h3><blockquote><p>6.828中主要使用<code>objdump</code>，基本工具可以通过<code>man</code>来查看用法，这里列出几个最常见的参数。</p></blockquote><h4 id="Objdump"><a href="#Objdump" class="headerlink" title="Objdump"></a>Objdump</h4><blockquote><p>对目标文件进行分析，在Linux平台上有三种<code>object file</code>:<code>Relocatable object File</code>,<code>Executable object File</code>,<code>Shared object File</code>，一直没搞懂为啥都叫<code>object File</code>。不过因为这三种目标文件对应于链接的不同阶段，所以对于链接过程本质的理解直接影响这里使用这个二进制分析工具。</p></blockquote><ul><li><code>-f</code>  Display file headers</li><li><code>-d</code>  Disassembly</li><li><code>-h</code>  Section headers </li><li><code>-x</code>  All headers </li><li><code>-S</code>  Display source code</li></ul><h4 id="Nm"><a href="#Nm" class="headerlink" title="Nm"></a>Nm</h4><blockquote><p>列出目标文件中的符号表内容，应该和重定位关系密切。</p></blockquote><h3 id="阅读源码CLI工具"><a href="#阅读源码CLI工具" class="headerlink" title="阅读源码CLI工具"></a>阅读源码CLI工具</h3><blockquote><p>虽然我是<a href="https://www.gnu.org/software/emacs/" target="_blank" rel="noopener">Emacs</a>党，但是不得不承认VIM在进行文本操作的时候还是更<strong>方便:)</strong>一些。</p></blockquote><h4 id="VIM-Ctags"><a href="#VIM-Ctags" class="headerlink" title="VIM-Ctags"></a>VIM-Ctags</h4><blockquote><p>这个就很强大了，用于在<code>tags</code>文件所在的根目录下寻找函数声明和宏定义，在阅读源码的时候基本上不知道的定义和关键字都可以使用<code>Ctags</code>来进行定位，非常实用。<br>安装成功之后，在工程目录下面执行命令<code>ctags -R *</code>对当前目录递归建立索引，会生成<code>tags</code>文件。在源码中遇到未见过的函数便将光标放在其上<code>Ctrl - }</code>即可跳转到其声明的位置。<code>Ctrl - o</code>自动返回。</p></blockquote><h4 id="VIM-TagList"><a href="#VIM-TagList" class="headerlink" title="VIM_TagList"></a>VIM_TagList</h4><blockquote><p>这个实际上没怎么用，功能是在VIM中打开目录树，便于程序员操作。可以先留下来，进一步观察。</p></blockquote><h4 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h4><blockquote><p>这又是一个神器，终端分屏功能强大，有<code>window</code>,<code>pannel</code>等概念。和<code>on-my-zsh</code>配合使用简直了。不愿意折腾的话也可以在<code>bash</code>下直接使用。我们在<code>GDB</code>调试OS的时候使用她作为分屏工具，需要在家目录下加入配置文件<code>~/.tmux.conf</code>。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/1.png" width="300" height="200" alt="pic1" align="center"></p></blockquote><h4 id="VimGrep"><a href="#VimGrep" class="headerlink" title="VimGrep"></a>VimGrep</h4><blockquote><p>用于在指定目录下进行全局搜索并在另一个窗口打开;关键字<code>sample</code>;在vim命令模式下执行命令；</p><ul><li>:<code>vim/sample/% | copen</code>  当前文件搜索</li><li>:<code>vim/sample/* | copen</code>  当前目录搜索</li><li>:<code>vim/sample/ ../** | copen</code> 从上一级目录开始递归搜索</li><li>:<code>vim/sample path1/**  path2/** | copen</code> 多路径搜索</li><li>: <code>cclose</code> 关闭当前搜索<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/MIT6.828/2.png" width="300" height="200" alt="pic2" align="center"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lab0&quot;&gt;&lt;a href=&quot;#Lab0&quot; class=&quot;headerlink&quot; title=&quot;Lab0&quot;&gt;&lt;/a&gt;Lab0&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从&lt;code&gt;8086汇编&lt;/code&gt;实验之后，前后两周的时间勉强通过Lab1。&lt;br&gt;最大的感触是&lt;strong&gt;基础太差&lt;/strong&gt;:对C语言的理解，对程序编译链接本质的理解，对&lt;code&gt;GDB&lt;/code&gt;等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。&lt;br&gt;但是这次触动中却又多了一丝&lt;code&gt;见山不是山，见山又是山&lt;/code&gt;的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如&lt;code&gt;printf&lt;/code&gt;函数的实现就涉及C语言中变参的特性。有理由相信这种&lt;strong&gt;血浓于水&lt;/strong&gt;的关系在后续的Lab中还会进一步加强，所以我也希望这会是我学习OS最完美的方法论——————&lt;strong&gt;Talk is cheap, show me the code.&lt;/strong&gt;。&lt;br&gt;截止到Lab1，整个学习的过程显得很清晰————就是&lt;strong&gt;通过调试&lt;code&gt;kernel&lt;/code&gt;的反汇编代码来理解运行原理并加以修改&lt;/strong&gt;。Lab0是我在实验过程中掉进的坑，查阅的资料和逐渐点亮的技能树，缩短实验前的准备时间对理解OS本身还是很有帮助的。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Linux" scheme="http://haotianmcihael.github.io/tags/Linux/"/>
    
      <category term="C" scheme="http://haotianmcihael.github.io/tags/C/"/>
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="MIT 6.828" scheme="http://haotianmcihael.github.io/tags/MIT-6-828/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch5</title>
    <link href="http://haotianmcihael.github.io/2018/10/16/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch5/"/>
    <id>http://haotianmcihael.github.io/2018/10/16/汇编语言（王爽）ch5/</id>
    <published>2018-10-15T16:32:55.000Z</published>
    <updated>2018-10-15T13:09:54.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五部分-中断II"><a href="#第五部分-中断II" class="headerlink" title="第五部分:中断II"></a>第五部分:中断II</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>CPU实现I/O功能的两个问题:从何处获得外设的输入？如何解决外设输入随时可能发生的问题？首先外设芯片内部有若干寄存器，CPU将这些寄存器当做端口来访问。外设的输入输出不直接送入CPU和内存而是通过这些寄存器。第二，CPU通过外中断控制I/O的随时性。<br><a id="more"></a></p></blockquote><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><blockquote><p>CPU可以直接读写三个地方的数据:</p><ul><li>内部寄存器</li><li>内存单元</li><li>端口<br>CPU通过端口地址来定位不同的端口，最多可以定位64KB个端口，则端口地址范围为<code>0~65535</code>。端口的读写指令<code>in</code>和<code>out</code>。只能使用<code>al</code>和<code>ax</code>来存放对端口进行读写的数据。</li></ul></blockquote><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><blockquote><p>外中断是由相关芯片发送给CPU中的。分为<strong>可屏蔽中断</strong>和<strong>不可屏蔽中断</strong>。不可屏蔽中断指那些CPU一定需要响应的中断，这种中断很少，中断类型码固定为2。大多数外中断指的是可屏蔽中断。<br>CPU要不要响应可屏蔽中断完全取决于状态寄存器的<code>IF</code>位。为1则响应，否则不响应。8086中手动设置<code>IF</code>的指令:</p><ul><li><code>sti</code>:设置为1</li><li><code>cli</code>:设置为0</li></ul></blockquote><h3 id="实验-编写9号中断例程"><a href="#实验-编写9号中断例程" class="headerlink" title="实验 编写9号中断例程"></a>实验 编写9号中断例程</h3><h4 id="PC机键盘的处理过程"><a href="#PC机键盘的处理过程" class="headerlink" title="PC机键盘的处理过程"></a>PC机键盘的处理过程</h4><blockquote><p>键盘中有一个芯片扫描每一个键的状态——按下还是松开。按下产生一个扫描码称为<strong>通码</strong>，松开也产生一个扫描码称为<strong>断码</strong>。<code>断码=通码+80h</code>。扫描码被送到<code>60h</code>端口中。<br><code>int 9h</code>是BIOS提供的不可屏蔽中断。一旦CPU收到该信号:</p><ul><li>读出<code>60h</code>端口的扫描码</li><li>如果是字符键的扫描码，将该扫描码和所对应的字符码送入内存中的BIOS键盘缓存区(16个字单元)。如果是控制键(Ctrl)和切换键(CapsLock)的扫描码，则将其转变为状态字节写进内存中存储状态字节的单元。</li><li>对键盘系统进行相关的控制。  </li></ul></blockquote><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><blockquote><p>在屏幕中间依次显示”a”~”z”,在显示的过程中按下Esc键后改变颜色。<br>实验有意思的地方在于:因为键盘上所有的键都会触发<code>int 9h</code>中断，<strong>需要在保证其他键无效的情况下，Esc键触发中断</strong>————就相当于出现了两个中断例程，两个中断向量。更有趣的是需要这两个中断同时有效，在一个<code>int 9h</code>中断下！<br>方法也很简单，就是使用<code>if_else</code>判断扫描码。当然汇编中没有<code>if_else</code>。    </p></blockquote><h4 id="中断向量和中断例程"><a href="#中断向量和中断例程" class="headerlink" title="中断向量和中断例程"></a>中断向量和中断例程</h4><blockquote><p>键盘无论是哪一个键当然只会触发<code>int 9h</code>中断这个不会变。不过得分别写例程:   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,128</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line"></span><br><span class="line">push es:[9*4]</span><br><span class="line">pop ds:[0]</span><br><span class="line">push es:[9*4+2]</span><br><span class="line">pop ds:[2]</span><br><span class="line"></span><br><span class="line">mov word ptr es:[9*4],offset int 9</span><br><span class="line">mov es:[9*4+2],cs</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码主要就是设置了中断向量表。可以看到讲原来的<code>int 9h</code>中断例程地址保存在ds:0,ds:2地址处，换上新的例程地址<code>cs:(offset int 9)</code>。新的例程代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int9:push ax</span><br><span class="line">push bx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">in al,60h</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">call dword ptr ds:[0]   ;这里的实际上模拟了int 9中断例程的功能，实现子程序中的调用</span><br><span class="line"></span><br><span class="line">cmp al,1</span><br><span class="line">jne int9ret</span><br><span class="line"></span><br><span class="line">;下面是Esc例程代码</span><br><span class="line"></span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">inc byte ptr es:[160*12+40*2+1]  ;改变属性值，改变颜色</span><br><span class="line"></span><br><span class="line">int9ret:pop es</span><br><span class="line">pop bx</span><br><span class="line">pop ax</span><br><span class="line">iret</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>其中<code>cmp al,1</code>和<code>jne int9ret</code>就相当于<code>if_else</code>的功能。在主程序中有了栈，栈在中断例程中的主要作用就是保护现场，分析一下:  </p><ul><li>需要保护最开始的<code>int 9h</code>的中断向量号</li><li>因为在显示字符的主程序中，<code>ax</code>,<code>es</code>,<code>bx</code>都保存了重要的中间参数，所以需要保护<br>除此之外,栈并没有起到什么作用。这样看下来其实源程序也简单了不少。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/25.png" alt="pic25"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第五部分-中断II&quot;&gt;&lt;a href=&quot;#第五部分-中断II&quot; class=&quot;headerlink&quot; title=&quot;第五部分:中断II&quot;&gt;&lt;/a&gt;第五部分:中断II&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CPU实现I/O功能的两个问题:从何处获得外设的输入？如何解决外设输入随时可能发生的问题？首先外设芯片内部有若干寄存器，CPU将这些寄存器当做端口来访问。外设的输入输出不直接送入CPU和内存而是通过这些寄存器。第二，CPU通过外中断控制I/O的随时性。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch4</title>
    <link href="http://haotianmcihael.github.io/2018/10/12/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch4/"/>
    <id>http://haotianmcihael.github.io/2018/10/12/汇编语言（王爽）ch4/</id>
    <published>2018-10-11T21:11:38.000Z</published>
    <updated>2018-10-15T08:01:05.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四部分-中断I"><a href="#第四部分-中断I" class="headerlink" title="第四部分:中断I"></a>第四部分:中断I</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote><p>在之前的实验中，我们所编写的汇编程序从编译到运行出结果都很顺利。这个过程映射到CPU层面就是<code>CS:IP</code>的跳转<strong>唯一取决于</strong>汇编程序员的代码。<code>CSAPP</code>将这个过程称为<strong>程序控制流</strong>。而<strong>中断</strong>则是将这种流程打断，建立更复杂的<strong>异常控制流</strong>。中断分为<code>内中断</code>和<code>外中断</code>两种。<br><a id="more"></a></p></blockquote><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><h4 id="中断产生"><a href="#中断产生" class="headerlink" title="中断产生"></a>中断产生</h4><blockquote><p>8086CPU使用<strong>中断类型码</strong>来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种<strong>中断信息的来源</strong>————具体指的是产生中断信息的事件，简称<strong>中断源</strong>。下面是8086中4种常见的中断源及其中断类型码:  </p><ul><li>除法错误: 0</li><li>单步执行: 1</li><li>执行<code>into</code>指令: 4</li><li>执行<code>int n</code>指令: n</li></ul></blockquote><h4 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h4><blockquote><p>CPU获得<strong>中断类型码</strong>之后，需要跳转到该<strong>中断类型码</strong>对应的<strong>中断处理程序</strong>中进行处理。如何跳转呢？使用<strong>中断向量表</strong>。而跳转通常意味着改变CPU的状态，所以需要使用栈来保存现场。所以<strong>识别</strong>，<strong>保存</strong>和<strong>跳转</strong>就是中断过程主要干的事儿————其中识别由硬件完成！<br><strong>中断向量表</strong>保存在内存<code>0000:0000</code>到<code>0000:03FF</code>的这1KB单元里。一个表项存放一个<strong>中断向量</strong>————也就是中断处理程序的地址入口。占4个字节，高地址放段地址，低地址放偏移地址。</p></blockquote><h5 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h5><blockquote><p>下图是一张8086的内存分布图:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/14.png" alt="pic14"><br>从内存0开始，所以存储<code>N号中断源对应的中断向量的偏移地址</code>的内存地址为:<code>0000:4N</code>，存储<code>N号中断源对应的中断向量的段地址</code>的内存地址为:<code>0000：4N+2</code>。看下图:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/15.png" alt="pic15">  </p></blockquote><h5 id="跳转和保存"><a href="#跳转和保存" class="headerlink" title="跳转和保存"></a>跳转和保存</h5><ul><li>获得中断类型码</li><li>标志寄存器的值入栈: <code>pushf</code></li><li>设置标志寄存器第8位TF和第9位IF的值位0: TF=0,IF=0</li><li>CS的内容入栈: <code>push CS</code></li><li>IP的内容入栈: <code>push IP</code></li><li>通过中断类型码获取入口地址: <code>(IP)=(N*4),(CS)=(N*4+2)</code></li><li>最后一步执行结束后，CPU开始执行由程序员编写的中断处理程序  </li></ul><h4 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h4><blockquote><p>所谓中断处理程序就是操作系统对各种中断的反应。 由于CPU随时可能检测到中断，所以中断处理程序必须一直存储在内存某段空间中。下面的实验就是通过来实现内中断处理程序。</p></blockquote><h5 id="0号中断"><a href="#0号中断" class="headerlink" title="0号中断"></a>0号中断</h5><blockquote><p>即除法溢出错误。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000h</span><br><span class="line">mov bh,1</span><br><span class="line">div bh</span><br></pre></td></tr></table></figure><blockquote><p>该除法指令在执行的过程中会发生溢出错误，导致产生0号中断从而引发中断过程。</p></blockquote><h4 id="实验-编写0号中断的处理程序"><a href="#实验-编写0号中断的处理程序" class="headerlink" title="实验 编写0号中断的处理程序"></a>实验 编写0号中断的处理程序</h4><ul><li>中断类型码:0</li><li>中断处理程序: 选择<code>0000：0200</code>到<code>0000：02ff</code>这256个Bytes内存的区域来存放</li><li>中断向量表: 0号中断的段地址<code>0000:0002</code>偏移地址<code>0000:0000</code><h5 id="安装处理程序do0"><a href="#安装处理程序do0" class="headerlink" title="安装处理程序do0"></a>安装处理程序<code>do0</code></h5><blockquote><p>得确保中断处理程序不会变动，所以选择一块合适的内存区域将其安装进去。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,cs</span><br><span class="line">   mov ds,ax</span><br><span class="line">   mov si,offset do0  ;设置ds:si指向被拷贝的程序地址</span><br><span class="line">   mov ax,0</span><br><span class="line">   mov es,ax  ;设置es:di指向拷贝的目的地址</span><br><span class="line">   mov di,200h</span><br><span class="line">   </span><br><span class="line">   mov cx,offset do0end-offset do0   ;设置需要拷贝的代码长度度</span><br><span class="line">   </span><br><span class="line">   cld  ;设置传输方向为正</span><br><span class="line">   rep movsb</span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">   设置中断向量表</span><br><span class="line">   */</span><br><span class="line">   </span><br><span class="line">   mov ax, 4c00h</span><br><span class="line">   int 21h</span><br><span class="line">   </span><br><span class="line">do0:   jmp short do0start</span><br><span class="line">   db &quot;overflow!&quot;</span><br><span class="line">   </span><br><span class="line">do0start:mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov si,200h   ;设置ds:si指向字符串</span><br><span class="line"> </span><br><span class="line">mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,12*160+36*2 ;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">mov cx,9 ;字符串的长度</span><br><span class="line">s:  mov al,[si]</span><br><span class="line">mov es:[di],al</span><br><span class="line">inc si</span><br><span class="line">add di,2  </span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">   </span><br><span class="line">   do0end: nop</span><br><span class="line">   </span><br><span class="line">   code ends</span><br><span class="line">   end start</span><br></pre></td></tr></table></figure><h5 id="设置中断向量号"><a href="#设置中断向量号" class="headerlink" title="设置中断向量号"></a>设置中断向量号</h5><blockquote><p>当中断发生的时候，确保0号中断的处理程序跳转地址是上一个设置好的地址。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[0*4],200h</span><br><span class="line">mov word ptr es:[0*4+2], 0</span><br></pre></td></tr></table></figure><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><blockquote><p>注意，在跳转到中断处理程序之前，所有的CPU现场已经入栈保存好了，而跳转过程本身也是硬件过程，所以我们所做的仅仅只是设置好<strong>跳转的地址</strong>和<strong>该地址相应的处理代码</strong>。<br><strong>经过实验发现DOSBox的和传统的DOS还是有一些区别的，这里用一个小实验验证中断:</strong>首先我们直接在debug下面将<code>0号中断向量号改写成为0000:0200处</code>，然后在另一块内存<code>0200:0000</code>中写进了会引发0号中断的代码:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/16.png" alt="pic16"><br>然后修改好了<code>CS:IP</code>地址并开始执行:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/17.png" alt="pic17">  </p></blockquote><h6 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h6><blockquote><p><strong>单步执行,可以看到<code>CS:IP</code>的值在执行到<code>div bh</code>的时候，立马从<code>0200:0005</code>变成了<code>0000:0002</code>!,我写的中断处理<code>mov cx,ffff</code>也被执行！然后一直执行到结束退出。</strong><br>实验的整个过程实际上就是做了一个跳转，然后我们仔细对比一下跳转前后寄存器值的差距:<strong>会发现除了<code>CS:IP</code>有变化之外，<code>SS:SP</code>大小也有变化，这是<code>CPU</code>保存现场的缘故————从<code>00F7</code>到<code>00FD</code>共3个字对应<code>CS</code>，<code>IP</code>和<code>TF</code>；而且<code>状态寄存器EI也变为DI</code>,估计也和<code>TF</code>和<code>IF</code>相关;因为我们的中断处理直接退出程序所以栈中的数据没有派上用场，不过如果需要返回源程序做一些操作的时候栈就会起到恢复的作用。</strong>我还尝试过在中断产生的时候查看栈中的内容，但是每次指令刚执行就被强制退出……不知道为什么。<strong>不过这是下一个实验的内容了。</strong>另外，这里可以回过头看一下<strong>ch2</strong>中关于栈的那个猜测，基本上没有毛病。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/18.png" alt="pic18">  </p></blockquote><h5 id="1号中断"><a href="#1号中断" class="headerlink" title="1号中断"></a>1号中断</h5><blockquote><p>在CPU保存现场的时候，对状态寄存器压栈，并且将其中两个状态位设置为零:TF=0;IF=0;主要是因为当<strong>CPU</strong>每执行完一条指令<strong>的时候，就会去查看状态寄存器的TF位是否为1，如果是则引发1号中断————单步中断</strong>。整个中断的过程和其他的没有什么区别，作者提到<code>debug -t</code>的单步执行功能，实际上就是通过debug调用1号中断对CPU进行控制。这里的控制主要体现在中断处理程序上————比如<code>debug -t</code>就是设置寄存器的值显示在屏幕上。那为什么要在处理之前又将<code>TF</code>设置为零呢？注意前面的<code>每执行完一条指令</code>的意思，CPU在执行中断处理程序的时候是不能响应其他中断的，<code>TF=0</code>是防止在过程中递归的陷入。  </p></blockquote><blockquote><p>但是在有些特殊情况下中断的产生，CPU不见得马上处理。比如<code>mov ss, ax</code>和<code>MOV sp, 10</code>这两条设置堆栈的指令，在前面的实验中出现过。</p></blockquote><h3 id="int-指令"><a href="#int-指令" class="headerlink" title="int 指令"></a>int 指令</h3><h4 id="中断例程"><a href="#中断例程" class="headerlink" title="中断例程"></a>中断例程</h4><blockquote><p><code>int n</code>是一种很重要的内中断。<code>n</code>是中断类型码，该条指令功能就是可以引发中断过程。执行如下:</p><ul><li>取终端类型码n</li><li>标志寄存器入栈，IF=0,TF=0</li><li><code>push cs</code>,<code>push ip</code></li><li>(IP)=(n<em>4),(CS)=(n</em>4+2)<br><strong>注意一下这里的压栈顺序，后面的实验中会有用到。</strong><br>一般情况下，系统会将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用，通常就是使用<code>int</code>指令。将这些自己编写的中断处理程序叫做中断例程。</li></ul></blockquote><h4 id="编写loop中断例程"><a href="#编写loop中断例程" class="headerlink" title="编写loop中断例程"></a>编写<code>loop</code>中断例程</h4><blockquote><p>在屏幕中间显示80个“！”。<br>这个程序一看就知道需要使用到<code>loop</code>指令，但是该指令到底是如何实现的呢？我们知道跳转指令实际上就是改变<code>CS:IP</code>的值，而<strong>给定次数的跳转</strong>和<strong>给定目标</strong>的跳转合在一起就会比较麻烦。<br><strong>跳转指令是靠两个标号之间的相对位移而不是靠标号的地址</strong>这一点很重要。我们用<code>cx</code>存放循环次数，用<code>bx</code>存放相对位移。先看一下例程代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0b800h   </span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12</span><br><span class="line"></span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:  mov byte ptr es:[di],&apos;!&apos;</span><br><span class="line">add di,2</span><br><span class="line">/*</span><br><span class="line">int 7ch例程代码:如果（cx）!=0,跳转到标号s处</span><br><span class="line">*/</span><br><span class="line">se: nop</span><br><span class="line"></span><br><span class="line">mov ax,4c00</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>至此，应该已经完全可以看懂这些汇编程序。可是核心的功能呢？如下:<br>跳转到标号s处需要知道s的段地址和偏移地址。先来分析一下在执行<code>int 7ch</code>之后发生了什么？画得不好凑活着看吧:)<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/19.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>x86中的栈是一个<strong>满堆栈</strong>。首先标志寄存器入栈，然后对se标号的CS:IP压栈。因为代码只有一个段，所以se的段地址和s的段地址一样。而<code>bx</code>中存储了<code>s-se</code>，所以对于s来说:<code>bx+se</code>就是它自己的偏移量。而se的偏移量就是栈中的<code>IP</code>。所以思路顺下来了。可以写代码了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lp: push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx      ;cx--</span><br><span class="line">jcxz lpret       ;if(cx=0) (cs:ip)=lpret</span><br><span class="line">add [bp+2],bx   ;重点</span><br><span class="line">lpret: pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中<code>add [bp+2],bx</code>就是前面刚顺下来的算法实现。将栈中的<code>IP</code>修改称为s的偏移地址。这里的重点是<code>iret</code>指令，这个指令和跳转指令经常组合在一起共同使用，相当于<code>pop ip</code>,<code>pop cs</code>,<code>popf</code>这三条指令的和。<strong>上述代码就是在栈中修改好<code>CS:IP</code>的值，然后使用<code>iret</code>出栈执行。</strong></p></blockquote><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><blockquote><p>本次实验的过程实际上就是分为两部分:<code>安装例程</code>和<code>执行例程</code>。</p></blockquote><h6 id="安装例程"><a href="#安装例程" class="headerlink" title="安装例程"></a>安装例程</h6><blockquote><p>对于<code>7ch</code>中断类型码来说，对应的中断例程地址应该在<code>0000:01f0</code>。我们<strong>首先将中断例程写进该地址，然后修改中断向量表项。</strong>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset do0</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200h</span><br><span class="line"></span><br><span class="line">mov cx,offset do0end-offset do0   ;将中断例程写进对应的地址中</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br><span class="line"></span><br><span class="line">mov ax,0   ;这4行代码修改中断向量表</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200h</span><br><span class="line">mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">do0:    ;这是中断例程</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret</span><br><span class="line">add [bp+2],bx</span><br><span class="line">lpret:pop bp</span><br><span class="line">iret</span><br><span class="line"></span><br><span class="line">do0end:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>我们将上述代码保存为<code>sample.asm</code>然后编译连接。然后执行<code>sample.exe</code>:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/20.png" alt="pic20"><br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/21.png" alt="pic21"><br>上图分别是地址<code>0000:0200</code>处的<strong>中断例程</strong>，和<code>0000:01f0</code>处的<strong>中断向量表</strong>。可以看到成功写入内存。</p></blockquote><h6 id="执行例程"><a href="#执行例程" class="headerlink" title="执行例程"></a>执行例程</h6><blockquote><p>执行程序就是调用<code>int 7ch</code>这个例程看是否有效。我们将执行程序保存为<code>demo.asm</code>编译连接。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,0b800h</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,160*12 ;确定显存的地址</span><br><span class="line"></span><br><span class="line">mov bx,offset s-offset se</span><br><span class="line">mov cx,80</span><br><span class="line">s:mov byte ptr es:[di],&apos;!&apos;</span><br><span class="line">add di,2</span><br><span class="line">int 7ch    ;在这里int指令充当了loop的功能</span><br><span class="line"></span><br><span class="line">se:nop</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>然后执行<code>demo.exe</code>,看现象:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/22.png" alt="pic22"></p></blockquote><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><blockquote><p>这是最简单的一个例程，不过我们可以因此得知<strong>跳转指令</strong>和<strong>栈</strong>的重要性!</p></blockquote><h4 id="BIOS和DOS所提供的中断例程"><a href="#BIOS和DOS所提供的中断例程" class="headerlink" title="BIOS和DOS所提供的中断例程"></a>BIOS和DOS所提供的中断例程</h4><blockquote><p>关于BIOS和DOS已经很熟悉了，从计算机加电开始，<code>CS:IP</code>会自动跳转到<code>ffff:0000</code>的地址执行程序，到底执行的是啥？有两大部分:<strong>自检程序</strong>和<strong>初始化程序</strong>。初始化程序将建立BIOS所支持的中断向量。BIOS中的中断例程主要有:  </p><ul><li>外部中断和内部中断的中断例程</li><li>用于对硬件设备进行I/O操作的中断例程</li><li>其他和硬件系统相关的中断例程  </li></ul></blockquote><blockquote><p>自检和初始化完成之后，调用<code>int 19h</code>进行操作系统的引导。而DOS也有自己的中断例程，这些中断例程是操作系统提供给程序员的资源。另外，DOS和硬件设备相关的中断例程一般都是调用了BIOS的中断例程。每一个中断例程都是由很多的子程序构成的。不管是BIOS还是DOS的中断例程都通过<code>ah</code>来传递内部子程序的编号。</p></blockquote><h5 id="BIOS中断例程"><a href="#BIOS中断例程" class="headerlink" title="BIOS中断例程"></a>BIOS中断例程</h5><blockquote><p><strong>int 10h</strong>用来设置和字符和光标。见代码:  </p></blockquote><blockquote><p>看现象:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/23.png" alt="pic23">  </p></blockquote><blockquote><p>下面是代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ah,2    ;置光标</span><br><span class="line">mov bh,0;第0页</span><br><span class="line">mov dh,5;行号</span><br><span class="line">mov dl,12;列号</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ah,9   ;在光标位置显示字符</span><br><span class="line">mov al, &apos;a&apos;  ;字符</span><br><span class="line">mov bl,11001010b   ;颜色属性</span><br><span class="line">mov bh,0    ;第0页</span><br><span class="line">mov cx,5   ;字符重复个数</span><br><span class="line">int 10h</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h </span><br><span class="line"></span><br><span class="line">code ends </span><br><span class="line">end</span><br></pre></td></tr></table></figure><h5 id="DOS中断例程"><a href="#DOS中断例程" class="headerlink" title="DOS中断例程"></a>DOS中断例程</h5><blockquote><p>DOS中断<strong>int 21h</strong>，之前一直使用<strong>4ch00</strong>参数即程序返回功能。<br>参数<strong>ah=9</strong>表示调用第21h号中断例程的9号子程序:在光标位置上显示字符串.看现象:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/24.png" alt="pic24"><br>下面是代码:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &apos;Dos is shit!&apos;,&apos;$&apos;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">start:mov ah,2</span><br><span class="line">mov bh,0</span><br><span class="line">mov dl,12</span><br><span class="line">int 10h  ;BIOS 中断例程</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov dx,0</span><br><span class="line">mov ah,9</span><br><span class="line">int 21h   ;DOS中断例程</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第四部分-中断I&quot;&gt;&lt;a href=&quot;#第四部分-中断I&quot; class=&quot;headerlink&quot; title=&quot;第四部分:中断I&quot;&gt;&lt;/a&gt;第四部分:中断I&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在之前的实验中，我们所编写的汇编程序从编译到运行出结果都很顺利。这个过程映射到CPU层面就是&lt;code&gt;CS:IP&lt;/code&gt;的跳转&lt;strong&gt;唯一取决于&lt;/strong&gt;汇编程序员的代码。&lt;code&gt;CSAPP&lt;/code&gt;将这个过程称为&lt;strong&gt;程序控制流&lt;/strong&gt;。而&lt;strong&gt;中断&lt;/strong&gt;则是将这种流程打断，建立更复杂的&lt;strong&gt;异常控制流&lt;/strong&gt;。中断分为&lt;code&gt;内中断&lt;/code&gt;和&lt;code&gt;外中断&lt;/code&gt;两种。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch3</title>
    <link href="http://haotianmcihael.github.io/2018/10/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch3/"/>
    <id>http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/</id>
    <published>2018-10-10T21:29:35.000Z</published>
    <updated>2018-10-13T02:06:40.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三部分-指令核心"><a href="#第三部分-指令核心" class="headerlink" title="第三部分:指令核心"></a>第三部分:指令核心</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><blockquote><p>内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，<strong>注意这里的内存指的是内存地址空间</strong>。<br>CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。<br><a id="more"></a><br>寻址的方式有很多种类 ，不过归结到底都是<code>段地址+偏移地址</code>。段地址存储在段寄存器中，而偏移地址的方式就有很多种。见下图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/%2013.png" alt="pic13">  </p></blockquote><blockquote><p>需要注意的是:</p><ul><li>上图中的<code>idata</code>表示立即数，<code>[]</code>表示偏移地址。<code>(ax)</code>表示寄存器ax的内容。</li><li><code>[]</code>中的除了立即数之外，只有<code>bx</code>,<code>si</code>,<code>di</code>和<code>bp</code>四个寄存器可以进行寻址，其他的寄存器不行。</li><li><code>[bp]</code>的段寄存器默认是<code>ss</code>。</li><li>编译器masm和调试器debug两个工具对于<code>mov ax,[idata]</code>中的<code>idata</code>处理不同，编译器会将其识别为<code>idata</code>,所以在使用编译器的时候这种形式应该写成<code>mov ax,ds:[idata]</code></li></ul></blockquote><h4 id="数据处理-总结性质"><a href="#数据处理-总结性质" class="headerlink" title="数据处理(总结性质)"></a>数据处理(总结性质)</h4><blockquote><p>计算机处理的最终还是数据，那么就有两个最基本的问题:</p><ul><li>处理的数据在什么地方？</li><li>要处理的数据有多长？</li></ul></blockquote><h5 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h5><blockquote><p>绝大部分机器指令都是进行数据处理的指令，处理大致分为三类:读取，写入，运算。在机器指令这一层来说并不关心数据的值，而关心<strong>指令执行前一秒，将要处理的数据所在的位置</strong>。指令在执行之前，所要处理的数据可以在三个地方:CPU内部，寄存器，端口。</p></blockquote><h5 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h5><blockquote><p>8086指令可以处理两种尺寸的数据:Byte和Word。所以在机器指令中需要指明是字操作和字节操作。  </p><ul><li>通过寄存器指明:<code>ax</code>，<code>al</code>等</li><li>用操作符<code>X ptr</code>指明内存单元的长度，<code>X</code>是<code>word</code>或者<code>byte</code>。比如:<code>mov byte ptr ds:[0],1</code>。</li><li>还有一些默认的操作比如栈操作默认为字操作。</li></ul></blockquote><h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4><h5 id="伪指令补充"><a href="#伪指令补充" class="headerlink" title="伪指令补充"></a>伪指令补充</h5><ul><li><code>db</code>    定义字节型数据</li><li><code>dw</code>  定义字型数据</li><li><code>dd</code>  定义双字节型数据</li><li><code>dup</code> 和前面三个伪指令结合使用，用来进行数据的重复。<code>db 3 dup(1,2,3)</code>表示定义的三个字节型数据分别为1,2,3。</li></ul><h5 id="LOOP循环指令"><a href="#LOOP循环指令" class="headerlink" title="LOOP循环指令"></a>LOOP循环指令</h5><blockquote><p>主要进行两步操作，（cx）=(cx)-1，判断cx中的值。不为零则转至标号处执行程序，如果为零则向下执行。可见<code>cx</code>中的值影响了loop指令的执行结果。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><h5 id="JMP转移指令"><a href="#JMP转移指令" class="headerlink" title="JMP转移指令"></a>JMP转移指令</h5><blockquote><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的的指令。<br>根据修改的方式，只修改IP的称为<code>段内转移</code>，修改IP和CS的称为<code>段间转移</code>。由于转移指令对IP的修改范围不同，段内转移又分为:<code>短转移（8位）</code>和<code>近转移（16位）</code>。不同的转移方式，其基本的原理确实相同的。  </p></blockquote><h6 id="1-JMP-short-offset"><a href="#1-JMP-short-offset" class="headerlink" title="1-JMP short offset"></a>1-JMP short offset</h6><blockquote><p>转移指令值得注意的点就是offset指的不是确定的地址，而是从标号到指令之间的位移。<br><code>(IP)=(IP)+8位位移</code>，段内短转移的位移范围位8位有符号数，用补码表示。<code>offset处的地址-JMP指令后的第一个字节的地址</code>。 </p></blockquote><h6 id="1-JMP-near-ptr-offset"><a href="#1-JMP-near-ptr-offset" class="headerlink" title="1-JMP near ptr offset"></a>1-JMP near ptr offset</h6><blockquote><p><code>(IP)=(IP)+16位位移</code> ,段内近转移的位移范围是16位有符号数，用补码表示。原理和前者一样。</p></blockquote><h6 id="2-JMP-far-ptr-offset"><a href="#2-JMP-far-ptr-offset" class="headerlink" title="2-JMP far ptr offset"></a>2-JMP far ptr offset</h6><blockquote><p>前面的几种类型地址都是通过offset和位移，而接下来的几种是在寄存器和内存中的给定IP或者CS。<strong>内存地址单元可以用任意的寻址方式得到。</strong><br><code>（CS）=标号所在段的段地址</code>，<code>（IP）=标号所在段中的偏移地址</code> 。段间转移，会发现其跳转地址实际上是在指令中的offset的地址。和前两个还是有区别的。</p></blockquote><h6 id="2-JMP-16位reg"><a href="#2-JMP-16位reg" class="headerlink" title="2-JMP 16位reg"></a>2-JMP 16位reg</h6><blockquote><p>最基础的跳转指令，只是修改IP=16位的寄存器中内容。 </p></blockquote><h6 id="2-JMP-word-ptr-内存单元地址"><a href="#2-JMP-word-ptr-内存单元地址" class="headerlink" title="2-JMP word ptr 内存单元地址"></a>2-JMP word ptr 内存单元地址</h6><blockquote><p>比如:<code>jmp word ptr ds:[0]</code>中<code>ptr</code>后面的就是一个地址，<code>jmp word ds:[0],0</code>后面跟两个地址。注意<strong>（CS）=(内存地址单元+2)，（IP）=（内存地址单元）</strong>。</p></blockquote><h6 id="2-jcxz"><a href="#2-jcxz" class="headerlink" title="2-jcxz"></a>2-jcxz</h6><blockquote><p>该指令为有条件转移指令，<strong>所有的有条件转移指令都是短转移</strong>。方式为:<br><code>if((cx)==0)jmp short offset</code><br>另外，所有的<code>loop</code>循环指令都是短转移。</p></blockquote><h5 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h5><h6 id="ret-近转移"><a href="#ret-近转移" class="headerlink" title="ret(近转移)"></a>ret(近转移)</h6><blockquote><p>书中说<strong>ret指令用栈中的数据修改IP中的内容</strong>。之前对栈有一个分类，这里的栈是<strong>满递减堆栈</strong>。所以由此可知堆栈指针<code>SP</code>一直指向最后一个压栈的数据。<code>ret</code>指令实际上把堆栈中的最后一个数据作为自己跳转的偏移地址。方式如下:<br><code>(IP)=((ss)*16+(sp))</code>,<code>(sp)=(sp)+2</code><br>从上面也可以看出来这两条指令等同于:<code>pop IP</code></p></blockquote><h6 id="retf-远转移"><a href="#retf-远转移" class="headerlink" title="retf(远转移)"></a>retf(远转移)</h6><blockquote><p>书中说<strong>retf指令用栈中的数据修改IP和CS中的内容</strong>。类似:<br><code>(IP)=((ss)*16+(sp))</code>,<code>(sp)=(sp)+2</code><br><code>（CS）=（（ss）*16+(sp)）</code>,<code>(sp)=(sp)+2</code><br>这四条指令等同于:<code>pop IP</code>,<code>pop CS</code></p></blockquote><h6 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h6><blockquote><p>call指令不能实现短转移，但是其转移的原理和jmp指令相同。如下：<br><code>(sp)=(sp)-2</code>,<code>((ss)*16+(sp))=(IP)</code>,<code>(IP)=(IP)+16位位移</code>这几条指令相当于:<br><code>push IP</code>和<code>jmp near ptr offset</code></p></blockquote><h6 id="call和ret指令-子程序"><a href="#call和ret指令-子程序" class="headerlink" title="call和ret指令(子程序)"></a>call和ret指令(子程序)</h6><blockquote><p>先看一段代码:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,1</span><br><span class="line">   mov cx,3</span><br><span class="line">   call s</span><br><span class="line">   mov bx,ax</span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">s: add ax,ax</span><br><span class="line">   loop s</span><br><span class="line">   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><blockquote><p>程序执行到<code>call s</code>的时候，IP指向了后面的一条指令，然后CPU执行<code>call s</code>指令————<code>将当前的IP（mov bx,ax的地址）压栈，然后修改为s地址</code>。然后子程序开始执行，执行结束之后执行<code>ret</code>指令————<code>从栈中弹出一个值，将CS:IP的值指向mov bx,ax</code>。然后返回为原来的地址。这两条指令为子程序的调用提供了可能。</p></blockquote><h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><blockquote><p>寄存器是汇编程序员解决问题的最有利的手段，不仅仅在于可以存储数据，还具有辅助指令执行的功能。标志寄存器就是如此，<strong>用来存储CPU执行指令的某些执行结果。</strong>存储的信息称为“程序状态字PSW”。状态寄存器的每一位都有具体的含义。下面分别介绍:  </p></blockquote><h5 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h5><blockquote><p>零标志位，相关指令执行结束如果结果为0，zf=1；如果不为0，zf=0.</p></blockquote><h5 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h5><blockquote><p>奇偶标志位，相关指令执行结束如果结果的所有bit位中1的个数为偶数，pf=1,否则pf=0.</p></blockquote><h5 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h5><blockquote><p>符号标志位，相关指令执行结束如果结果为负，sf=1；否则sf=0。<strong>该标志是CPU对有符号数计算结果的一种记录。</strong></p></blockquote><h5 id="CF标志"><a href="#CF标志" class="headerlink" title="CF标志"></a>CF标志</h5><blockquote><p>进位标志位，在进行<strong>无符号</strong>数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</p></blockquote><h5 id="OF标志"><a href="#OF标志" class="headerlink" title="OF标志"></a>OF标志</h5><blockquote><p>溢出标志位，在进行<strong>有符号</strong>数运算的时候，记录了是否发生溢出。</p></blockquote><h5 id="标志寄存器在Debug中的使用"><a href="#标志寄存器在Debug中的使用" class="headerlink" title="标志寄存器在Debug中的使用"></a>标志寄存器在Debug中的使用</h5><blockquote><p>标志寄存器是按照有意义的各个标志位单独表示的。如下。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/7.png" alt="pic7"><br>下图是已知的标志位的表示:<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/13.png" alt="pic13"></p></blockquote><h4 id="其他指令（总结性质）"><a href="#其他指令（总结性质）" class="headerlink" title="其他指令（总结性质）"></a>其他指令（总结性质）</h4><blockquote><p>还有很多的指令比如<code>MOV</code>,<code>CMP</code>，<code>abc</code>等。但这里并不打算详细讲解每一条指令，就像书中所说:<strong>汇编语言只是载体，目的在于理解机器运行的原理和方式。</strong><br>至此，我们已经学习了<code>寄存器</code>，<code>内存</code>,<code>汇编指令</code>，并且掌握了一个<strong>正常的程序控制流</strong>在机器层面的运行过程。接下来的内容，就属于操作系统的层面，引入<strong>异常控制流</strong>，也就是在正常的执行过程中有外界干扰的情况，这是理解整个OS的重点，也是我写这几篇技术博客的主要学习目的。(<code>mit6.828</code>中的汇编大同小异，只是指令集换成了AT&amp;T的格式)。</p></blockquote><h3 id="实验7-寻址方式在结构化数据访问中的应用"><a href="#实验7-寻址方式在结构化数据访问中的应用" class="headerlink" title="实验7 寻址方式在结构化数据访问中的应用"></a>实验7 寻址方式在结构化数据访问中的应用</h3><h3 id="实验9-根据材料编程"><a href="#实验9-根据材料编程" class="headerlink" title="实验9 根据材料编程"></a>实验9 根据材料编程</h3><h3 id="实验10-编写子程序"><a href="#实验10-编写子程序" class="headerlink" title="实验10 编写子程序"></a>实验10 编写子程序</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三部分-指令核心&quot;&gt;&lt;a href=&quot;#第三部分-指令核心&quot; class=&quot;headerlink&quot; title=&quot;第三部分:指令核心&quot;&gt;&lt;/a&gt;第三部分:指令核心&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;h4 id=&quot;内存寻址&quot;&gt;&lt;a href=&quot;#内存寻址&quot; class=&quot;headerlink&quot; title=&quot;内存寻址&quot;&gt;&lt;/a&gt;内存寻址&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，&lt;strong&gt;注意这里的内存指的是内存地址空间&lt;/strong&gt;。&lt;br&gt;CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch2</title>
    <link href="http://haotianmcihael.github.io/2018/10/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch2/"/>
    <id>http://haotianmcihael.github.io/2018/10/04/汇编语言（王爽）ch2/</id>
    <published>2018-10-03T20:26:50.000Z</published>
    <updated>2018-10-15T07:59:54.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二部分-汇编结构"><a href="#第二部分-汇编结构" class="headerlink" title="第二部分:汇编结构"></a>第二部分:汇编结构</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><h4 id="汇编语言的结构"><a href="#汇编语言的结构" class="headerlink" title="汇编语言的结构"></a>汇编语言的结构</h4><h5 id="寄存器和内存之间"><a href="#寄存器和内存之间" class="headerlink" title="寄存器和内存之间"></a>寄存器和内存之间</h5><blockquote><p>汇编语言是由不同的段构成的，这些段的功能各异不过主要分为<code>指令</code>和<code>数据</code>两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。<br><a id="more"></a><br><strong>字节存储和字存储</strong>就是两种解决办法，在8086中寄存器是16位的(16位为一字)，而存储器的最小存储单元是8位也就是一个字节，所以如果在一些读写中需要用到字存储而不是字节存储的话，就需要两块连续的内存单元才能完成数据的传输，而且是<strong>高地址存放字的高位字节，低地址存放字的低位字节</strong>。<br><strong>要读写一块内存单元的时候，必须先要给出这个内存单元的地址。</strong>在实验1中我们知道了CPU使用<code>段地址+偏移地址</code>的方式来进行寻址。而实现这些功能的就是一些具有特殊功能的寄存器。这里提到的是最简单的也最常使用的两种类型:  </p><ul><li><code>CS</code>+<code>IP</code>————在任意时刻CPU将CS:IP指向的内容当做指令执行。  </li><li><code>DS</code>+[idata]————<code>DS</code>通常用来存放需要访问的数据的段地址。<br><strong>这里主要介绍汇编语言的结构，对应到寄存器和内存寻址的方式后面会讲。</strong></li></ul></blockquote><h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5><blockquote><p>将一段内存当做数据段，是我们在编程的时候的一种安排，可以在具体操作的时候，<strong>用ds存放数据的段地址，</strong>再根据相关指令访问数据段中的具体单元。</p></blockquote><h5 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h5><blockquote><p>从硬件角度讲，CPU只认被CS:IP指向的内存单元中的内容为指令。要让CPU执行我们放在代码段的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。</p></blockquote><h5 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h5><blockquote><p>   <strong>栈是一种先进后出的数据结构</strong>，这是最基本的栈的概念。这里讲到的栈指的是内存区域。从操作系统的角度讲一个线程需要分配一个栈(stack)。相对应的一个进程需要分配一个堆(heap)。栈的大小在分配的时候就已经确定好了，其作用主要是存放一些局部和确定的变量和数据。<br>   关于栈也有两个寄存器:<code>SS:SP</code>。换句话讲CPU如何知道一段内存区域是不是栈？栈顶的段地址放在<code>SS</code>中，而偏移地址放在<code>SP</code>中。<strong>任意时刻，SS:SP指向栈顶元素</strong>。这是规定。<br>   另外，上微机原理课的时候，老师讲到栈的分类:  </p><ul><li>向高地址生长的称为递增堆栈。</li><li>向地地址生长的称为递减堆栈。<br> 地址延伸主要的影响就是内存中的大端寻址和小端寻址。<br>  <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/4.png" alt="pic4">  </li></ul></blockquote><ul><li>堆栈指针指向最后压入堆栈的有效数据项，叫做满堆栈。</li><li>堆栈指针指向下一个待压入数据的空位置，叫做空堆栈。<br>  <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/5.png" alt="pic5"></li></ul><h5 id="栈指令"><a href="#栈指令" class="headerlink" title="栈指令"></a>栈指令</h5><blockquote><p>   在i386的指令集中，栈操作都是以字为单位的。</p></blockquote><h6 id="push执行过程"><a href="#push执行过程" class="headerlink" title="push执行过程"></a>push执行过程</h6><pre><code>1. SP=SP-2;2. 向`SP:SS`指向的内存字单元中送入数据;</code></pre><h6 id="pop执行过程"><a href="#pop执行过程" class="headerlink" title="pop执行过程"></a>pop执行过程</h6><pre><code>1. 从`SP:SS`指向的内存字单元中读取数据;2. SP=SP+2;</code></pre><h5 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h5><blockquote><p>   之前讨论过关于<strong>段</strong>这个概念。我认为，还是因为在编程的时候可以通过一个系统化的结构来统一汇编语言的实现逻辑。使得这些指令看上去便于管理和协调合作。至于其物理实现，其实就是CPU的寻址方式决定的。书本中有一段话特别经典，我摘抄如下:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">比如我们将10000H~1001F安排为代码段，并在里面存储如下代码:  </span><br><span class="line"></span><br><span class="line">MOV ax,1000H  </span><br><span class="line">MOV ss,ax</span><br><span class="line">MOV sp,0020H  //初始化栈顶</span><br><span class="line">MOV ax,cs</span><br><span class="line">MOV ds,ax  //设置数据段段地址</span><br><span class="line">MOV ax,[0]</span><br><span class="line">add ax,[2]</span><br><span class="line">add bx,[4]</span><br><span class="line">add bx,[6]</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax</span><br><span class="line">pop bx  </span><br><span class="line"></span><br><span class="line">设置CS=1000，IP=0.这段代码就会被执行，但是可以看到在这段代码中，我们又将  </span><br><span class="line">10000H~1001FH安排为栈段和数据段。  </span><br><span class="line">可见不管我们如何安排，CPU将内存中的某段内存当做代码，是因CS:IP指向了那里。  </span><br><span class="line">CPU将某段内存当做栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排，  </span><br><span class="line">以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们  </span><br><span class="line">的安排运行的时候做到游刃有余。  </span><br><span class="line">一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。  </span><br><span class="line">关键是在于CPU中寄存器的设置，机CS，IP，SS，SP，DS的指向。</span><br></pre></td></tr></table></figure><h5 id="多个段的统一"><a href="#多个段的统一" class="headerlink" title="多个段的统一"></a>多个段的统一</h5><blockquote><p>以前写的汇编都是单个段，并且主要是代码段。如果内存中的一段汇编代码需要包含多个数据段，代码段，栈段。该如何设计才能保证程序正常运行呢？<br><strong>我们应该有一个概念，就是所谓和CPU对应的程序一定是<code>CS:IP</code>指向的内存地址。</strong>所以实际上这个问题是在问保证<code>CS:IP</code>正确指向程序的前提下，如何让数据段，栈段合理的加进来？<br>这里有个<code>伪指令</code>的概念，伪指令主要是为汇编器提供一些编译的前提信息比如从哪里开始执行代码，其他的段的起始地址在哪里。所以问题也就解决了。</p><ul><li>如何保证<code>CS:IP</code>指向代码段:    <code>end</code>和<code>end start</code></li><li>如何定义一个段: <code>code segment</code>和<code>code ends</code></li><li>如何将段寄存器和段相对应: <code>assume cs:code</code></li></ul></blockquote><h4 id="汇编语言的编译、连接过程及其工具的使用"><a href="#汇编语言的编译、连接过程及其工具的使用" class="headerlink" title="汇编语言的编译、连接过程及其工具的使用"></a>汇编语言的编译、连接过程及其工具的使用</h4><blockquote><p>   这部分详细见书上。  </p></blockquote><h5 id="源程序组成"><a href="#源程序组成" class="headerlink" title="源程序组成"></a>源程序组成</h5><blockquote><p>   一个汇编程序的源程序由<code>汇编指令</code>和<code>伪指令</code>构成。汇编指令指的是编译成为机器指令最终为CPU所执行的代码。伪指令没有相对应的机器指令，主要是由编译器来执行的指令。</p></blockquote><h5 id="编译、链接、执行"><a href="#编译、链接、执行" class="headerlink" title="编译、链接、执行"></a>编译、链接、执行</h5><blockquote><p>源程序经过编译成为可重定位文件，然后经过链接成为可执行文件。可执行文件是可以直接在操作系统中执行的。上述两种文件都属于ELF格式的文件，ELF是Linux下面的一种文件格式，具体的细节在后面的操作系统中会谈到，这里只是了解。<br>    <code>编程</code>（edit）————&gt;<code>1.asm</code>————&gt;<code>编译</code>(masm)————&gt;<code>1.obj</code>————&gt;<code>链接</code>(link)————&gt;<code>1.exe</code>————&gt;<code>加载</code>(shell)————&gt;<code>内存中的程序</code>————&gt;<code>运行</code>(CPU)</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/6.png" alt="pic6"></p><h3 id="工具进阶"><a href="#工具进阶" class="headerlink" title="工具进阶"></a>工具进阶</h3><h4 id="debug-d"><a href="#debug-d" class="headerlink" title="debug -d"></a>debug -d</h4><blockquote><p>第一个实验中使用的debug工具，通过各种参数来对寄存器和内存进行读写。比如<code>d 段地址:偏移地址</code>指令会列出指定内存单元中的内容。但是debug也是一个程序，而能定位内存地址的方式在8086中只有段寄存器可以做到,实际上debug就是通过将地址写入段寄存器中的方式来进行内存寻址。这个原理适用于所有的参数。<br>而使用的这个段寄存器正是<code>DS</code>寄存器。<br>根据这个原理，就可以通过修改寄存器来进阶使用这些命令，比如:<code>-r ds</code>,<code>:1000</code>,<code>-d ds:0</code>这段代码就表示查看从1000：0开始的内存空间中的内容。这里主要是认识到段寄存器DS的寻址功能，为之后的寻址方式打基础。  </p></blockquote><h4 id="debug-p"><a href="#debug-p" class="headerlink" title="debug -p"></a>debug -p</h4><blockquote><p>在整个实验中，debug工具是经常要使用的。debug有两种用法，一种就是使用<code>a</code>参数直接写入程序然后调试。还有一种就是直接调试<code>exe</code>文件。<br>第一种之前一直在用，第二种方式加载的过程有一些不一样，ds段寄存器中存放着该程序的段地址，因为偏移为零所以DS:0就是所加载程序的首地址。而加载进来的程序前256字节存放的是一段通信程序，所以真正的代码是在<code>(DS+10H:0):0</code>开始的。<br>每一段汇编指令都需要以<code>mov ax,4c00H</code>，<code>int 21H</code>结尾。在调试到<code>int 21H</code>的时候需要使用<code>P</code>命令执行。出现<code>Program terminated normally</code>程序正常退出。</p></blockquote><h3 id="实验2-用机器指令和汇编指令编程"><a href="#实验2-用机器指令和汇编指令编程" class="headerlink" title="实验2 用机器指令和汇编指令编程"></a>实验2 用机器指令和汇编指令编程</h3><blockquote><p>这个实验很有意思，一共有两部分:</p></blockquote><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><blockquote><p>使用<code>a</code>将下面的汇编指令写入内存，然后使用<code>T</code>命令调试。如下: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,10</span><br><span class="line">mov ax,3123</span><br><span class="line">push ax</span><br><span class="line">mov ax,3366</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure><blockquote><p>会发现在单步调试的时候，在<code>mov ss,ax</code>之后的下一条指令竟然不是<code>mov sp,10</code>。但是查看寄存器的时候发现实际上这条执行已经被执行结束了。这是第一个现象。</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/7.png" alt="pic7"></p><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><blockquote><p>对上面的代码继续调试，如下：<br>会发现最开始对栈初始化之后，到执行到<code>mov ss,ax</code>指令的时候，查看原来的栈段内容竟然不再是零，且这些数字还都是和段寄存器相关的。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/8.png" alt="pic8"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>下图是接下来的每一步后栈段中的内存变化。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/9.png" alt="pic9"><br>可以看到的现象是:开始的时候栈中是没有数据的，栈桢SP指向<code>2000:0010</code>的位置。<br>在<code>mov ss,ax</code>和<code>mov sp,10</code>这两步执行结束之后，发现栈中已经有数据了，这里称为初始化。初始化的一共有6字节的数据:4个字节为<code>CS:IP</code>，还有两字节在栈底确定为<code>01A3H</code>。<br>之后的每一条栈操作的指令执行结束之后栈中的<code>CS:IP</code>值也会跟着变化，这说明每一次指令都有可能产生一次中断。<br>但是在栈底的<code>01A3H</code>一直没有变化估计应该是中断相关。在正式压栈操作的过程中发现最开始初始化过的那些数据并没有被压到栈底，<strong>这就意味着堆栈指针SP应该还在栈底，然后真正有数据项压栈的时候才会SP-=2操作。</strong></p></blockquote><h5 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h5><blockquote><p>就上面的三个现象，我在想仅仅是初始化的过程就已经占据了一大半栈空间，那如果将栈大小调整成为8字节的。那会出现什么情况？<br>   我将<code>mov sp,10</code>改成<code>mov sp,08</code>；然后准备了8字节数据，所以栈会被压满。这时候我想看看现象。<br>这是一张初始化的图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/10.png" alt="pic10"></p></blockquote><blockquote><p>这是末尾压栈满了的图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/11.png" alt="pic11"><br>因为书上关于中断的详细讲解在第四部分，所以这里只是一个猜测。<strong>现象中随着栈不断被压满，之前初始化的那些数据都被挤出去了，具体去哪了不知道。那6个字节的数据到底有什么用也不知道。</strong>  </p></blockquote><h5 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h5><blockquote><p>不过可以知道的是初始化栈帧的时候会有参数压到栈里，参数有<code>CS:IP</code>和中断向量号，其中<code>CS:IP</code>还在<strong>不断变化</strong>。而随着栈中的数据越来越多，栈中的这6个字节的参数被慢慢挤出。难道这6个字节不重要吗，或者说只是在初始化的时候用了一下？但是过程中这些参数一直也在变化，所以不可能不重要.不过这些数据之所以放到栈中的原因一定不是为了存储，否则就不会被随便挤出。<br>结合第一部分实验，<code>mov sp,10</code>是紧跟着前一条指令执行的，所以我能想到的唯一一个合理的解释就是:这些参数是在指令执行过程中直接使用的，而执行过程对shell屏蔽不可见，所以在栈中数据越来越多的时候这些参数还可以随意的移动位置并且被抛弃，这些参数是过程中使用的参数，而这个过程就是中断！至于中断到底是什么，到第4章再详细学习吧。</p></blockquote><h3 id="实验3-用编程、编译、连接、跟踪"><a href="#实验3-用编程、编译、连接、跟踪" class="headerlink" title="实验3 用编程、编译、连接、跟踪"></a>实验3 用编程、编译、连接、跟踪</h3><blockquote><p>最后一个实验查看PSP（就是加载开始前256字节）的内容。<br>使用<code>u</code>来查看汇编好像又和中断有关系。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/12.png" alt="pic12"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第二部分-汇编结构&quot;&gt;&lt;a href=&quot;#第二部分-汇编结构&quot; class=&quot;headerlink&quot; title=&quot;第二部分:汇编结构&quot;&gt;&lt;/a&gt;第二部分:汇编结构&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;h4 id=&quot;汇编语言的结构&quot;&gt;&lt;a href=&quot;#汇编语言的结构&quot; class=&quot;headerlink&quot; title=&quot;汇编语言的结构&quot;&gt;&lt;/a&gt;汇编语言的结构&lt;/h4&gt;&lt;h5 id=&quot;寄存器和内存之间&quot;&gt;&lt;a href=&quot;#寄存器和内存之间&quot; class=&quot;headerlink&quot; title=&quot;寄存器和内存之间&quot;&gt;&lt;/a&gt;寄存器和内存之间&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;汇编语言是由不同的段构成的，这些段的功能各异不过主要分为&lt;code&gt;指令&lt;/code&gt;和&lt;code&gt;数据&lt;/code&gt;两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch1</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch1/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch1/</id>
    <published>2018-10-02T09:03:13.000Z</published>
    <updated>2018-10-13T02:06:21.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分-硬件模型"><a href="#第一部分-硬件模型" class="headerlink" title="第一部分:硬件模型"></a>第一部分:硬件模型</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><h4 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h4><blockquote><p>   全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————<code>冯诺依曼结构</code>。<br>   CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？<br><a id="more"></a>  </p></blockquote><ul><li>存储单元的地址（地址）</li><li>读/写操作（控制）</li><li>读/写的具体数据（数据）  </li></ul><blockquote><p> 答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它<code>内存地址空间</code>。  </p></blockquote><blockquote><p> 以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构<code>《微机原理和接口》</code>，也不是讲整个计算机系统的结构和功能<code>《组成原理》</code>。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。<br> 固有的硬件体系指的是这套<code>CPU+RAM</code>的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说<strong>不同的CPU有不同的汇编语言</strong>，用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。</p></blockquote><h4 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h4><blockquote><p>学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。<br>从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是<code>从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算</code>。但是如果我把<code>data1</code>和<code>data2</code>互换一下，其实也是可以的。但是需要考虑到的是<code>data2</code>所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。</p></blockquote><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><blockquote><p>   8086CPU有14个寄存器，都是16位的。但是这16位的寄存器也可以独立作为两个8位的寄存器使用。<br>   寄存器和内存是汇编程序猿眼中最直观的计算机样子。</p></blockquote><h5 id="汇编层面的CPU"><a href="#汇编层面的CPU" class="headerlink" title="汇编层面的CPU"></a>汇编层面的CPU</h5><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制各种器件进行工作</li><li>内部总线连接各种器件，在它们之间进行数据的传送  </li></ul><h5 id="8086架构（16位机）"><a href="#8086架构（16位机）" class="headerlink" title="8086架构（16位机）"></a>8086架构（16位机）</h5><p>具体深究到物理实现就是《组成原理》知识了。  </p><ul><li>运算器一次最多可以处理16位数据  </li><li>寄存器的最大宽度为16位      </li><li>寄存器和运算器之间的通路为16位  </li></ul><h5 id="汇编层面的内存"><a href="#汇编层面的内存" class="headerlink" title="汇编层面的内存"></a>汇编层面的内存</h5><blockquote><p>CPU在访问内存单元的时候，需要知道内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存空间在这个空间上都有唯一的地址，这个惟一的地址就叫做<code>物理地址</code>。<br>CPU首先在内部形成这个物理地址，然后通过地址总线送入存储器。这个地址一定是一个内存单元的物理地址。不同的CPU架构形成地址的方式不一样。  </p></blockquote><h5 id="CS-IP"><a href="#CS-IP" class="headerlink" title="CS:IP"></a>CS:IP</h5><blockquote><p>   前面提到了8086CPU内部需要形成物理地址，但是8086是16位机————只能处理和传输16位的地址，但是8086的地址总线有20位，所以需要两个16位来共同形成一个20位的地址。<br>    14个寄存器中，CS是段寄存器，存放基地址。而IP存放偏移量。公式:<code>CSx16+IP</code>。<br>  首先需要明白的就是，一个内存单元是8位二进制也叫一个字节。而十六进制的一位可以表示成为二进制的4位。完全只是为了方便才写成16进制的。<strong>20位的地址（5位16进制）</strong>可以写成<code>4C780H</code>，后面的H表示16进制。<code>一个X进制的数据左移一位，相当于乘以X</code>。所以为了记起来方便一些可以记成<code>CS寄存器的数据左移一位+IP寄存器的值</code>。但是<strong>两个寄存器只有16位（4位16进制)</strong>，到后面计算的时候需要注意这两个前提，避免溢出。<br>  书中特别强调了对<strong>段</strong>的理解。这里的段并不是指内存被物理上分成一段一段的。而是因为CPU在管理内存的时候，使用<code>CSx16+IP</code>的方式来进行管理。<strong>所以可以将地址连续，起始地址为16的倍数的一组内存单元看成是一个段。</strong>重点在于不是所有的起始地址都可以作为段地址————这是因为<code>CSx16</code>决定的。而且因为<code>IP</code>是16位的所以每一个段的长度最大为<code>64KB</code>。  </p></blockquote><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><blockquote><p>   <strong>在8086机中，任意时刻CPU将CS:IP指向的内容当做指令执行。</strong>汇编中使用<code>jmp 段地址:偏移地址</code>对CS:IP进行修改。或者使用<code>jmp 寄存器</code>来修改IP的值。  </p></blockquote><h6 id="8086的工作过程"><a href="#8086的工作过程" class="headerlink" title="8086的工作过程"></a>8086的工作过程</h6><ul><li>从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓存器。</li><li>IP指向下一条指令。</li><li>执行指令,从CS:IP中取指令，重复上面的过程。  </li></ul><h3 id="书中划线"><a href="#书中划线" class="headerlink" title="书中划线"></a>书中划线</h3><ul><li>汇编语言和机器语言的差别在于指令的表示方法上。</li><li>微机存储器的容量是以<strong>字节</strong>为最小单位的来计算的。</li><li>在内存和磁盘上，数据和指令没有任何区别。</li><li>在汇编语言这门课中，我们所面对的是<strong>内存地址空间</strong>。CPU向这段地址中读写数据实际上就是向相应的物理存储器中读写数据。</li><li>内存地址空间的大小受到CPU地址总线宽度的限制。</li></ul><h3 id="实验1-查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验1-查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验1 查看CPU和内存，用机器指令和汇编指令编程"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h3><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><blockquote><p>   debug是DOS,Windows都提供的实模式（8086方式）程序的调试工具。下面是本次实验将会用到的参数:  </p></blockquote><h5 id="r-读写寄存器"><a href="#r-读写寄存器" class="headerlink" title="r (读写寄存器)"></a>r (读写寄存器)</h5><ul><li><code>r</code>查看所有的寄存器的值</li><li><code>r 寄存器名称</code>修改制定寄存器的值</li></ul><h5 id="d-（读写内存）"><a href="#d-（读写内存）" class="headerlink" title="d （读写内存）"></a>d （读写内存）</h5><ul><li><code>d 段地址:偏移地址</code> 列出从指定内存单元开始的128个内存单元的内容</li><li><code>d 段地址:起始偏移地址 结尾偏移地址</code>列出在偏移地址范围之内的内存单元的内容</li></ul><h5 id="e-（读写内存）"><a href="#e-（读写内存）" class="headerlink" title="e （读写内存）"></a>e （读写内存）</h5><ul><li><code>e 段地址:偏移地址  data1  data2 data3……</code>从特定单元开始讲数据写入内存</li><li><code>e 段地址:偏移地址 回车</code>表示挨个儿修改内存，空格表示默认不修改，回车表示修改结束</li></ul><h5 id="e-u-t"><a href="#e-u-t" class="headerlink" title="e+u+t"></a>e+u+t</h5><ul><li>使用<code>e</code>参数向内存中写入机器码</li><li>使用<code>u 段地址:偏移地址</code>可以将内存中机器码翻译成为汇编语言</li><li><code>t</code>参数执行<code>CS:IP</code>指向的内存地址单元的任何指令，注意修改参数</li></ul><h5 id="a"><a href="#a" class="headerlink" title="a"></a>a</h5><ul><li><code>a 段地址:偏移地址</code>可以直接使用汇编的格式写入机器指令</li></ul><h4 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h4><blockquote><p>   一共有4个实验。写出来的都是我觉得很有意思且值得讨论的实验。  </p></blockquote><h5 id="第二个实验"><a href="#第二个实验" class="headerlink" title="第二个实验"></a>第二个实验</h5><blockquote><p>   给出起始地址为<code>2000:0000</code>的三条指令，使用这三条指令计算2的8次方。<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/2.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>   有意思的是这个算法，a += a；如果这里的a是2的话，实际上<code>a+a</code>等于<code>ax2</code>所以可以2的8次方可以通过8次这样的加法完成，但是如果a是其他的值就不行了。</p></blockquote><h5 id="最后两个实验"><a href="#最后两个实验" class="headerlink" title="最后两个实验"></a>最后两个实验</h5><blockquote><p>使用<code>e</code>参数对特定的内存单元进行读写。<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/3.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>   这两个实验间接地证明了<strong>内存地址空间</strong>的存在。<br>   我在向内存<code>B810:0000</code>中写数据的时候，发现显示器上会出现有颜色的字符和表情包，猜想这个地址应该是显存的物理地址。这也说明这里的内存不仅仅指的是主存储器，还有其他的和CPU直接相连的RAM。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一部分-硬件模型&quot;&gt;&lt;a href=&quot;#第一部分-硬件模型&quot; class=&quot;headerlink&quot; title=&quot;第一部分:硬件模型&quot;&gt;&lt;/a&gt;第一部分:硬件模型&lt;/h2&gt;&lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;h4 id=&quot;硬件基础&quot;&gt;&lt;a href=&quot;#硬件基础&quot; class=&quot;headerlink&quot; title=&quot;硬件基础&quot;&gt;&lt;/a&gt;硬件基础&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;   全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————&lt;code&gt;冯诺依曼结构&lt;/code&gt;。&lt;br&gt;   CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch0</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch0/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch0/</id>
    <published>2018-10-02T08:25:22.000Z</published>
    <updated>2018-10-10T14:01:34.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><blockquote><p>王爽老师的《汇编语言》是国内的经典教材。<br>学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。</p></blockquote><a id="more"></a>    <h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><blockquote><p>全书的实验都是在8086CPU的体系结构下展开的，这也是Intel第一块16位的处理器。<br>我们有两种办法在自己的计算机上模拟8086:一种是使用WindowsXP系统。一种是采用DOSBox模拟器，第二种比较方便。<a href="https://pan.baidu.com/s/1-Da6IPYym54QbokzFMiNvA" target="_blank" rel="noopener">这里是链接</a>。<br>本书有17个实验，2个课程设计，5个研究试验。我主要是以其中一些实验为章节展开学习。</p></blockquote><h4 id="全书架构"><a href="#全书架构" class="headerlink" title="全书架构"></a>全书架构</h4><blockquote><p>在我看来，全书应该可以分为这么几个部分:</p><ul><li>硬件模型Chapter.(1、2)————告诉你汇编编程就是程序员以<code>指令</code>为手段在<code>CPU的寄存器</code>和<code>内存地址空间</code>之间进行数据读写的的过程。</li><li>汇编结构Chapter.(3、4)————介绍了完整的汇编程序的组成部分:<code>数据段</code>，<code>代码段</code>、<code>栈段</code>。第4章介绍了汇编程序编译的全过程和基本工具的使用。</li><li>指令核心Chapter.(5~11)————从第5章作者开始引进一些新的指令，并且展开来讲汇编程序设计的核心部分。介绍了重点的指令比如<code>操作指令</code>,<code>跳转指令</code>，<code>比较指令</code>等及其用法等，并深入介绍了内存寻址的各种花式用法。</li><li>操作系统层面的应用Chapter.(12~17)和操作系统相关的概念比如中断等。</li></ul></blockquote><blockquote><p>整个学习过程中，<strong>寄存器和内存地址空间的读写是贯穿全书的核心</strong>，因为所有的操作最终都是产生了对内存或者某一个寄存器的读写。<strong>而完成这一切读写功能的就是汇编指令。</strong>这也是机器硬件的真正工作原理。<br>虽然这些部分都可以拆开来了解，但是实际上每一部分还有很多的细节和承上启下的概念，我也是站在我理解的角度对这些内容进行了划分，需要注意的是:全书还有很多的细节比如不同的存储单元和数据处理方式，这些都不是单独某一个章节可以完成的而是贯穿全书实验的前提。所以还是需要通读一遍全书来顺这些概念。</p></blockquote><h4 id="搭建实验条件"><a href="#搭建实验条件" class="headerlink" title="搭建实验条件"></a>搭建实验条件</h4><ul><li>将下载好的环境包放在<code>~/x86</code>，作为我们的工作目录。</li><li>打开DOSBox模拟器。</li><li>挂载C盘:<code>mount C ~/x86</code>。</li><li>进入C盘:<code>C:</code>。</li><li>开始实验:<code>debug</code>。</li><li>退出程序<code>quit</code>，退出模拟器<code>exit</code>。</li></ul><h4 id="安装成功展示"><a href="#安装成功展示" class="headerlink" title="安装成功展示"></a>安装成功展示</h4><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/1.png" width="300" height="200" alt="图片名称" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;王爽老师的《汇编语言》是国内的经典教材。&lt;br&gt;学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
  </entry>
  
</feed>
