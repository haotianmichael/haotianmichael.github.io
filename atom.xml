<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CodeSaw</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haotianmcihael.github.io/"/>
  <updated>2023-01-18T02:22:20.612Z</updated>
  <id>http://haotianmcihael.github.io/</id>
  
  <author>
    <name>HaotianMichael</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NJU静态程序分析(6-Tai-e实验复盘)</title>
    <link href="http://haotianmcihael.github.io/2023/01/18/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-6-Tai-e%E5%AE%9E%E9%AA%8C%E5%A4%8D%E7%9B%98/"/>
    <id>http://haotianmcihael.github.io/2023/01/18/NJU静态程序分析-6-Tai-e实验复盘/</id>
    <published>2023-01-17T23:25:38.000Z</published>
    <updated>2023-01-18T02:22:20.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p><code>Tai-e</code>是一个程序分析<a href="https://tai-e.pascal-lab.net/" target="_blank" rel="noopener">框架</a> By谭添老师。共有8个实验，包括：</p><ul><li>编译优化(活跃变量分析，常量传播分析，死代码检测)</li><li>基础程序分析(程序调用图构建，非上下文敏感指针分析，各类经典上下文敏感指针分析)</li><li>程序分析在软件安全性领域的应用(污点分析)</li></ul><p><img src="/Users/haotianmichael/Documents/HBlog/haotianmichael.io/source/_posts/NJU静态程序分析-6-Tai-e实验复盘/1.png" alt=""></p><p>做实验的过程中我对课程上学到的理论有了更具体的理解；也遇到了各种坑，包括对分析算法实现细节上的理解，甚至Java语言本身的特性。这里复盘一下在实验中遇到的各种问题。</p><a id="more"></a><h3 id="Lab1-Live-Variable-Analysis"><a href="#Lab1-Live-Variable-Analysis" class="headerlink" title="Lab1-Live Variable Analysis"></a>Lab1-Live Variable Analysis</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Tai-e&lt;/code&gt;是一个程序分析&lt;a href=&quot;https://tai-e.pascal-lab.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;框架&lt;/a&gt; By谭添老师。共有8个实验，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译优化(活跃变量分析，常量传播分析，死代码检测)&lt;/li&gt;
&lt;li&gt;基础程序分析(程序调用图构建，非上下文敏感指针分析，各类经典上下文敏感指针分析)&lt;/li&gt;
&lt;li&gt;程序分析在软件安全性领域的应用(污点分析)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/Users/haotianmichael/Documents/HBlog/haotianmichael.io/source/_posts/NJU静态程序分析-6-Tai-e实验复盘/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;做实验的过程中我对课程上学到的理论有了更具体的理解；也遇到了各种坑，包括对分析算法实现细节上的理解，甚至Java语言本身的特性。这里复盘一下在实验中遇到的各种问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824(Spring 2022)-MapReduce</title>
    <link href="http://haotianmcihael.github.io/2022/12/28/MIT6-824-Spring-2021-MapReduce/"/>
    <id>http://haotianmcihael.github.io/2022/12/28/MIT6-824-Spring-2021-MapReduce/</id>
    <published>2022-12-28T14:29:59.000Z</published>
    <updated>2022-12-28T07:57:42.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>最近终于有时间研究一下MIT的<a href="https://pdos.csail.mit.edu/6.824/schedule.html" target="_blank" rel="noopener">神课</a><code>6.824</code>。  </p><p>这门课教<code>Distributed System</code>，即多台物理隔离的计算机通过网络来协调，共同完成一致性任务，可以是计算任务，也可以是存储任务。  </p><p><strong>分布式系统</strong>和单机相比，除了有很多高并发的<code>Partial Failures</code>，更多的是硬件老化，断电，网卡失灵等这种现实问题。因此设计低成本高性能系统以及处理并发和网络问题——<strong><code>Performance</code>性能和<code>Fault Tolerance</code>容错</strong>是这门课的核心。</p><p>课程共有20个<code>Lectures</code>和4个<code>labs</code>。和<code>6.828</code>一样重视实践——<strong>看论文，查资料，做<code>lab</code></strong>~简单粗暴。所以学习过程基本上就按照如下推进：</p><ul><li>提前看<code>Lecture</code>要求的<code>papers</code></li><li>听<a href="https://www.bilibili.com/video/BV1R7411t71W?spm_id_from=333.999.0.0" target="_blank" rel="noopener">对应</a>的<code>Lectures</code></li><li>查找<code>lab</code>相关的学习资料</li><li>做<code>lab</code></li></ul><p>之前做<code>6.828</code>的时候就发现我在做这种<strong>学习过程很长，思考内容又很深</strong>的课程训练时很容易钻牛角尖而让自己乱了节奏，思维如若不能放松下来效果肯定不会太好——希望这次能尽量调整过来。</p><a id="more"></a><h3 id="Paper"><a href="#Paper" class="headerlink" title="Paper"></a>Paper</h3><p>论文<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf" target="_blank" rel="noopener">MapReduce:Simplified Data Processing on Large Clusters</a>是关于Google已经淘汰掉的<strong>大规模数据集处理编程架构<code>MapReduce</code></strong>。当时的Google面临在多台机器上的大规模数据集处理比如计算<code>PageRank</code>或者对所有文件进行<code>grep</code>等。</p><p>而统一化编程模型可以很好的抽象掉因为大规模集群导致的<strong>并行，网络，容错</strong>等问题——将这些细节隐藏起来，只留一个供程序员使用的编程接口可以大大提高开发效率。而工业级<code>MapReduce</code>的本质就是一个<strong>利用普通机器组成的大规模计算集群进行并行，高容错，高性能的大数据处理函数框架。</strong></p><h4 id="理论模型"><a href="#理论模型" class="headerlink" title="理论模型"></a>理论模型</h4><p>理论模型借鉴于<code>Lisp</code>语言中的<code>map/reduce</code>函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">map</span><span class="params">(<span class="built_in">string</span> key, <span class="built_in">string</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//key:  文档名</span></span><br><span class="line"><span class="comment">//value: 文档内容</span></span><br><span class="line"><span class="keyword">for</span> each word w in value:</span><br><span class="line">EmitIntermediate(w, <span class="string">"1"</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reduce</span> <span class="params">(<span class="built_in">string</span> key, Iterator values)</span> </span>&#123;</span><br><span class="line"><span class="comment">//key: 一个单词</span></span><br><span class="line"><span class="comment">//value: 计数值列表</span></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> each v in value:</span><br><span class="line">result  += ParseInt(v);</span><br><span class="line">Emit(toString(result));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里两个函数模型的类型分别是:</p><ul><li>map:   (k1, v1)  —&gt;  list(k2, v2)</li><li>reduce:   (k2, list(v)) —&gt; list(v2)</li></ul><p>对于一个<code>map</code>操作，将<code>key</code>文档中的内容按照一定方式读取，并统计其中的<code>w</code>项的频率<code>value</code>并输出到一个中间文件上。而<code>reduce</code>从中间文件中读取并迭代其<code>lists</code>，将对应的<code>key</code>项统计。</p><p> <img src="1.png" width="50%" height="50%" alt=""></p><p>这一模型可以很好的处理并行化操作——<strong>因为<code>map</code>的过程可以在多台机器上并行完成而没有依赖。<code>reduce</code>过程也是。但是整体<code>reduce</code>和<code>map</code>之间存在着顺序依赖关系即必须是相应的<code>map</code>操作结束才可以唤醒<code>reduce</code>操作。</strong></p><p>这样的话所有的依赖和协调过程都被隐藏在<code>map</code>和<code>reduce</code>函数的<strong>数据分发</strong>之间，而开发者可以完全不用考虑分布式细节而单独编写这两个函数以达到自己的目的。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>从实现角度看系统的很多行为是由<code>MapReduce</code>内置的库完成的。这里有几个容易混淆的概念：</p><ul><li><code>user program</code>：用户程序，会被多次<code>fork</code>成为<code>master</code>和<code>worker</code>  </li><li><p><code>master</code>: 主节点，用来将<code>task</code>分配给相应的<code>worker</code>，记录工作节点的当前状态和声明周期</p></li><li><p><code>task</code>：<code>map</code>任务或者<code>reduce</code>任务，由相应的<code>worker</code>完成</p></li><li><code>worker</code>: 工作节点，用来完成相应的<code>task</code></li><li><p><code>user-defined map/reduce</code>: 开发者自定义的<code>map/reduce</code>函数</p><p><img src="2.png" width="50%" height="50%" alt=""></p></li></ul><h5 id="输入预处理"><a href="#输入预处理" class="headerlink" title="输入预处理"></a>输入预处理</h5><p>首先库函数会将输入文件切分成<code>M</code>份，并在一个集群的若干台机器上启动程序的多个副本。副本中除了有一个作为主节点，其他都是工作节点。  </p><p>主节点将M个map任务R个reduce任务分配给空闲的工作节点（理解<code>task</code>在被分配给<code>worker</code>后两者是一个意思）。</p><h5 id="map工作节点（区分工作节点和用户函数）"><a href="#map工作节点（区分工作节点和用户函数）" class="headerlink" title="map工作节点（区分工作节点和用户函数）"></a>map工作节点（区分工作节点和用户函数）</h5><p>每一个被分配map的工作节点需要读取相应内容并解析出<code>key/value</code>对，<strong>并将这些作为参数提供给用户自定义的map函数，</strong>而函数输出的中间结果缓存在内存中。</p><p>缓存的中间<code>key/value</code>对会被划分为R块并写入本地磁盘，而这些数据对在磁盘中的相应位置会被传回主节点——由主节点再传给相应的reduce工作节点。</p><h5 id="reduce工作节点（区分工作节点和用户函数）"><a href="#reduce工作节点（区分工作节点和用户函数）" class="headerlink" title="reduce工作节点（区分工作节点和用户函数）"></a>reduce工作节点（区分工作节点和用户函数）</h5><p>保证map操作结束后，主节点唤醒reduce工作节点并告知其中间输出的磁盘位置。reduce工作节点使用RPC调用获取这些中间数据。<strong>当reduce读取完所有的数据，需要按照key对其进行排序，是为了最后迭代器统计计数提供前置条件。</strong>最后reduce工作节点迭代排好序的中间数据，并将每一个中间key和它关联一组中间value传递给用户定义的reduce函数。</p><h5 id="shuffle过程（核心状态机）"><a href="#shuffle过程（核心状态机）" class="headerlink" title="shuffle过程（核心状态机）"></a>shuffle过程（核心状态机）</h5><p>整个map和reduce之间的数据shuffle是系统分布式的核心，关键就是map生成的中间文件及其命名。</p><p> <img src="3.png" width="50%" height="50%" alt=""></p><p>如上图，假设有5个map工作节点和3个reduce工作节点。</p><ul><li>map工作节点的输出分为3类，分别由<code>R0</code>，<code>R1</code>和<code>R2</code>处理，<strong>当map的解析函数一致时，相同的key一定被分到了同一个中间文件中。</strong>即<code>0-0.txt</code>、<code>1-0.txt</code>和<code>0-2.txt</code>三个文件中<code>key</code>类型的交集是空集。</li><li><code>md5(key)%R</code>计算map最终输出落入到哪个中间文件</li><li>中间文件命名：map任务编号-reduce任务编号</li></ul><p>因此5个map操作结束后会生成5*3的中间文件矩阵。</p><ul><li>map结束后，3个reduce工作节点通过RPC分别获取矩阵的每一列文件数据</li></ul><p>比如R0调用<code>0-0.txt、1-0.txt、2-0.txt、3-0.txt、4-0.txt</code>。因为同一列中类型相同，所以只需要内部排序。</p><p>所谓<code>shuffle</code>就是map/reduce对中间文件的行列操作，其结果是将中间文件进一步处理成为<code>&lt;value, list&lt;key&gt;&gt;</code>作为用户定义reduce函数的输入进行计数统计。</p><h5 id="最终输出"><a href="#最终输出" class="headerlink" title="最终输出"></a>最终输出</h5><p>reduce工节点处理完计数后，将结果输出到磁盘上作为下一次<code>MapReduce</code>的输入。</p><h4 id="工业级处理"><a href="#工业级处理" class="headerlink" title="工业级处理"></a>工业级处理</h4><p>在框架实现的过程中出现了很多的细节。Google在将<code>MapReduce</code>工业化落地的过程中也将这些影响系统<strong>性能</strong>和<strong>可靠性</strong>的主要因素进行了优化——而一个优秀的系统本身就是在实践中不断迭代出来的，这里简单概括一下，不做详细讨论。</p><h5 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h5><p><strong>分布式容错的本质就是如何在不可靠的硬件上构建可靠的软件。</strong>因为是大规模集群，所以很难避免<code>Partial Failure</code>——从实现角度看就是各个节点的容错。</p><ul><li>主节点：主节点奔溃之后会coredump到一个恢复文件中，重启后可以从最近的恢复点重新执行MapReduce</li><li>工作节点：奔溃后一般都要将当前的task重新分配到一个节点完成<ul><li>map：输出是一个中间文件所以符合原子提交即后面的任务会将文件覆盖</li><li>reduce：其输出是一个持久性的文件所以需要重命名一个新的文件防止冲突</li></ul></li></ul><h5 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h5><p>当出现大规模的机器节点时，很多性能问题会成为优化的方向。比如进一步优化网络和磁盘性能。</p><ul><li>局部性：在分布式系统中，输入文件传到map节点，map中间文件传到reduce节点都需要网络带宽。可以考虑将map直接分配到本地磁盘上等操作增加并行性。</li><li>任务粒度：M个map节点，R个reduce节点。分配太多节点导致网络带宽不够，分配太少导致并行度不够。</li><li>负载均衡：不同的工作节点性能也不同，如果系统卡在最后几个节点导致负载过高花费时间过长，就会让整个系统处于不平衡的状态。</li></ul><h3 id="Lecture1-2"><a href="#Lecture1-2" class="headerlink" title="Lecture1~2"></a>Lecture1~2</h3><h4 id="go语言环境配置"><a href="#go语言环境配置" class="headerlink" title="go语言环境配置"></a>go语言环境配置</h4><p>作为一个<code>VIM</code>重度用户我已经不用IDE很多年了。就自行配置了<code>Vim-Go</code>开发环境。</p><h5 id="Go安装配置"><a href="#Go安装配置" class="headerlink" title="Go安装配置"></a>Go安装配置</h5><p>我用<code>MacOs Catalina</code>环境，下载安装就不说了。主要关注<code>Go</code>环境变量，需要写入相应的<code>SHELL</code>配置文件中，我的在<code>.zshrc</code>中：</p><ul><li><code>GOROOT</code>: Go语言的安装目录，一般是<code>/usr/local/go</code></li><li><code>GOPATH</code>: 工作区即写代码的目录，一般分为三个子目录：<ul><li><code>src</code>  </li><li><code>bin</code></li><li><code>pkg</code></li></ul></li><li><code>GOBIN</code>: 存放GO语言可执行文件的目录（这里的可执行文件主要指通过<code>go get</code>下载并编译好的库，供直接调用的）</li><li><code>PATH</code>: 需要将当前的可执行文件目录放到PATH下面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 注意&quot;&quot;的使用</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=~/go/golib:~/go/goproject    #这里设置了两个工作区</span><br><span class="line">export GOBIN=~/go/gobin</span><br><span class="line">export PATH=&quot;$GOROOT/bin:$GOBIN:$PATH&quot;</span><br></pre></td></tr></table></figure><h5 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h5><p>因为Github和Go官网不太好用，所以使用镜像来下载需要的库比较方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Mac/Linux环境下</span><br><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><h5 id="二进制工具"><a href="#二进制工具" class="headerlink" title="二进制工具"></a>二进制工具</h5><p><code>vim-go</code>是一个开发<code>go</code>的<code>vim</code>插件。我使用<code>vundle</code>包管理工具来管理<code>vim</code>插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如何使用vundle自行Google</span><br><span class="line">Plugin &apos;fatih/vim-go&apos;</span><br></pre></td></tr></table></figure><p>因为这个插件启动还需要一些和二进制工具，具体的列表可打开<code>&quot;~/.vim/bundle/vim-go/plugin/go.vim&quot;</code>如下：</p><p> <img src="4.png" width="50%" height="50%" alt=""></p><p>常规做法是在<code>vim</code>命令行模式下面直接执行<code>:GoInstallBinaries</code>来自动安装。如果没有安装代理的话尽管有镜像还是很容易出错，所以我的做法是一个一个从官网上<code>go get</code>然后<code>go insatll</code>手动安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go get github.com/go-delve/delve/cmmd/dlv     #从官网上直接下载二进制工具</span><br><span class="line">$ go install github.com/go-delve/delve/cmmd/dlv@laatest   #使用go install手动安装</span><br></pre></td></tr></table></figure><p>如果按照前面的方式配置好了环境变量，那这些二进制工具就会被安装在<code>~/go/gobin</code>目录下。验证方式就是打开<code>vim</code>之后不会有插件报错信息。</p><h3 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h3><h3 id="To-conclude"><a href="#To-conclude" class="headerlink" title="To conclude"></a>To conclude</h3><p>在学习过程用到的资料列举如下:</p><p><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/" target="_blank" rel="noopener">MIT6.824中文翻译</a></p><p><a href="https://go-zh.org/doc/" target="_blank" rel="noopener">Go文档</a></p><p><a href="https://book.itsfun.top/gopl-zh/" target="_blank" rel="noopener">Go语言圣经</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;最近终于有时间研究一下MIT的&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/schedule.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;神课&lt;/a&gt;&lt;code&gt;6.824&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;这门课教&lt;code&gt;Distributed System&lt;/code&gt;，即多台物理隔离的计算机通过网络来协调，共同完成一致性任务，可以是计算任务，也可以是存储任务。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式系统&lt;/strong&gt;和单机相比，除了有很多高并发的&lt;code&gt;Partial Failures&lt;/code&gt;，更多的是硬件老化，断电，网卡失灵等这种现实问题。因此设计低成本高性能系统以及处理并发和网络问题——&lt;strong&gt;&lt;code&gt;Performance&lt;/code&gt;性能和&lt;code&gt;Fault Tolerance&lt;/code&gt;容错&lt;/strong&gt;是这门课的核心。&lt;/p&gt;
&lt;p&gt;课程共有20个&lt;code&gt;Lectures&lt;/code&gt;和4个&lt;code&gt;labs&lt;/code&gt;。和&lt;code&gt;6.828&lt;/code&gt;一样重视实践——&lt;strong&gt;看论文，查资料，做&lt;code&gt;lab&lt;/code&gt;&lt;/strong&gt;~简单粗暴。所以学习过程基本上就按照如下推进：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提前看&lt;code&gt;Lecture&lt;/code&gt;要求的&lt;code&gt;papers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;听&lt;a href=&quot;https://www.bilibili.com/video/BV1R7411t71W?spm_id_from=333.999.0.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对应&lt;/a&gt;的&lt;code&gt;Lectures&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查找&lt;code&gt;lab&lt;/code&gt;相关的学习资料&lt;/li&gt;
&lt;li&gt;做&lt;code&gt;lab&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前做&lt;code&gt;6.828&lt;/code&gt;的时候就发现我在做这种&lt;strong&gt;学习过程很长，思考内容又很深&lt;/strong&gt;的课程训练时很容易钻牛角尖而让自己乱了节奏，思维如若不能放松下来效果肯定不会太好——希望这次能尽量调整过来。&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://haotianmcihael.github.io/categories/Golang/"/>
    
    
      <category term="Distributed System" scheme="http://haotianmcihael.github.io/tags/Distributed-System/"/>
    
      <category term="MapReduce" scheme="http://haotianmcihael.github.io/tags/MapReduce/"/>
    
      <category term="MIT6.824" scheme="http://haotianmcihael.github.io/tags/MIT6-824/"/>
    
  </entry>
  
  <entry>
    <title>PKU软件分析</title>
    <link href="http://haotianmcihael.github.io/2021/07/19/PKU%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    <id>http://haotianmcihael.github.io/2021/07/19/PKU软件分析/</id>
    <published>2021-07-19T15:35:26.000Z</published>
    <updated>2022-04-19T09:05:59.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p><code>Gödel Incompleteness Theorem</code>从数学上证明了不存在完美的形式系统。而<code>Alan Turing</code>的<strong>停机问题</strong>则在<strong>可判定性</strong>上为<code>Hilbert Plan</code>画上句号——这才有了后面的<code>Turing Machine</code>和<code>Program Language</code>。</p><p><code>NJU</code>课程深入讲解了基于抽象解释的程序分析方法。<code>PKU</code>的<a href="https://xiongyingfei.github.io/SA/2020/main.htm" target="_blank" rel="noopener">课程</a>则更倾向于涵盖所有的程序分析派别——将程序分析上升到了数学和逻辑的层面，我个人很喜欢这种学院派的味道。多一个角度学习也对分析理论和算法的细节有了新的认识，特地记录一下。</p><a id="more"></a><h3 id="may-must"><a href="#may-must" class="headerlink" title="may/must"></a>may/must</h3><p>其实<code>may/must</code>都是相对而言的，对于具体的程序分析问题会有不一样的约束。这里引入<strong>可判定性问题</strong>：</p><blockquote><p><code>Deciable Problem</code>是一个判定问题，该问题存在一个算法使得对于该问题的每一个实例都能给出是/否的答案。  </p></blockquote><p>对于<strong>非判定问题</strong>，假设正确答案为集合<code>S</code>，则:</p><ul><li><code>must analysis</code>: super of S</li><li><code>may analysis</code>: subset of S</li></ul><p>比如确定程序有无内存泄漏就是一个不可判定问题。所以针对这个问题我们选择的算法就应该是<code>may</code>分析来保证<code>Sound</code>。</p><h3 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h3><p>这个名称的来源？  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 停机问题判定Halt</span><br><span class="line">void Evil() &#123;</span><br><span class="line">if(!Halt(Evil)) return;   //Evil函数调用需要传递自己的栈给自己</span><br><span class="line">  elsewhile(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序可以看成是状态（数据）和状态之间的转移（控制）两部分</strong>，而根据停机问题中的核心——即<code>if</code>条件判断是会很复杂的判定。则将<code>if</code>忽略掉，即将控制部分忽略掉只剩下数据部分故称为数据流分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Gödel Incompleteness Theorem&lt;/code&gt;从数学上证明了不存在完美的形式系统。而&lt;code&gt;Alan Turing&lt;/code&gt;的&lt;strong&gt;停机问题&lt;/strong&gt;则在&lt;strong&gt;可判定性&lt;/strong&gt;上为&lt;code&gt;Hilbert Plan&lt;/code&gt;画上句号——这才有了后面的&lt;code&gt;Turing Machine&lt;/code&gt;和&lt;code&gt;Program Language&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NJU&lt;/code&gt;课程深入讲解了基于抽象解释的程序分析方法。&lt;code&gt;PKU&lt;/code&gt;的&lt;a href=&quot;https://xiongyingfei.github.io/SA/2020/main.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;课程&lt;/a&gt;则更倾向于涵盖所有的程序分析派别——将程序分析上升到了数学和逻辑的层面，我个人很喜欢这种学院派的味道。多一个角度学习也对分析理论和算法的细节有了新的认识，特地记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>Self-Designed ADT in LLVM</title>
    <link href="http://haotianmcihael.github.io/2021/06/30/Self-Designed-ADT-in-LLVM/"/>
    <id>http://haotianmcihael.github.io/2021/06/30/Self-Designed-ADT-in-LLVM/</id>
    <published>2021-06-30T03:38:37.000Z</published>
    <updated>2022-03-29T19:48:29.199Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;
      
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>Advanced Compiler Design and Implementation</title>
    <link href="http://haotianmcihael.github.io/2021/06/27/Advanced-Compiler-Design-and-Implementation/"/>
    <id>http://haotianmcihael.github.io/2021/06/27/Advanced-Compiler-Design-and-Implementation/</id>
    <published>2021-06-26T23:34:38.000Z</published>
    <updated>2022-04-16T13:38:54.083Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>不是鲸书。  </p><a id="more"></a><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>想尝试设计一套针对优化和程序分析的框架。<br>通常做程序分析有两条路子，一条是针对程序分析的专用分析器，单独作为一套框架使用;另一条是作为编译器的优化趟来实现， 想到哪里写到哪里。</p><p>针对常规的编译流程<code>Source</code>——<code>IR</code>——<code>CodeGen</code>，我目前还是倾向于<code>Clang</code>的设计，先打算研究其架构并简化出来一套适合的东西。其次要继续读<code>static analysis</code>方向的论文，复现其算法和原理。</p><h3 id="arvcc"><a href="#arvcc" class="headerlink" title="arvcc"></a>arvcc</h3><p>我准备在<a href="https://github.com/haotianmichael/arvcc" target="_blank" rel="noopener">arvcc</a>仓库里面实现新设计的编译框架，最近的工作主要是将<code>Clang</code>里面的架构简化出来然后加以利用。</p><h4 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h4><p><code>llvm</code>中所有的工具都会使用到选项<code>options</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> '-emit-llvm', '-S' and'test.cpp' are all options</span><br><span class="line"><span class="meta">$</span> clang -emit-llvm -S  test.cpp</span><br></pre></td></tr></table></figure><p> 所以<code>option</code>是一个根类，各个工具也有自己的选项子类比如<code>Driver</code>下面可以有自己的<code>DriverOption</code>。这些<code>XXXOption</code>都是各个工具<code>*.td/*.def文件</code>自定义，然后通过<code>TableGen</code>自动生成的。  </p><p><code>arvcc</code>聚焦了很少的功能，所以我打算将各自<code>Option</code>直接集成到不同工具目录下，比如<code>Driver</code>的话，就直接定义在<code>DriverOption.h</code>中，其中<code>DriverOption</code>类继承自<code>Option</code>类。</p><h4 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h4><p>工业级编译器需要考虑很多兼容性功能和用户接口，从而有了<code>Driver</code>的概念。还有很多性能上的<code>trade-off</code>从而用很多<code>LLVM</code>自定义的数据结构。故其具体实现上也及其复杂繁琐。</p><p><code>Clang</code>本质是一个<code>Driver</code>，而<code>-cc1</code>才是编译器前端。在命令行中敲下<code>clang a.cpp</code>之后，编译器默认会自带很多编译选项<code>-###</code>，其中就有<code>-cc1</code>来进入编译器前端。  </p><h5 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h5><p><code>Clang</code>通过定义各个<code>DriverOptions</code>的类型来映射整个编译流程，甚至精确到了选择指定的工具，编译步骤和输出格式。</p><h3 id="剑气"><a href="#剑气" class="headerlink" title="剑气"></a>剑气</h3><p>记录自己机器上和开发有关的些许细节。</p><h4 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h4><p><code>brew</code>是用的最多的，<strong>我机器上存在多个版本的软件比如<code>python/llvm/node...</code>，PATH里都是以<code>brew</code>版本为准(因为时间原因，可能<code>brew</code>自己构建其他软件的依赖也选择了不同的版本，可以使用<code>brew search xxx</code>来查看)。</strong>下面列出项目相关：</p><ul><li><code>llvm+clang:</code> 构建于<code>brew info llvm</code>，目前<code>-v = 13.0.1</code><ul><li><code>$CC/CXX</code>  用于<code>cmake</code>的默认编译器</li><li><code>-LDFLAGS/CPPFLAGS</code> 用于<code>cmake</code>编译器编译选项</li></ul></li><li><p><code>NeoVim:</code> 构建于<code>brew info NeoVim</code>，目前版本<code>-v = 0.6.1</code>,依赖检查<code>: checkhealth</code></p></li><li><p><code>Voltron:</code> 构建依赖<code>brew info python 3.10</code></p></li><li><code>ccls:</code>构建依赖<code>brew info llvm</code></li></ul><h4 id="lsp"><a href="#lsp" class="headerlink" title="lsp"></a>lsp</h4><p>今年正式从<code>Vim+YCM</code>转到了<code>NeoVim+LSP</code>。<code>language server protocol</code>降低了由<code>M</code>家IDE厂商分别为<code>N</code>门语言做插件的复杂度。由<code>language server</code>(针对语言)和<code>language client</code>(针对IDE/Editor)两部分构成。我的配置是<code>server:ccls</code>+<code>client:coc.vim</code>.  </p><p><strong>目前仅仅使用其<code>completion</code>和<code>go to def/ref</code>功能。</strong></p><h5 id="ccls"><a href="#ccls" class="headerlink" title="ccls"></a>ccls</h5><p><code>-DCMAKE_PREFIX_PATH</code>选项很重要，这是因为它将<code>clang/llvm</code>的头文件<code>include paths</code>和库<code>resourceDir</code>硬编码到<code>ccls</code>中以便索引。</p><ul><li><code>include paths:  clang -v -fsyntax-only -x c++ /dev/null</code>  </li><li><code>resourceDir:  clang -print-resource-dir</code> </li></ul><p><code>ccls</code>使用<code>.ccls/ compile_command.json</code>来索引文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% cmake -H. -BDebug -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=YES</span><br><span class="line">% ln -s Debug/compile_commands.json .</span><br></pre></td></tr></table></figure><h5 id="coc-vim"><a href="#coc-vim" class="headerlink" title="coc.vim"></a>coc.vim</h5><p>想要加其他语言的插件<code>:CocConfig</code>。  </p><p>有些硬编码的字符可以直接使用<code>grep</code>来过滤文本文件内容，<code>fzf/find</code>来查找指定目录下的文件。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep -r <span class="string">"ccc_print_phases"</span> llvm-src/clang/     <span class="comment"># 目录查找</span></span></span><br></pre></td></tr></table></figure><h4 id="lldb"><a href="#lldb" class="headerlink" title="lldb"></a>lldb</h4><p>我用<code>voltron</code>做调试器前端，功能很全就是需要在自启动窗口。。有点麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ voltron view register</span><br><span class="line">$ voltron view stack</span><br><span class="line">$ voltron view disasm</span><br><span class="line">$ voltron view backtrace</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;不是鲸书。  &lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="SSA" scheme="http://haotianmcihael.github.io/tags/SSA/"/>
    
  </entry>
  
  <entry>
    <title>Type system, a Sketchy view.</title>
    <link href="http://haotianmcihael.github.io/2021/06/16/Type-system-a-Sketchy-view/"/>
    <id>http://haotianmcihael.github.io/2021/06/16/Type-system-a-Sketchy-view/</id>
    <published>2021-06-15T18:02:32.000Z</published>
    <updated>2022-03-20T21:39:18.045Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p><code>Type system</code>的基本目的是防止在程序运行时发生<code>execution error</code>。这种<code>Informal statement</code>非形式化描述有很多内涵：首先该如何严格定义<code>execution error</code>；其次在这种定义下，描述<code>absence of execution error</code>也是<code>Type system</code>很<code>nontrivial</code>的性质——当<code>PL .aka. programming language</code>的所有运行时行为都能确保这种性质的话，我们就说该语言是<code>type sound</code>的。事实证明为了更加没有歧义的描述<code>PL</code>的<code>type soundness</code>，需要做大量的分析和证明。因此针对<code>Type system</code>的分类，描述和研究过程逐渐演变成为一套<code>formal discipline</code>即形式化体系。</p><script type="math/tex; mode=display">\frac{\Gamma_{1} \vdash \Im_{1}  ...  \Gamma_{n} \vdash \Im_{n}}{\Gamma \vdash \Im}</script><p><code>The formalization of Type system</code>需要一套精确的符号和定义系统，一个<strong>严格正确</strong>的<code>Type system</code>可以对语言定义的各个重要性质进行<strong>完整</strong>的判断。而非形式化的描述甚至做不到完整概括语言的<code>type structure</code>则更谈不上实现上的唯一性。比如不同的编译器对于同一套语言<code>Type system</code>的实现往往不尽相同，甚至有一些<code>type unsound</code>的语言定义导致一段代码明明通过<code>typechecker</code>的检查但在运行时奔溃掉。理想情况下我们说<code>formal Type system</code>应该是所有<code>typed programming languages</code>内核定义的一部分。这样的话，<code>typechecking</code>算法就可以严格按照精确的类型<code>spec</code>执行，从某种程度上该语言可以看成是<code>Type sound</code>的。</p><a id="more"></a><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Execution-errors"><a href="#Execution-errors" class="headerlink" title="Execution errors"></a>Execution errors</h4><p>比较典型的<code>execution error</code>就是系统出现了意外的<code>software faults</code>比如<code>illegal instruction fault</code>或者<code>illegal memory reference fault</code>等。但是也存在<code>execution error</code>会没有预兆的发生从而导致数据错误。进一步的还存在像<code>divide by zero</code>，或者<code>derferencing nil</code>等<strong><code>Type system</code>无法避免</strong>的<code>sofeware faults</code>。但是有的语言虽然没有<code>Type system</code>却也不会发生<code>software faults</code>。</p><h5 id="safety"><a href="#safety" class="headerlink" title="safety"></a>safety</h5><p>首先对<code>execution errors</code>进行分类：</p><ul><li><code>trapped errors:</code> 导致计算行为瞬间奔溃停止<ul><li>除零错误</li><li>内存非法访问</li></ul></li><li><code>untrapped errors:</code>刚开始不会很明显，但是后续会导致任意错误<ul><li>没有运行时边界检查的数组越界</li><li>引用错误地址</li></ul></li></ul><blockquote><p>A program fragment is <strong>safe</strong> if it does not cause <strong>untrapped  errors</strong> to occur.</p></blockquote><p>所有程序都是<code>safe</code>的语言称为<code>safe languages</code>——因此<code>safe languages</code>是要能排除一切潜在错误。<code>untyped languages</code>通过<code>runtime checks</code>来达到<code>safety</code>——<code>typed languages</code>通过<code>static</code>静态(比如编译期)排除一切潜在错误行为来达到<code>safety</code>，其也可以同时采用<code>runtime</code>和<code>static</code>检查。  </p><h5 id="well-behaved"><a href="#well-behaved" class="headerlink" title="well-behaved"></a>well-behaved</h5><p>针对通用编程语言，我们应该提炼出<code>execution errors</code>的一个子集作为<code>forbidden errors</code>。这个子集应该包含所有的<code>untrapped errors</code>，以及一部分<code>trapped errors</code>。</p><blockquote><p>A program fragment is said to have <strong>good behavior/well-behaved</strong>, if it doesn’t cause any <strong>forbidden error</strong> to occur.</p></blockquote><p><strong>对比一下<code>safe</code>和<code>well-behaved</code>的定义就可以发现<code>well-behaved</code>的代码是<code>safe</code>的，但反之不然。</strong>所有代码都是<code>well-behaved</code>的语言被称为<code>strongly checked</code>。针对一个<code>Strongly checked</code>的语言的特征：</p><ul><li>不会出现<code>untrapped errors</code>（<code>safe</code>的保证）</li><li>不会出现包含在<code>forbidden errors</code>中的部分<code>trapped errors</code></li><li>其余的<code>trapped errors</code>发生也只会由于程序员的自身问题导致</li></ul><p><code>Typed languages</code>通过运行静态检查(比如编译期)来实现语言的<code>well-behaved</code>——这样的语言被称为是<code>staticlly checked</code>，整个检查过程被称为<code>typechecking</code>，执行该检查过程的算法被称为<code>type-checker</code>。一段经过<code>type-checker</code>检查的程序被称为<code>well-typed</code>。<code>staticlly checked languages</code>有<code>ML,Java,Pascal</code>等。  </p><p><code>Untyped languages</code>通过运行时检查<code>runtime checks</code>来排除所有的<code>forbidden errors</code>。比如它们会检查所有数组边界，所有除法操作，并在错误出现的时候触发异常。整个检查过程被称为<code>dynamic checking</code>。<code>LISP</code>就是这样一门语言，这样的语言尽管没有静态检查，没有类型系统，但却还是<code>strongly checked</code>。 </p><h5 id="safety-or-Performance"><a href="#safety-or-Performance" class="headerlink" title="safety or Performance"></a>safety or Performance</h5><p><code>type system</code>的首要目标就是要通过排除所有程序运行时的<code>untrapped errors</code>来确保程序的<code>safety</code>。但是实际上很多静态语言都不能保证<code>safety</code>——它们的类型系统并没有完全排除掉运行时的<code>untrapped errors</code>。这些语言被称为是<code>weakly-typed</code>，而且其程度都各自不同。<code>C</code>在<code>pointer arithmetic</code>和<code>casting</code>上有大量<code>unsafe</code>的操作。</p><p>大多数<code>untyped languages</code>都是<code>completely safe</code>的，否则程序既没有编译期检查又没有运行时检查一旦出错后果不堪设想。比如<code>Assembly</code>就属于这种语言范畴。</p><div class="table-container"><table><thead><tr><th></th><th>Typed</th><th>Untyped</th></tr></thead><tbody><tr><td>Safe</td><td>ML、Java</td><td>LISP</td></tr><tr><td>Unsafe</td><td>C</td><td>Assembly</td></tr></tbody></table></div><p>但程序语言的<code>safety</code>属性一般需要以牺牲性能为代价。但是究其优势：可以通过引入<code>garbage collection</code>来确保运行时结构的完整，最后其对于像<code>OS/web browsers</code>等应用的安全提供了保证。  </p><p>那实现<code>safety</code>是通过类型系统即静态还是运行时即动态:</p><ul><li><code>untyped languages</code>会导致大量<code>safety</code>问题</li><li><code>untyped languages</code>比如<code>LISP</code>要比<code>weakly-typed languages</code>比如<code>C</code>更难维护</li></ul><h4 id="Typed-and-untyped-languages"><a href="#Typed-and-untyped-languages" class="headerlink" title="Typed and untyped languages"></a>Typed and untyped languages</h4><p>程序变量在程序运行期间可以假定一系列的值。  </p><blockquote><font color="red">An upper bound of such a range is called a **type** of the variable.</font>  </blockquote><p>该变量的一个类型就是其值的一个<code>upper bound</code>。比如一个<code>Boolean</code>类型的变量在程序运行过程中只能是<code>true/false</code>，而<code>not(x)</code>在运行时也是有意义的。一门所有变量都有<code>nontrivial types</code>的语言称为<code>typed languages</code>。而没有限制变量范围的语言称为<code>untyped languages</code>——其变量没有<code>type</code>，或者说其变量都有一个<code>universal type</code>。</p><p><code>Type system</code>是<code>type languages</code>的核心部分，用来跟踪<code>types of variables</code>，更普遍的用来跟踪<code>types of expression</code>。只有遵守<code>type system</code>的代码才可以成为该<code>type language</code>的合格程序。而<code>type system</code>可能不会在语言的语法中显式出现。</p><blockquote><font color="red">Type systems are used to determine whether programs are **well behaved.**</font></blockquote><ul><li><code>Explicitly typed:</code> <code>types</code>是语法的一部分</li><li><code>implicitly typed:</code> <code>types</code>不会显式出现在语法中</li></ul><h5 id="properties-of-type-systems"><a href="#properties-of-type-systems" class="headerlink" title="properties of type systems"></a>properties of type systems</h5><p>我们在这里假设程序语言需要即<code>safe</code>又<code>type</code>，因此引入<code>type system</code>的讨论。</p><p><code>Types</code>，作为程序语言的一部分有着和其他<code>program annotations</code>编程标记更加实用的特征。总体上来说，对于程序语言行为的<code>annotations</code>涵盖了<code>informal comments</code>，<code>formal spec</code>，甚至<code>theorem proving</code>等。而<code>Types</code>就在几个范畴的中心地带——其比<code>comments</code>更加精确，但是比<code>formal spec</code>更加简洁和易用。总体来讲<code>type system</code>有如下属性：</p><ul><li><code>decidably verifiable:</code> 需要有算法(指的是<code>typechecker</code>)来确保程序是<code>well-behaved</code>的。<code>type system</code>的目的不仅仅是描述开发者的意图，更重要的是为了捕捉程序运行时错误。（<code>formal spec</code>只能进行描述）</li><li><code>transparent:</code> 开发者对于<code>typechecker</code>的行为应该很易于上手。比如很容易看出某段代码是否可以通过类型测试，如果没有通过则问题一定是开发者自身（<code>automatic theorem proving</code>相比之下更晦涩难懂）</li><li><code>enforceable:</code> <code>type declarations</code>应该被尽可能的完成静态/动态检查。类型声明和其对应程序之间的一致性应该符合验证。（<code>comments</code>无法做到这一点）</li></ul><h4 id="How-type-systems-are-formalized"><a href="#How-type-systems-are-formalized" class="headerlink" title="How type systems are formalized"></a>How type systems are formalized</h4><p>我们如何保证<code>well-typed</code>的程序确实是<code>well-behaved</code>的呢？</p><blockquote><p>这里的<code>well-typed</code>指的是通过人为设计的类型系统算法<code>typechecker</code>，而<code>well-behaved</code>指的是在运行时不会出现<code>forbidden errors</code>。</p></blockquote><p><code>Formal type systems</code>就是在PL文档中对<code>type system</code>非形式化描述背后的数学特征描述。一旦某一个<code>type system</code>被形式化了，我们只需证明以下<code>soundness theorem</code>：</p><blockquote><p><em>Well-typed</em> programs are <em>well-behaved</em>.</p></blockquote><p>一旦该定理成立，我们就说该<code>type system</code>是<code>sound</code>的。</p><blockquote><p>Good behavior of all programs of a typed language and soundness of its type system mean the same thing.</p></blockquote><h5 id="type-and-term"><a href="#type-and-term" class="headerlink" title="type and term"></a>type and term</h5><p>为了形式化一门程序语言的<code>type system</code>并且证明<code>soundness theorem</code>，就需要在本质上将整个语言都形式化。首先要做的就是描述该语言的语法<code>syntax</code>。对于大多数语言来说这就意味着描述其<code>types and terms</code>的语法。</p><ul><li><code>Types</code>描述程序的静态行为</li><li><code>Terms(statements, expressions, and other program fragments)</code>描述算法的行为</li></ul><h5 id="scoping-rules"><a href="#scoping-rules" class="headerlink" title="scoping rules"></a>scoping rules</h5><p>下一步是定义语言的<code>scoping</code>规则——该规则明确定义了<font color="red">标识符的作用域即标识符<code>binding locations</code>声明处和<code>occurrences</code>使用处的联系。<code>Typed languages</code>需要这种<code>scoping</code>是静态的，换句话讲就是说标识符的声明<code>binding locations</code>一定要在运行时之前。</font>而标识符的声明处<code>binding locations</code>往往是由语言语法决定的，因此<code>static scoping</code>也叫做<code>lexical scoping</code>。与之相反的就是<code>dynamic scoping</code>。</p><blockquote><p>Scoping can be formally specified by defining the set of<font color="red"> free variables</font> of a program fragment (which involves specifying how variables are bound by declarations). The associated notion of substitution of types or terms for free variables can then be defined.</p></blockquote><p>对于作用域的形式化可以定义一个<code>program fragment</code>的一系列<code>free variable</code>,接着可以定义如何使用<code>types/terms</code>来替换这些变量。  </p><ul><li><font color="blue">scoping rules, binding locations, free variable</font></li></ul><h5 id="type-rules"><a href="#type-rules" class="headerlink" title="type rules"></a>type rules</h5><p>当这些搞定后，开始定义程序语言的<code>type rules</code>：其通过<code>M:A</code>的形式定义了<code>terms M</code>和<code>types A</code>之间的一种<code>has-type</code>关系。有些语言还通过<code>A&lt;:B</code>的形式定义<code>types</code>之间的<code>subtype-of</code>关系，还有通过<code>A=B</code>的形式定义<code>types</code>之间的<code>equal-type</code>关系。</p><blockquote><p>The collection of type rules of a language forms its type system.</p></blockquote><h5 id="static-typing-environments"><a href="#static-typing-environments" class="headerlink" title="static typing environments"></a>static typing environments</h5><p>在形式化<code>type rules</code>之前还需要引入另一个不会显式出现在语法中的基本概念——<font color="red"><code>static typing environments</code>：其在处理<code>program fragments</code>的过程中记录<code>free variable</code>的<code>type</code>。</font>一般和编译器在处理<code>typechecking</code>趟时其符号表的内容相对应。</p><blockquote><font color="red">The type rules are always formulated with respect to a static environment for the fragment being typechecked.</font></blockquote><font color="blue">比如一个`has-type`关系`M:A`，但是这个关系下`type A`和`term M`相关的`free variable`的信息在`static environment 𝚪`里面的</font>。故这个关系全称应该是`𝚪 ⊢ M:A`，意思是**在静态环境𝚪下，M有A类型**。##### semantics形式化程序语言的最后一步就是将其语义定义为一种`terms`和`results`之间的`relation`。该`relation`的形式很大程度上取决于所采用的语义学风格。语言的语义和`type system`是相互影响的——`term`的`type`和其`results`应该一样或正相关，这是`soundness theorem`的本质。  > <font color="red">the types of a term and of itsresult should be the same (or appropriately related); this is the essence of the soundness theorem.</font><p><code>type system</code>的基本概念对几乎所有编程范式（函数式，命令式，并行）都是适用的。独立的<code>type rules</code>应用于不同的范式时基本不能改变。比如<code>call-by-name</code>和<code>call-by-value</code>的函数的基本语义是一样的。</p><p>这章节我们讨论了独立于语义的<code>type system</code>。但是需要肯定的是，<code>type system</code>一定和一门语义以及该语义所带的<code>soundness</code>相关。</p><blockquote><p>The techniques of structrual operational semantics deal uniformly with a large collection of programming paradigms.</p></blockquote><h4 id="Type-equivalence"><a href="#Type-equivalence" class="headerlink" title="Type equivalence"></a>Type equivalence</h4><p>正向前文所说的，大多数<code>nontrivial type system</code>都会定义一种<code>equal type</code>的关系代表<code>type equivalence</code>。这一属性在定义一门编程语言时候异常重要：<strong>什么时候两个分别定义的<code>type expression</code>是一致的？</strong>比如两个由相似类型连接的不同<code>type names</code>：</p><blockquote><p>type X = Bool.</p><p>type Y = Bool.</p></blockquote><p>如果<code>type names</code>X和Y因为与相似类型关联而匹配，我们称为<code>structural equivalence</code>。如果由于<code>type names</code>不同而无法匹配（并没有参考相关联的类型），我们称为<code>by-name equivalence</code>。</p><p>通常情况下大多数语言会使用<code>structural and by-name</code>的混合。<code>Pure structural equivalence</code>可以通过<code>type rules</code>精确定义，然而<code>by-name equivalence</code>更难确定。后续的讨论我们基本讨论<code>structural equivalence</code>，而<code>by-name equivalence</code>可以使用前者很好的进行模拟。</p><h3 id="The-language-of-type-systems"><a href="#The-language-of-type-systems" class="headerlink" title="The language of type systems"></a>The language of type systems</h3><p><code>Type system</code>定义程序语言的<code>type rules</code>——独立于特定的<code>typechecking algorithms</code>。其和<code>formal grammar</code>定义程序语言的<code>syntax</code>但独立于特定的<code>parsing algorithms</code>是同样的道理。  </p><p>将<code>type system</code>和<code>typechecking algorithms</code>分离更加高效：<code>type system</code>属于语言定义<code>language definitions</code>，而<code>algorithms</code>属于编译器实现。通过<code>type system</code>映射语言的类型信息要比用编译器算法更加简洁。同一套<code>type system</code>在不同编译器上可能会有多种<code>typechecking</code>算法。</p><h4 id="Judgements"><a href="#Judgements" class="headerlink" title="Judgements"></a>Judgements</h4><p><code>Type system</code>由一套特殊的形式化方法描述。下面开始讨论：</p><p>首先引入一套形式化机制称作<code>judgments</code>:</p><script type="math/tex; mode=display">\Gamma \vdash \Im  \qquad \text{ℑ is an assertion;the free variables of ℑ are declared in 𝚪}</script><p>读作<code>𝚪 entails ℑ</code>(𝚪包含ℑ)。  </p><p><code>𝚪</code>是一个<code>static typing environment</code>，比如一个由不同变量及其相应<code>type</code>组成的有序链表，通过∅, x<sub>1</sub>:A<sub>1</sub>, …, x<sub>n</sub>:A<sub>n</sub>的形式。空环境记作∅，而在𝚪环境中声明的变量集合x<sub>1</sub>…x<sub>n</sub>记作<code>dom(𝚪)</code>——𝚪的<code>domain</code>值域。  </p><font color="red">ℑ是一种断言，其形式随着不同的`judgement`会变化，但是ℑ中的所有`free variables`都必须**声明**在𝚪中。</font><blockquote><font color="blue"> a term M has a type A with respect to a static typing environment for the free variables of M.   最重要的`judgement`是`typing judgement`，其断言为：对于针对`M`中所有`free variable`的静态环境`𝚪`的来说，`term M`的类型是`A`。</font></blockquote><ul><li>Term: statements, expressions, and other program fragments</li></ul><script type="math/tex; mode=display">\Gamma \vdash M:A   \qquad \text{M has type A in 𝚪}</script><p>比如举例如下：</p><script type="math/tex; mode=display">\begin{aligned}&\emptyset \vdash true:Bool &&\qquad \text{true has type Bool} \\&\emptyset,x:Nat \vdash x+1:Nat &&\qquad \text{x+1 has type Nat, provided that x has type Nat}\\\end{aligned}</script><p>其他类型的<code>judgement</code>也很常见，比如下面断言为<code>an environment is well-formed</code>:</p><script type="math/tex; mode=display">\Gamma \vdash \diamond  \qquad \text{𝚪 is well-formed(i.e., it has been properly constructed)}</script><h4 id="Type-rules"><a href="#Type-rules" class="headerlink" title="Type rules"></a>Type rules</h4><p><code>Type rules</code>：在<code>valid judgements</code>的前提下，断言<code>certain judgement</code>有效。一般都以某些本质上有效的<code>judgements</code>作为开始(常见的有：∅⊢◇,表示<code>empty environment is well-formed</code>)。</p><script type="math/tex; mode=display">\begin{aligned}&\text{ (Rule name)} \quad \quad \text{ (Annotations)}    \\&\frac{\Gamma_{1} \vdash \Im_{1}  \quad ... \quad \Gamma_{n} \vdash \Im_{n} \text{ (Annotations)}}{\Gamma \vdash \Im}\end{aligned}\qquad \text{ General form of a type rule.}</script><p>每一个<code>type rule</code>的格式：在水平线上面的是一系列<code>premise judgements</code>:𝚪<sub>i</sub> ⊢ ℑ<sub>i</sub>，而在水平线下面的是<code>conclusion judgements</code>: 𝚪⊢ℑ。当所有的<code>premise</code>都满足之后，<code>conclusion</code>一定成立。<code>premise</code>的数量可以为零。而且每一个<code>type rules</code>都有一个名字：根据惯例，名字的第一个单词是由<code>conclusion judgements</code>规定的~比如<code>conclusion</code>是一个<code>value typing judgement</code>的<code>type rules</code>的名字就会叫做<code>Val...</code>。必要的时候，限制<code>rule</code>的一些条件和需要用到的一些缩写都会在<code>typ rule</code>或者<code>premise</code>旁边进行批注。比如一下例子：</p><script type="math/tex; mode=display">\begin{aligned}&\text{ (Val n) (n=0,1,...)} \\&\frac{ \Gamma \vdash \diamond }{\Gamma \vdash n:Nat}\end{aligned} \qquad \begin{aligned}&\text{ (Val+)} \\&\frac{\Gamma \vdash M:Nat \qquad \Gamma \vdash N:Nat}{\Gamma \vdash \text{M+N:Nat}} \end{aligned}</script><p> 比如第一个<code>type rule</code>表示所有的<code>numeral</code>自然数都是<code>Nat</code>类型。<font color="red">第二个【结合<code>Typing Judgements</code>】</font><code>type rule</code>表示两个<code>Nat</code>类型的表达式<code>M</code>和<code>N</code>可以构成一个更大的<code>Nat</code>类型的表达式<code>M+N</code>，<font color="blue">Moreover, the environment 𝚪 for M and N, which declares the types of any free variable of M and N, carries over to M+N并且静态环境<code>𝚪</code>不仅声明了<code>M</code>和<code>N</code>的所有<code>free variable</code>的类型，更涵盖了<code>M+N</code>的类型。</font>  </p><font color="orange">注释：首先`static typing environment`记录程序中`free variable`的类型信息-These are used to record the types of free variables during the processing of program fragments;   其次`typing judgements`是断言`term`有类型-It asserts that a term M has a type A with respect to a static typing environment for the free variables of M。</font><p>基本的规则表示<code>empty environment</code>是<code>well formed</code>的，不需要前提：</p><script type="math/tex; mode=display">\text{(Env ∅)} \\ \frac{}{\emptyset \vdash \diamond}</script><blockquote><p>A collection of type rules is called a (formal) type system. Technically, type system fit into the general framework of <em>formal proof system</em>:  collections of rules used to carry out step-by-step deductions.   </p><p><strong>The deductions carried out in type systems concern the typing of prorgams.</strong></p></blockquote><p>技术上讲，<code>type system</code>满足形式化证明系统<code>formal proof systems</code>的基本框架：一系列的<code>type rules</code>被用来执行一步一步的推理演绎。类型系统推理的过程就是程序中类型的概念。</p><h4 id="Type-derivations"><a href="#Type-derivations" class="headerlink" title="Type derivations"></a>Type derivations</h4><p><code>derivation</code>在<code>type system</code>中是以<code>judgements tree</code>的形式，上面是叶子，最后是根——每一个<code>judgement</code>都可以从其上面的叶子部分根据一定规则推导得到。<code>type system</code>最基本的要求就是看其<code>derivation</code>是否是正确构建的。  </p><p>在一套<code>type system</code>中，能正确应用<code>type rules</code>推导出来的一定是<code>valid judgement</code>。比如下面：</p><script type="math/tex; mode=display">\begin{aligned}\dfrac{\dfrac{\dfrac{}{\emptyset \vdash \diamond}  \text{by(Env ∅)}}{\emptyset \vdash 1:Nat}  \text{by(Val n)} \quad \dfrac{\dfrac{}{\emptyset \vdash \diamond}  \text{by(Env ∅)}}{\emptyset \vdash 2:Nat}  \text{by(Val n)}}{\emptyset \vdash 1+2:Nat}  \text{by(Val +)}\end{aligned}</script><p>根据前面给出的规则，我们可以构造出新的<code>derivation</code>即<code>∅⊢1+2:Nat</code>是<code>valid judgement</code>。其中每一步推导用到的规则都标记在右边。</p><h4 id="Well-typing-and-type-inference"><a href="#Well-typing-and-type-inference" class="headerlink" title="Well typing and type inference"></a>Well typing and type inference</h4><p>给定一个<code>type system</code>，如果存在一个类型<code>A</code>使得<code>𝚪⊢M:A</code>是有效的——那么对于环境<code>𝚪</code>来说<code>M is well typed</code>的，即<code>term M</code>被赋予某个类型。</p><blockquote><p>The discovery of a derivation(and hence of a type) for a term is called the <strong>type inference</strong>.</p></blockquote><p>比如在一个简单的<code>type system</code>中，其有<code>rules(Env ∅),(Val n),(Val +)</code>，那么根据前面的推导，在空环境<code>empty environment</code>下的<code>term 1+2</code>可以被推导出Nat类型。假设我们给该类型系统加入<code>premise 𝚪⊢◇</code>和<code>conclusion 𝚪⊢true:Booll</code>，那么我们将无法对<code>term true+1</code>推导出任何类型，这是因为没有一个将<code>natural</code>和<code>boolean</code>类型相加的<code>rule</code>。因为无法推导出<code>1+true</code>的<code>derivations</code>，我们就说<code>1+true</code>是<code>not typeable</code>的，或者说其发生了<code>typing error</code>。我们继续给上述类型系统加入<code>premise 𝚪⊢M:Nat</code>和<code>conclusion 𝚪⊢N:Bool</code>和<code>conclusion 𝚪⊢M+N:Nat</code>（通过将true解释为整数1）。那么<code>term 1+true</code>将会被推导出一个<code>Nat</code>类型。</p><p>可以看出，<code>type inference</code>非常依赖<code>type system</code>。一个类型推导算法可以很简单，也可以很难或者压根不可能实现。虽然类型系统通常是抽象表达设计，但是其实用性则完全取决于类型推导算法的可用性。  </p><p><code>explicitly typed languages</code>比如<code>pascal</code>的类型推导相对容易简单，而<code>implicitly typed languages</code>比如<code>ML</code>的类型推导相对更困难一些。类型推导的基本思路很清晰易懂，但是真正实际中的实现却相当复杂并且还在研究中。  </p><blockquote><p>Type inference problem becomes particularly hard in the presence of <strong>polymorphism.</strong></p></blockquote><p>对于<code>explicitly typed languages</code>比如<code>Ada, CLU, ML</code>等的<code>polymorphic features</code>的<code>type inference</code>在实践中得到了解决——是通过纯算法问题，而不是在引入相关<code>type system</code>的基础上解决的。<strong>而往往最纯粹，最普遍的针对多态的类型推导问题都是在𝛌演算中讨论的。</strong> 然而该问题的结局却依赖于不切实际的冗长的一些<code>typing annotations</code>。为了让该多态方案更加实际化一点，需要省略一些类型信息。这个领域依然是目前学术界的研究重点。  </p><h4 id="Type-soundness"><a href="#Type-soundness" class="headerlink" title="Type soundness"></a>Type soundness</h4><p>最后需要注意的是，<code>type system</code>不是一系列任意的<code>type rules</code>的堆积。<code>well-typing</code>在语义层面对应着<code>good behavior</code>。通常通过证明<code>type soundness theorem</code>来检查类型系统内部的一致性——因此类型系统需要语义作为基础。对于<code>denotational semantics</code>来说如果<code>∅⊢M:A</code>是有效的，则〖M〗∊〖A〗(即M的值属于类型A所表示的集合)，对于<code>operational semantics</code>来说如果<code>∅⊢M:A</code>成立，并且M推导出M’，则<code>∅⊢M&#39;:A</code>成立。对于两个例子来说，<code>type soundness theorem</code>断言<code>well-typed</code>的程序不会在计算过程中出现<code>execution errors</code>。</p><h3 id="First-order-Type-Systems"><a href="#First-order-Type-Systems" class="headerlink" title="First-order Type Systems"></a>First-order Type Systems</h3><p>在大多数过程间语言中实现的<code>type system</code>称为<code>first order</code>。核心就是包括<strong>高阶函数<code>higher order functions</code></strong>。最精简的<code>first-order type system</code>可以由<code>untyped 𝛌-calculus</code>表示，形式为<code>𝛌x.M</code>即有参数<code>x</code>和返回值<code>M</code>的匿名函数。</p><p><code>first-order typed 𝛌-calculus</code>被称为F<sub>1</sub>。它和<code>untyped 𝛌-calculus</code>不同的地方在于对<code>𝛌-abstractions</code>加上了类型信息——<code>𝛌x:A.M</code>其中<code>x</code>是参数，<code>A</code>是参数类型，而<code>M</code>是函数体。<strong>将<code>𝛌x.M</code>转化为<code>𝛌x:A.M</code>是将非类型语言进阶为类型语言的关键步骤：<code>bound variables</code>获取到了类型信息。</strong>因为F<sub>1</sub>是建立在函数基础上的，所以引入<code>A⟶B</code>带有参数类型A和返回值类型B的函数类型。介绍构建函数类型所需的基本类型：引入<code>Basic</code>表示该类型集合，引入<code>K∊Basic</code>表示集合中的任何一个该类型。 </p><h4 id="Syntax-of-F1"><a href="#Syntax-of-F1" class="headerlink" title="Syntax of F1"></a>Syntax of F<sub>1</sub></h4><blockquote><p>A,B ::=                                types</p><p>​        K     K∊Basic                 basic types</p><p>​        A⟶B                            function types</p><p>M,N ::=                                terms</p><p>​        x                                      variable</p><p>​        𝛌x:A.M                            function</p><p>​        M N                                 application    </p></blockquote><p>F<sub>1</sub>的语法如上图所示。这里有必要简单说明一下<code>typed language</code>的语法。对于<code>untyped language</code>来说<code>context-free syntax</code>就可以完整描述整个语言。而对于<code>typed language</code>来说却不够；<font color="red"><code>typed language</code>不仅仅需要<code>type system</code>来完善程序语言的<code>legality</code>，还需要<code>context-free syntax</code>来表示定义<code>free/bound variable</code>概念——即定义程序语言的<code>scoping rules</code>。</font>在作用域的基础上，那些只有<code>bound variable</code>不同的<code>term</code>会被称为是语法上相同的<code>syntactically identical</code>比如<code>𝛌x:K.x</code>和<code>𝛌y:K.y</code>。  </p><h4 id="Basic-of-F1"><a href="#Basic-of-F1" class="headerlink" title="Basic of F1"></a>Basic of F<sub>1</sub></h4><p>F<sub>1</sub>需要三个<code>judgements</code>如下：</p><div class="table-container"><table><thead><tr><th>𝚪⊢◇</th><th>𝚪 is a well-formed environment</th></tr></thead><tbody><tr><td>𝚪⊢A</td><td>A is a well-formed type in 𝚪</td></tr><tr><td>𝚪⊢M:A</td><td>M is a well-formed term of type A in 𝚪</td></tr></tbody></table></div><p>其中<code>𝚪⊢A</code>有点冗余，因为所有语法上正确的类型<code>A</code>在任何环境<code>𝚪</code>下都是<code>well-formed</code>的。而在<code>second-order</code>系统中，类型的<code>well-formed</code>就不单单取决于语法了，这时候<code>𝚪⊢A</code>就很重要了。证明这些<code>judgement</code>的有效性的<code>type rules</code>在下面表格中。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Env ∅)} \qquad &&\text{(Env x)} \\ &\frac{}{\emptyset \vdash \diamond} \qquad &&\frac{\Gamma \vdash A \quad x\notin dom(\Gamma)}{\Gamma,x:A\vdash \diamond} \\ \\&\text{(Type Const)}  &&\text{(Type Arrow)} \\&\frac{\Gamma \vdash \diamond \quad K\in Basic}{\Gamma \vdash K} &&\frac{\Gamma \vdash A \quad \Gamma \vdash B}{\Gamma \vdash A\to B} \\ \\&\text{(Val x)} &&\text{(Val fun)} &&&\text{(Val Appl)} \\&\frac{\Gamma^{'},x:A,\Gamma^{''}\vdash \diamond}{\Gamma^{'},x:A,\Gamma^{''}\vdash x:A} &&\frac{\Gamma, x:A\vdash M:B}{\Gamma \vdash \lambda x:A.M:A\to B} &&&\frac{\Gamma \vdash M:A\to B \quad \Gamma \vdash N:A}{\Gamma \vdash MN:B}\end{aligned}</script><p>其中规则<code>Env ∅</code>是唯一不需要前提的：空环境<code>empty environment</code>是有效的环境。规则<code>Env x</code>用来将环境<code>𝚪</code>扩展到范围更大的有效环境𝚪,<code>x:A</code>——前提是<code>A</code>在<code>𝚪</code>中是一个有效的类型。注意到对前提<code>𝚪⊢A</code>应用归纳原则就需要<code>𝚪</code>是合法的。也就是说必须由<code>𝚪⊢◇</code>推导出<code>𝚪⊢A</code>。另一个前提是变量<code>x</code>不能在环境<code>𝚪</code>中被使用<font color="blue">must not be defined.</font>。我们应该明确在环境中的所有不同变量，比如当<code>ValFun</code>规则中的前提<code>𝚪,x:A⊢M:B</code>被推导时（出现在水平线下面），<code>x</code>就不能出现在<code>dom(𝚪)</code>中。  </p><p>规则<code>Type Const</code>和<code>Type Arrorw</code>用来构建类型。规则<code>Val x</code>使用非正式的<code>𝚪&#39;,x:A,𝚪&#39;&#39;</code>表示<code>x:A</code>在环境中的任意地方出现。规则<code>Val Fun</code>对函数<code>𝛌x:A.M</code>赋值了<code>A⟶B</code>类型，前提是首先参数有<code>A</code>类型之后，函数体被赋予了<code>B</code>类型。要注意该规则中<code>environment</code>是如何改变长度的。<code>Val Appl</code>规则将参数传给函数求值。下面展示了F<sub>1</sub>所有的<code>derivation</code>：</p><p><img src="1.png" width="50%" height="50%" alt=""></p><h4 id="Expansion-of-F1"><a href="#Expansion-of-F1" class="headerlink" title="Expansion of F1"></a>Expansion of F<sub>1</sub></h4><p>现在既然了解过了简单的<code>first-order type system</code>，我们可以通过丰富其内容来将其打造成为一个现实语言的类型系统。我们要为每一个新添加的类型构造添加一组<code>rules</code>。我们首先引入一些基础类型：<code>Unit Type</code>其值就是常数<code>constant unit</code>；<code>Bool Type</code>其值就是<code>true or false</code>；<code>Nat Type</code>其值是自然数。  </p><h5 id="Unit-Type"><a href="#Unit-Type" class="headerlink" title="Unit Type"></a>Unit Type</h5><p><code>Unit Type</code>经常用来填充一些空参数和结果比如某些语言中的<code>Void/Null</code>。该类型没有操作，所以我们只需要一条规则陈述<code>Unit</code>是合法的类型，值<code>unit</code>是类型<code>Unit</code>的合法值即可。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Unit)} \quad &&\text{(Val Unit)} \\&\frac{\Gamma \vdash \diamond}{\Gamma \vdash Unit} \quad && \frac{\Gamma \vdash \diamond}{\Gamma \vdash unit:Unit}\end{aligned}</script><h5 id="Bool-Type"><a href="#Bool-Type" class="headerlink" title="Bool Type"></a>Bool Type</h5><p><code>Type Bool</code>也有相似结构的规则，不同的是<code>booleans</code>有一个实际操作——<code>condition</code>。在规则<code>Val Cond</code>中，其两个分支都必须有相同的类型，这是因为这两个都有可能成为结果所以需要保持一致。  </p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Bool)}  &&\text{(Val True)}  \\&\frac{\Gamma \vdash \diamond}{\Gamma \vdash Bool} \quad && \frac{\Gamma \vdash \diamond}{\Gamma \vdash true:Bool} \quad  \\\\ &\text{(Val False)} &&\text{(Val Cond)} \\&\frac{\Gamma \vdash \diamond}{\Gamma  \vdash false:Bool} && \frac{\Gamma \vdash M:Bool \quad \Gamma \vdash N_1:A \quad \Gamma \vdash N_2:A}{\Gamma \vdash (if_A \text{M then} N_1 \text{else} N_2):A}\end{aligned}</script><p>规则<code>Val Cond</code>引出了一个在<code>typechecking</code>的时候需要用到的类型信息的问题。当遇到条件语句的时候，一般<code>typechecker</code>会分别推断N<sub>1</sub>和N<sub>2</sub>的类型，然后在找到一个和前面找到的两个类型兼容的类型A。在一些类型系统中这种推断不是很容易进行，因此为了解决这个问题，我们使用下标类型<code>suubstripted type</code>来表示额外增加的类型信息：if<sub>A</sub>就是<code>typechecker</code>的提示：最终类型可能是A，而从N<sub>1</sub>和N<sub>2</sub>推断出来的类型信息需要和其做比较。一般情况下我们都会使用下标类型来表示可能会有用的一些类型信息，但是目前比较成熟的<code>typechecker</code>都会自己合成该类型信息，因此其可以省略掉。</p><h5 id="Nat-Type"><a href="#Nat-Type" class="headerlink" title="Nat Type"></a>Nat Type</h5><p>自然数的类型<code>Nat Type</code>可以通过0和<code>succ</code>的规则都推导出来。在该类型上的操作通过<code>pred</code>和<code>isZero</code>(测试零值)原语变的可能。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Nat)} \quad &&\text{(Val Zero)} \quad &&&\text{(Val Succ)} \\&\frac{\Gamma \vdash \diamond}{\Gamma \vdash Nat} && \frac{\Gamma \vdash \diamond}{\Gamma \vdash 0:Nat} &&&\frac{\Gamma \vdash M:Nat}{\Gamma \vdash succ M:Nat} \\\\&\text{(Val Pred)} &&\text{(Val IsZero)} \\&\frac{\Gamma \vdash M:Nat}{\Gamma \vdash pred M:Nat} &&\frac{\Gamma \vdash M:Nat}{\Gamma \vdash isZero M:Bool}\end{aligned}</script><h5 id="Product-Type"><a href="#Product-Type" class="headerlink" title="Product Type"></a>Product Type</h5><p>既然我们有了一系列基本类型，我们可以考虑一些结构化类型，从<code>product Type</code>开始，一个<code>product Type</code> A<sub>1</sub>XA<sub>2</sub>表示两个类型分别是A<sub>1</sub>和A<sub>2</sub>的元素组成的值对的类型。这两个元素可以分别被投影为<code>projections first</code>和<code>projections second</code>。或者我们可以使用<code>with</code>语句，将一个<code>pair M</code>分解，并将其两个元素绑定在作用域N下的两个变量v<sub>1</sub>和v<sub>2</sub>上。<strong><code>with</code>语句对应着<code>ML</code>语言中的<code>pattern matching</code>和<code>pascal</code>语言中的<code>with</code></strong>；  </p><p><code>product Type</code>还可以通过相对应的<code>projections</code>和<code>with</code>被用来构建<code>tuple Type</code>A<sub>1</sub>XA<sub>2</sub>…XA<sub>i</sub>。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Product)} \quad &&\text{(Val Pair)} \\&\frac{\Gamma \vdash A_1 \quad \Gamma \vdash A_2}{\Gamma \vdash A_1 \times A_2} && \frac{\Gamma \vdash M_1:A_1 \quad \Gamma \vdash M_2:A_2}{\Gamma \vdash \langle M_1,M_2 \rangle:A_1 \times A_2} \\\\&\text{(Val First)} \quad &&\text{(Val Second)} \\&\frac{\Gamma \vdash M: A_1 \times A_2}{\Gamma \vdash firstM:A_1} &&\frac{\Gamma \vdash M:A_1 \times A_2}{\Gamma \vdash second M:A_2} \\\\&\text{(Val  With)} \\& \frac{\Gamma \vdash M:A_1 \times A_2 \quad \Gamma ,x_1:A_1,x_2:A_2\vdash N:B}{\Gamma \vdash (with(x_1:A_1,x_2:A_2):=M do N):B}\end{aligned}</script><h5 id="Union-Type"><a href="#Union-Type" class="headerlink" title="Union Type"></a>Union Type</h5><p><code>Type Union</code>经常被忽视，但其和<code>product Type</code>一样重要。一个<code>union</code>:A<sub>1</sub>+A<sub>2</sub>的元素可以被看成是有左标记的A<sub>1</sub>类型（<code>tagged with a left token</code>），或者是一个有右标记的A<sub>2</sub>类型。这里的标记可以被<code>isLeft/isRight</code>检测其类型结果分别是<code>asLeft/asRight</code>。如果<code>asLeft</code>被错误的赋给<code>right-tagged</code>的值，那么<code>trapped error</code>就会发生。但是这个错误并不是<code>forbidden error</code>。因为假定<code>asLeft</code>有A<sub>1</sub>类型的情况都是<code>safe</code>的。规则<code>Val Case</code>表述了一种优雅的可以替换<code>isLeft/isRight/asLeft/asRight</code>的构造方式和其相应的<code>trapped errors</code>。其还消除了<code>union</code>对<code>Bool</code>类型的依赖。case构造根据M的标记执行两个分支中的一个，M的未标记内容分别绑定到N<sub>1</sub>或N<sub>2</sub>范围内的x<sub>1</sub>或x<sub>2</sub>。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Union)}  \\&\frac{\Gamma \vdash A_1 \quad \Gamma \vdash A_2}{\Gamma \vdash A_1+A_2} \\\\ & \text{(Val inLeft)} &&\text{(Val inRight)} \\& \frac{\Gamma \vdash M_1:A_1 \quad \Gamma \vdash A_2}{\Gamma \vdash inLeft_{A_{2}}M_1:A_1+A_2} && \frac{\Gamma \vdash A_1 \quad  \Gamma \vdash M_2:A_2}{\Gamma \vdash inRight_{A_{1}}M_2:A_1+A_2} \\\\&\text{(Val isLeft)} &&\text{(Val isRight)} \\&\frac{\Gamma \vdash M:A_1+A_2}{\Gamma \vdash isLeft M:Bool}&&\frac{\Gamma \vdash M:A_1+A_2}{\Gamma \vdash isRight M:Bool} \\\\&\text{(Val asLeft)} &&\text{(Val asRight)} \\&\frac{\Gamma \vdash M:A_1+A_2}{\Gamma \vdash asLeft M:A_1} &&\frac{\Gamma \vdash M:A_1+A_2}{\Gamma \vdash asRight M:A_2} \\\\&\text{(Val Case)} \\&\frac{\Gamma \vdash M:A_1+A_2 \quad \Gamma,x_1:A_1 \vdash N_1:B \quad \Gamma,x_2:A_2\vdash N_2:B}{\Gamma \vdash (case_B Mofx_1:A_1 thenN_1|x_2:A_2thenN_2):B}\end{aligned}</script><p>在程序表达方面而不是实现方面，注意<code>Bool Type</code>可以被定义为<code>Unit + Unit</code>，在这种情况下<code>case</code>的构造就会简化成为<code>condition</code>构造。<code>Int Type</code>可以被定义为一个正数<code>Nat</code>类型加上一个负数<code>Nat</code>类型。</p><h5 id="Record-Type"><a href="#Record-Type" class="headerlink" title="Record Type"></a>Record Type</h5><p><code>Product Type</code>和<code>Union Type</code>类型可以进一步迭代成为<code>tuple Type</code>和<code>multiple unions Type</code>。但是这两种构造太复杂而且不太常出现在现代语言中。而另一中形式<code>labeld</code>的<code>product and union</code>经常被用到：<code>record Type</code>和<code>Variant Type</code>。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Record)} (l_i \ distinct)  \\&\frac{\Gamma \vdash A_1 \quad ... \quad \Gamma \vdash A_n}{\Gamma \vdash Record(l_1:A_1,...,l_n:A_N)} \\\\& \text{(Val Record)} (l_i \ distinct)   \\&\frac{\Gamma \vdash M_1:A_1 \quad ... \quad \Gamma \vdash M_n:A_n}{\Gamma \vdash record(l_1=M_1,...,l_n=M_n):Record(l_1:A_1,...,l_n:A_n)} \\\\&text{Val Record Select} \\&\frac{\Gamma \vdash M:Record(l_1:A_1,...,l_n:A_n) \quad j\in 1...n}{\Gamma \vdash M.l_j:A_j} \\\\&\text{Val Record With} \\&\frac{\Gamma \vdash M:Record(l_1:A_1,...,l_n:A_n)  \qquad \Gamma,x_1:A_1,...x_n:A_n \vdash N:B}{\Gamma \vdash (with(l_1=x_1:A_1,...,l_n=x_n:A_n):MdoN):B}\end{aligned}</script><p><code>record</code>类型可以通过名称来实现提取元素，基本上就是将多个<code>product</code>类型并起来。其规则都是从语法层面按照其元素各自的类型将其进行重组。一个<code>product</code>类型A<sub>1</sub>XA<sub>2</sub>可以被定义为<code>Record</code>类型(first:A<sub>1</sub>, second:A<sub>2</sub>)。</p><h5 id="Variant-Type"><a href="#Variant-Type" class="headerlink" title="Variant Type"></a>Variant Type</h5><p><code>Variant Type</code>就是复杂版的<code>Union Type</code>。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Variant)} (l_i \ distinct)  \\&\frac{\Gamma \vdash A_1 \quad ... \quad \Gamma \vdash A_n}{\Gamma \vdash Variant(l_1:A_1,...,l_n:A_n)} \\\\&\text{(Val Variant)} (l_i \ distinct) \\& \frac{\Gamma \vdash A_1 \quad ... \quad \Gamma \vdash A_n \qquad \Gamma \vdash M_j:A_j \quad j\in1...n}{\Gamma \vdash variant_{l_1:A_1,...,l_n:A_n}(l_j=M_j):Variant(l_1:A_1,...,l_n:A_n)} \\\\&\text{(Val Variant Is)} \\&\frac{\Gamma \vdash M:Variant(l_1:A_1,...,l_n:A_n) \qquad j\in1...n}{\Gamma \vdash M as l_j:A_j} \\\\&\text{(Val Variant As)} \\&\frac{\Gamma \vdash M:Variant(l_1:A_1,...,l_n:A_n \qquad j\in1...n)}{\Gamma \vdash Misl_j:Bool} \\\\&\text{Val Variant Case} \\&\frac{\Gamma \vdash M:Variant(l_1:A_1,...,l_n:A_n) \qquad \Gamma,x_1:A_1\vdash N_1:B \quad ... \quad \Gamma,x_n:A_n \vdash N_n:B}{\Gamma \vdash (case_B M of l_1=x_1:A_1 then N_1 | ...|l_n=x_n:A_nthen N_n):B}\end{aligned}</script><p><code>Union Type</code>A<sub>1</sub>+A<sub>1</sub>可以被定义为<code>Variant</code>(left:A<sub>1</sub>,right:A<sub>2</sub>)。另外<code>Enumeration Types</code>比如<code>{red, green, blue}</code>可以被定义为<code>Variant</code>(red:Unit, green:Unit,blue:Unit)。其中<code>Is</code>规则是<code>isLeft/isRight</code>，，而<code>As</code>规则是<code>asLeft/asRight</code>，但是如果直接使用<code>union</code>规则的话就需要<code>case</code>处理多个分支。</p><h5 id="Reference-Type"><a href="#Reference-Type" class="headerlink" title="Reference Type"></a>Reference Type</h5><p><code>Reference Type</code>可以被用来处理命令式语言中的<code>mutable locations</code>的基本类型。<code>Ref(A)</code>的一个元素就是一个包含类型A的可变地址。新地址可以被<code>Val Ref</code>分配，或者被<code>Val Assign</code>规则更新，或者使用<code>Val Deref</code>进行解引用。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Ref)}  &&\text{(Val Ref)}  \\&\frac{\Gamma \vdash A}{\Gamma \vdash RefA} && \frac{\Gamma \vdash M:A}{\Gamma \vdash refM:RefA} \\\\&\text{(Val Deref)} &&\text{(Val Assign)} \\&\frac{\Gamma \vdash M:RefA}{\Gamma \vdash derefM:A} &&\frac{\Gamma \vdash M:RefA \qquad \Gamma \vdash N:A}{\Gamma \vdash M:=N:Unit}\end{aligned}</script><font color="red">因为赋值语句的目的是为了产生`side effect`，所以其值就必须是`unit`-. Since the main purpose of an assignment is to perform a side effect, its resulting value is chosen to be unit</font>  <p>一些常规的<code>mutable</code>类型也可以从<code>Ref</code>类型中派生出来，比如<code>Mutable record types</code>就是一个包含着<code>Ref</code>类型的<code>record</code>类型。</p><h5 id="Array-Type"><a href="#Array-Type" class="headerlink" title="Array Type"></a>Array Type</h5><p><code>array</code>和<code>array</code>操作使用了一些<code>arithmetic primitives and local let declarations</code>等。比较复杂构造的规则可以通过简单构造的规则推导出来。下面给出<code>arrays</code>的实现过程：</p><script type="math/tex; mode=display">\begin{aligned}Array&(A) \quad \triangleq  && \text{Array type} \\&Nat \times(Nat\to Ref(A)) &&\text{a bound plus a map from indices} \text{less than the bound to refs} \\array_A&(N,M) \triangleq  && \text{Array constructor(for N refs initialized to M)} \\&let \ cell_0:Ref(A) = \\ &ref(M)and...and\ \\ &cell_{N-1}:Ref(A)=ref(M).\\&in \langle N,\lambda x:Nat.\ if\ x=0 \\&\ then \ cell_0\ else\ if\ ...\ else\ \\ &if\ x=N-1\ then\ cell_{N-1}\ \\&else\ error_{Ref_{(A)}}.\rangle \\bound&(M) \triangleq && \text{Array bound} \\&first \ M \\M[N]_A &\triangleq && \text{Array indexing} \\&if\ N\ <\ first\ M \\&then\ deref\ ((second\ M)(N)) \\&else \ error_A\\M[N]:&=P\ \triangleq &&\text{Array update} \\&if\ N\ <\ first\ M \\&then\ ((second\ M)(N)):=P \\&else\ error_Unit\end{aligned}</script><p>下面给出<code>Array</code>类型的规则：</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Type Array)} \\&\frac{\Gamma \vdash A}{\Gamma \vdash Array(A)} \\\\&\text{(Val Array)} &&\text{(Val Array Bound)}\\&\frac{\Gamma \vdash N:Nat \quad \Gamma \vdash M:A}{\Gamma \vdash array(N,M):Array(A)} &&\frac{\Gamma \vdash M:Array(A)}{\Gamma \vdash bound\ M:Nat} \\\\&\text{(Val Array Index)} &&\text{(Val Array Update)} \\&\frac{\Gamma \vdash N:Nat \quad \Gamma \vdash M:Array(A)}{\Gamma \vdash M[N]:A} &&\frac{\Gamma \vdash N:Nat \quad \Gamma \vdash M:Array(A) \quad \Gamma \vdash P:A}{\Gamma \vdash M[N]:=P:Unit}\end{aligned}</script><h5 id="Recursive-Type"><a href="#Recursive-Type" class="headerlink" title="Recursive Type"></a>Recursive Type</h5><p>在大多数编程语言中，类型可以被递归定义。<code>Recursive Types</code>让其他类型的构造变的更加有用，但是一般不会显式定义出来，故其形式化方式非常特殊。  </p><p>处理递归类型需要对F<sub>1</sub>基础部分做一些增加，<code>environments</code>需要加入<code>type variables X</code>。这个类型变量的形式是<code>𝛍X.A</code>，代表了对递归表达式<code>X=A(X may occur in A)</code>的一种抽象。<code>fold/unfold</code>操作分别映射递归类型及其同型<code>𝛍X.A/[𝛍X.A/X]A</code>（比如<code>[B/X]A</code>意为将在A中的自由出现的X都替换成为B）。这些操作并没有运行时花销，因此在语法中也经常被忽略，但是其存在使得形式化处理变得更加便捷。</p><script type="math/tex; mode=display">\begin{aligned}&\text{(Env X)} &&\text{(Type Rec)} \\&\frac{\Gamma \vdash \diamond \quad X \notin dom(\Gamma)}{\Gamma,X\vdash \diamond} &&\frac{\Gamma,X\vdash A}{\Gamma \vdash \mu X.A} \\\\&\text{(Val Fold)} &&\text{(Val Unfold)} \\&\frac{\Gamma \vdash M:\lbrack \mu X.A/X\rbrack A}{\Gamma \vdash fold_{\mu X.A}M:\mu X.A} && \frac{\Gamma \vdash M:\mu X.A}{\Gamma \vdash unfold_{\mu X.A/X}M:\lbrack \mu X.A/X\rbrack A}\end{aligned}</script><h5 id="List-Type"><a href="#List-Type" class="headerlink" title="List Type"></a>List Type</h5><p>递归类型的标准应用就是用来定义<code>list</code>和<code>tree</code>，甚至<code>product</code>和<code>union</code>类型。</p><script type="math/tex; mode=display">\begin{aligned}&List_A  \qquad \triangleq \qquad \mu X.Unit+(A\times X) \\&nil_A:List_A \triangleq \qquad fold(inLeft\ unit)\\&cons_A:A\to List_A \to List_A \qquad \triangleq \qquad \lambda hd:A.\lambda tl:List_A.fold(inRight\langle hd.tl\rangle)\\&listCase_{A,B}:List_A \to B \to (A\times List_A \to B) \to B \triangleq \\&\lambda l:List_A.\lambda n:B. \lambda c:A \times List_A \to B \\& case(unfold\ l) of \ unit:\ Unit\ then\ n| p:A\times List_A\ then\ c\ p\end{aligned}</script><p><code>Recursive Type</code>可以和<code>Record Type and Variant Type</code>一起定能够以更加复杂的树结构比如<code>abstract syntax trees</code>。而<code>case/with</code>语句就可以被用来解析这些树结构。  </p><p>当和函数类型联合使用的时候，递归类型变的更加强大。<font color="blue">Via clever encodings, one can show that recursion at the value level is already implicit in recursive types: there is no need to introduce recursion as a separate construct.</font> 而且非k类型计算在<code>typed languages</code>中执行了-<font color="blue">More precisely, Table 18 shows how to define, for any type A, a divergent element A of that type, and a fixpoint operator A for that type. </font>   </p><p>最后，<code>Type equivalence</code>在递归类型中显得更加有难度。</p><h3 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h3><h4 id="First-order-Type-Systems-for-Imperative-Languages"><a href="#First-order-Type-Systems-for-Imperative-Languages" class="headerlink" title="First-order Type Systems for Imperative Languages"></a>First-order Type Systems for Imperative Languages</h4><p><font color="orange">Imperative languages have a slightly different style of type systems, mostly because they distinguish commands, which do not produce values, from expressions, which do produce values</font>产生<code>side effect</code>?</p><h4 id="Second-order-Type-Systems"><a href="#Second-order-Type-Systems" class="headerlink" title="Second-order Type Systems"></a>Second-order Type Systems</h4><p><code>Type parameter</code>涵盖泛型，类，接口，模板(C++)等高级主题。</p><h4 id="SubTyping"><a href="#SubTyping" class="headerlink" title="SubTyping"></a>SubTyping</h4><p>针对面向对象。</p><h4 id="Equivalence"><a href="#Equivalence" class="headerlink" title="Equivalence"></a>Equivalence</h4><p>复杂情况下重构类型相等。</p><h4 id="Type-inference"><a href="#Type-inference" class="headerlink" title="Type inference"></a>Type inference</h4><p>统筹类型推导。</p><h4 id="暂时总结"><a href="#暂时总结" class="headerlink" title="暂时总结"></a>暂时总结</h4><p><a href="http://lucacardelli.name/papers/typesystems.pdf" target="_blank" rel="noopener">本片论文</a>对类型系统做了全范围的综述，进一步深入还需要一些基础。TODO:)</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://opendsa-server.cs.vt.edu/OpenDSA/Books/PL/html/FreeBoundVariables.html" target="_blank" rel="noopener">free/bound variables</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Type system&lt;/code&gt;的基本目的是防止在程序运行时发生&lt;code&gt;execution error&lt;/code&gt;。这种&lt;code&gt;Informal statement&lt;/code&gt;非形式化描述有很多内涵：首先该如何严格定义&lt;code&gt;execution error&lt;/code&gt;；其次在这种定义下，描述&lt;code&gt;absence of execution error&lt;/code&gt;也是&lt;code&gt;Type system&lt;/code&gt;很&lt;code&gt;nontrivial&lt;/code&gt;的性质——当&lt;code&gt;PL .aka. programming language&lt;/code&gt;的所有运行时行为都能确保这种性质的话，我们就说该语言是&lt;code&gt;type sound&lt;/code&gt;的。事实证明为了更加没有歧义的描述&lt;code&gt;PL&lt;/code&gt;的&lt;code&gt;type soundness&lt;/code&gt;，需要做大量的分析和证明。因此针对&lt;code&gt;Type system&lt;/code&gt;的分类，描述和研究过程逐渐演变成为一套&lt;code&gt;formal discipline&lt;/code&gt;即形式化体系。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac{\Gamma_{1} \vdash \Im_{1}  ...  \Gamma_{n} \vdash \Im_{n}}{\Gamma \vdash \Im}&lt;/script&gt;&lt;p&gt;&lt;code&gt;The formalization of Type system&lt;/code&gt;需要一套精确的符号和定义系统，一个&lt;strong&gt;严格正确&lt;/strong&gt;的&lt;code&gt;Type system&lt;/code&gt;可以对语言定义的各个重要性质进行&lt;strong&gt;完整&lt;/strong&gt;的判断。而非形式化的描述甚至做不到完整概括语言的&lt;code&gt;type structure&lt;/code&gt;则更谈不上实现上的唯一性。比如不同的编译器对于同一套语言&lt;code&gt;Type system&lt;/code&gt;的实现往往不尽相同，甚至有一些&lt;code&gt;type unsound&lt;/code&gt;的语言定义导致一段代码明明通过&lt;code&gt;typechecker&lt;/code&gt;的检查但在运行时奔溃掉。理想情况下我们说&lt;code&gt;formal Type system&lt;/code&gt;应该是所有&lt;code&gt;typed programming languages&lt;/code&gt;内核定义的一部分。这样的话，&lt;code&gt;typechecking&lt;/code&gt;算法就可以严格按照精确的类型&lt;code&gt;spec&lt;/code&gt;执行，从某种程度上该语言可以看成是&lt;code&gt;Type sound&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
      <category term="𝛌-calculus" scheme="http://haotianmcihael.github.io/categories/%F0%9D%9B%8C-calculus/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="Type System" scheme="http://haotianmcihael.github.io/tags/Type-System/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(5-IFDS-And-Soundiness)</title>
    <link href="http://haotianmcihael.github.io/2021/06/06/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-5-IFDS/"/>
    <id>http://haotianmcihael.github.io/2021/06/06/NJU静态程序分析-5-IFDS/</id>
    <published>2021-06-06T15:54:46.000Z</published>
    <updated>2022-03-16T09:57:13.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abastract"><a href="#Abastract" class="headerlink" title="Abastract"></a>Abastract</h3><p>在<code>IFDS</code>出现之前，经典<code>intra-procedural analysis</code>框架(<font color="red">D</font>,<font color="green">L</font>,<font color="blue">F</font>)对于程序分析问题的研究还停留在①多项式时间处理<code>specific individual problem</code>比如<code>constant propagation/pointer analysis</code>②多项式时间处理<code>locally separable proble</code>（经典<code>bit-vector/gen-kill</code>问题——<code>reaching definitions,available expressions,live variabl</code>的过程间分析）③对普遍分析问题提供<strong>非多项式时间</strong>的算法方案。</p><p>随着<code>POPL&#39;1995</code>发表的<a href="http://web.cs.ucla.edu/~harryxu/courses/253/sp2013/papers/popl95.pdf" target="_blank" rel="noopener">Precise Interprocedural Dataflow Analysis via Graph Reachability</a>通过将一类<code>inter-procedural analysis</code>问题转化为<code>a special kind of graph-reachability problem</code>图可达性问题——<font color="red"><code>IFDS</code></font>框架横空出世。<strong><code>IFDS</code>除了针对<code>separable problems</code>，还针对包括<code>truly-live variables,copy constant propagation,possibly-uninitialized variablestruly-live variables</code>在内的<code>non-separable problems</code>等一大类普遍性分析问题都提供了多项式时间的精确解决手段。</strong>由于<code>IFDS</code>本身的约束，作者在<code>Theoretical Computer Science&#39;1996</code>上还发表过一篇<a href="https://pdf.sciencedirectassets.com/271538/1-s2.0-S0304397500X00448/1-s2.0-0304397596000722/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJIMEYCIQDHEEjOJdEm0cLtUB%2BHaJKZnI%2BPN5tMP4ElOR%2FgbYtzIgIhAJLujFNrXghpU6i4dLJlbR4WmRz%2FBokVzMrouNR8thheKvoDCEMQBBoMMDU5MDAzNTQ2ODY1IgwWTLJMo41Prpn%2F%2FEgq1wPGTtVLFsiVIF9uO3Jqe%2Fc7DNIZ2aCoMKASRnKPldZG3DL%2Fkla1b4JCb1utfraGJZeeG8LZFHTKpNPPAfY8Ax4cYe2D2fM1efeJUEv%2FGD2v21Ge7INGhUegLgtSJXoz%2FTGqXHronY0wS56U4dQHPyuDJ9pJYu8tQi5bCN93m1E%2BvoIrIoPK1IBlinh9LCUHfggCjlfJcrUWdkz6FvAO9pGlBB2bSWVrDJQZhf6k8%2FEA5%2BXg3GaNvYrHvzSnNokhfIAooqmnr9POzK6%2B3%2Fx0h%2Bs4dh9hNMSBVThSuNZlmYyRaRKHAukdzlgx7Lu9cQrKYEbMA9sr6UbY1CBGWM0IkEQ7hmxoPj3%2BkLlagNcZRd2FVg7zQcCPjdYrEeuUM6FicieZyU64gwrF%2Fl2Jq9GQPaZpYcndiEruIB8ggW%2F6moNCZs2IDLW40fNnp3Hm32GGMPuJDgPa9Yg7iD9Rfrr7uPhjSB8oKcpFqUKwmYqMn4W6pM74elsDHPsbw%2FsaqXNJCU42md6tfWSTBmByS3IQHgs6NpJWs3QckjVDmQYfTXv%2FgpMfrR%2FVnq7q6gGUgGrsgttCWa9VagHvZlUoLrIsFwlkjVjx7LNyflLfYyQBjsMjVKKQ7qw9kLMwrfi2kQY6pAGC4F0%2Bu4eJObfe5rQlGYJgI2OFVr6PyiBiTn4XcTtHOC2fbkj4Rre9Pj4QydLxF0oSXJqJCXkBJhzxpC9ouKJpDzYffbmPkpIA6rzdujGyRGluGCeiM2cOu7JtFEx1nvPsB%2BLlMN8JJBJQL3QWxnV36yu6ycImjADRWzn2Oe1Hn59BdoZO9nzL8zTLFHgS9jRZeYlTJQnh6FZe4I4upbqHwxemIw%3D%3D&amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Date=20220313T104326Z&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Expires=300&amp;X-Amz-Credential=ASIAQ3PHCVTY3WOOQG6M%2F20220313%2Fus-east-1%2Fs3%2Faws4_request&amp;X-Amz-Signature=d189220faa10689b60977d689048eeee379847ff107227365fec1a7742463d7d&amp;hash=c12a21daeaec6fe0aaf5b9fb5ec0259bf755743c2eea8ab65f566cece9ee2d36&amp;host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&amp;pii=0304397596000722&amp;tid=spdf-17632b09-bb7d-4bc0-9605-080c373f0575&amp;sid=d0b19308547fc443ae8b53f5ca290b286a01gxrqa&amp;type=client&amp;ua=50040252510d525a5a05&amp;rr=6eb42b298d006da7" target="_blank" rel="noopener">Precise interprocedural dataflow analysis with applications to constant propagation</a>提出<code>IDE</code>框架来处理<code>interprocedural constant propagation</code>等<code>IFDS</code>框架处理不了的<code>non-distributive</code>问题。这两篇论文为程序分析领域引入新的血液。</p><p>近年<code>Sparse Value IFDS,Disk-Assisted IFDS</code>等课题一直是学术界的研究热点。在工业界比如<a href="https://linkspringer.53yu.com/content/pdf/10.1007%2F978-3-030-17465-1.pdf" target="_blank" rel="noopener">phasar</a>等程序分析工具中<code>IFDS/IDE</code>也有具体<a href="https://github.com/secure-software-engineering/phasar" target="_blank" rel="noopener">实现</a>。</p><a id="more"></a><h3 id="CFL-Reachability"><a href="#CFL-Reachability" class="headerlink" title="CFL-Reachability"></a>CFL-Reachability</h3><p>首先介绍图可达性的概念。</p><h4 id="Feasible-and-Realizable-Paths"><a href="#Feasible-and-Realizable-Paths" class="headerlink" title="Feasible and Realizable Paths"></a>Feasible and Realizable Paths</h4><p>过程间数据流分析真正用于工程落地之后的复杂度往往是很高的，即<code>ICFG</code>的边出现路劲爆炸导致分析速度变慢。究其根本原因，是因为在这些<code>edges</code>中有一些属于不可达边——<code>Infeasible paths</code>。</p><p>Paths in CFG that do not correspond to actual executions is Infeasible paths.</p><p>如果我们能够尽可能的防止<code>CFG</code>被<code>Infeasible paths</code>所污染，让分析流图边的更加简洁，势必大大提升分析速度。<strong>但是实际情况下这种<code>infeasible paths</code>往往无法判定。</strong>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo(int age) &#123;    //age只会是Positive，所以一条分支肯定不会被执行</span><br><span class="line">if(age &gt;= 0) </span><br><span class="line">r = age;</span><br><span class="line">else </span><br><span class="line">r = -1;  //但是程序在静态时该条路径无法判定其可执行性</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Realizable-Paths"><a href="#Realizable-Paths" class="headerlink" title="Realizable Paths"></a>Realizable Paths</h5><p>The paths in which “returns” are matched with corresponding “calls”.</p><p>如果一条调用边，其return-edge可以正确匹配到其call-edge，则称这条边是<code>realizable</code>的。<strong>既然<code>infeasible</code>不可判定，便引入其子集——因为<code>realizable paths</code>可能不会被执行到，但是<code>unrealizable paths</code>则一定不会被执行到，而<code>unrealizable paths</code>则是可判定的。</strong></p><p><img src="1.png" width="50%" height="50%" alt=""></p><p><strong>寻找这样的<code>realizable paths</code>来是<code>IFDS</code>顺利执行的前提，</strong>下面引入一种系统的方式识别<code>realizable paths</code>——<code>CFL-Reachability</code>。</p><h4 id="CFL-Reachabiligy"><a href="#CFL-Reachabiligy" class="headerlink" title="CFL-Reachabiligy"></a>CFL-Reachabiligy</h4><p>A path is considered to connect two nodes  A and B, or<font color="red"> B is reachable from A</font>. Only if the concatenation of the labels on the edges of the path is a word in a specified <font color="red">context-free language</font>.</p><p>对于A和B两个<code>node</code>之间有一条<code>path</code>（一系列<code>edge</code>组成的，换句话说B可达A）并且这条<code>path</code>上的所有<code>edge</code>的<code>labels</code>构成的单词是<strong>由事先规定的context-free language定义好的合法单词的话，</strong>就说<font color="red">B is CFL-Reachable from A.</font></p><h5 id="context-free-grammer"><a href="#context-free-grammer" class="headerlink" title="context-free grammer"></a>context-free grammer</h5><p>上下文无关语言<code>context-free language</code>指的是由上下文无关文法<code>context-free grammer</code>产生的语言。</p><p>上下文无关文法是一种形式语言用于描述某种语法，它的主要形式就是：S ⟶ 𝞪. 这是一种产生式。S代表非终结符而𝞪代表一系列终结符或者空格。比如CFG的文法如下的话：</p><ul><li>S ⟶ aSb</li><li>S ⟶ ℇ</li></ul><p>这里的𝞪就是<code>aSb/ℇ</code>，上下文无关<code>context-free</code>的意思就是说在<strong>任何出现S的地方</strong>都可以使用<code>aSb/ℇ</code>来替换。</p><h5 id="Partially-Balanced-Parenthesis-Problem"><a href="#Partially-Balanced-Parenthesis-Problem" class="headerlink" title="Partially Balanced-Parenthesis Problem"></a>Partially Balanced-Parenthesis Problem</h5><p>将寻找<code>realizable paths</code>抽象成为典型的括号匹配问题。这里的<code>Partially</code>指的是)<sub>i</sub>一定会有一个(<sub>i</sub>匹配，换句话讲就是说对于每一个<code>return-edge</code>都有会有一个<code>call-edge</code>匹配，但是每一个<code>call-edge</code>却不一定有返回值（比如<code>realizable but not infeasiable paths</code>）。<strong>问题的整个建模过程为：对<code>control-flow graph</code>上的所有<code>edge</code>都加上一个<code>label</code>，对于一个<code>call</code>语句<code>i</code>，其<code>call-edge</code>被标记为(<sub>i</sub>其<code>return-edge</code>被标记为)<sub>i</sub>，而其余所有的<code>edge</code>都被标记为<code>e</code>。</strong></p><p>A path is a realizable path if thee path’ word is in the language L(realizable).比如</p><ul><li><font color="green">(<sub>1</sub>(<sub>2 </sub>e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub></font></li><li><font color="green">(<sub>1</sub>(<sub>2 </sub>e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub>(<sub>4</sub></font></li><li><font color="green">(<sub>1</sub>(<sub>2 </sub>e e e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub>(<sub>4</sub></font></li><li><font color="blue">e e</font><font color="green">(<sub>1</sub>(<sub>2 </sub>e e e )<sub>2</sub>)<sub>1</sub></font><font color="red">(<sub>3 </sub>(<sub>4</sub></font> <font color="blue">e</font></li></ul><p>则根据括号匹配设计的上下文无关文法如下：</p><font color="blue">realizable</font>   ⟶ <font color="green">mathched</font>  <font color="blue">realizable</font><p>​                    ⟶  <font color="red">(<sub>i</sub></font>     <font color="blue">realizable</font></p><p>​                    ⟶   <font color="blue">ℇ</font></p><font color="green">mathched</font>  ⟶ <font color="red">(<sub>i</sub></font>   <font color="green">mathched</font>  <font color="red">)<sub>i</sub></font><p>​                    ⟶ <font color="blue">e</font></p><p>​                    ⟶ <font color="blue">ℇ</font></p><p>​                    ⟶ <font color="green">mathched matched</font> </p><p><img src="2.png" width="50%" height="50%" alt=""></p><h3 id="IFDS"><a href="#IFDS" class="headerlink" title="IFDS"></a>IFDS</h3><p><code>IFDS</code>是<code>Interprocedural，Finite，Distributive，Subset Problems</code>的简称。总结来就说：IFDS is for interprocedural data flow analysis with <font color="red">distributive</font> flow functions over <font color="red">finite</font> domains.  </p><p><code>IFDS</code>将一大类数据流分析问题转化成为了图可达性问题进行处理，相比较于迭代数据流框架提供了多项式时间的精确处理。但是<code>IFDS</code>必须在一定的约束下才可以：  </p><p>很多普遍的数据流分析问题都是<code>subset problem</code>——集合的<code>union/intersection</code>等；而<code>Interprocedural</code>指的是全程序分析；<strong>而该分析问题还有必须有一个<code>distributive flow function</code>并且其<code>domains</code>还是<code>finite</code>才可以用<code>IFDS</code>来处理。</strong>  </p><p>就比如<code>constant propagation</code>就不可以用<code>IFDS</code>处理，因为其<code>domains</code>是理论上所有的常数所以是<code>Infinite</code>，而且该分析本身也不是<code>Distributive</code>。</p><h4 id="Overview-of-IFDS"><a href="#Overview-of-IFDS" class="headerlink" title="Overview of IFDS"></a>Overview of IFDS</h4><h5 id="MRP"><a href="#MRP" class="headerlink" title="MRP"></a>MRP</h5><p>跟<code>Intra-procedural analysis</code>使用<code>meet-over-all-paths</code>来衡量分析的精度一样，<code>IFDS</code>也使用<code>meet-over-all-realizable-paths</code>来衡量其分析精度。  </p><p>根据MOP<sub>n</sub> = ⊔<font color="green">(p∊Paths(start, n))</font>pf<sub>p</sub>(⊥)的定义，对于每一个<code>node</code>点n，MOP<sub>n</sub>表示在<code>CFG</code>上的<code>start</code>点到<code>node</code>点n所有的<code>paths</code>的<code>union/intersection</code>操作。</p><p>而根据MRP<sub>n</sub> = ⊔<font color="green">(p∊RPaths(start, n))</font>pf<sub>p</sub>(⊥)的定义，对于每一个<code>node</code>点n，MRP<sub>n</sub>表示在<code>CFG</code>上的<code>start</code>点到<code>node</code>点n所有的<font color="red">realizable paths（这些paths的label构成的word符合<code>realizalble</code>语言的上下文无关文法）</font>的<code>union/intersection</code>操作。</p><p>根据两个精度计算方式的定义可以看出，MRP<sub>n</sub>对那些<code>unrealizable paths</code>进行了剪枝优化，因此其结果也比MOP<sub>n</sub>更精确——MRP<sub>n</sub> ≼ MOP<sub>n</sub>。</p><h5 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h5><p>首先从总体上概括一下<code>IFDS</code>的算法框架：</p><p>输入：程序<code>P</code>，数据流分析问题<code>Q</code></p><ul><li>为程序<code>P</code>建立<code>superGraph G*</code>，并根据分析问题<code>Q</code>为<code>G*</code>的每一个<code>edge</code>定义<code>flow functions（使用𝛌表达式）</code>(可以对比<code>intra-procedural analysis</code>为每一个<code>node</code>建立<code>flow functinos</code>)</li><li>通过将<code>flow functions</code>转化为<code>representation relations</code>（一种子图）的形式来建立程序<code>P</code>的<code>exploded supergraph G#</code></li><li>最后在<code>G#</code>上应用<code>tabulations algorithm</code>就可以将程序<code>Q</code>的分析问题当做图可达性问题从而求解（找到<code>MRP solutions</code>）</li></ul><font color="purple">Let n be a program point, data fact d ∊ MRP<sub>n</sub>, iff there is a realizable path in G# from <s<sub>main, 0> to <n, d="">.</n,></s<sub></font><p><img src="3.png" width="50%" height="50%" alt=""></p><h4 id="SuperGraph-and-Flow-Functions"><a href="#SuperGraph-and-Flow-Functions" class="headerlink" title="SuperGraph and Flow Functions"></a>SuperGraph and Flow Functions</h4><h5 id="SuperGraph"><a href="#SuperGraph" class="headerlink" title="SuperGraph"></a>SuperGraph</h5><p>引入<code>supergraph G* = (N*, E*)</code>， 对于过程间数据流分析，每一个<code>procedure</code>都是一个控制流图<code>G</code>，每一个<code>G</code>都有一个自己的<code>start node</code><font color="blue">s<sub>p </sub>&lt;/font &gt;和<code>exit node</code><font color="blue">e<sub>p</sub></font>。<code>IFDS</code>框架处理的全程序的<code>superGraph G*</code>就是这些控制流图的集合{G<sub>1</sub>, G<sub>2</sub>….}。</font></p><p>过程间分析最重要的<code>procedure call</code>则需要一个<code>node</code>点<font color="red">Call<sub>p</sub></font>和一个<code>node</code>点 <font color="red">Ret<sub>p</sub></font>。<code>G*</code>对于每一个<code>procedure call</code>都需要三条边：</p><ul><li><code>intra-procedural call-to-return-site edge</code>：<font color="red">Call<sub>p </sub></font> ⟶ <font color="red">Ret<sub>p</sub></font></li><li><code>inter-procedural call-to-start edge</code>:  <font color="red">Call<sub>p </sub></font> ⟶ <font color="blue">s<sub>p </sub>&lt;/font &gt;</font></li><li><code>inter-procedural exit-to-return-site edge</code>:  <font color="blue">e<sub>p</sub></font> ⟶ <font color="red">Ret<sub>p</sub></font></li></ul><h5 id="Flow-Functions"><a href="#Flow-Functions" class="headerlink" title="Flow Functions"></a>Flow Functions</h5><p>设计<code>flow function</code>是根据具体的程序分析问题，使用<code>𝛌-expression</code>表示的。</p><h4 id="Exploded-Supergraph-and-Tabulation-Algorithm"><a href="#Exploded-Supergraph-and-Tabulation-Algorithm" class="headerlink" title="Exploded Supergraph and Tabulation Algorithm"></a>Exploded Supergraph and Tabulation Algorithm</h4><h5 id="Exploded-SuperGraph"><a href="#Exploded-SuperGraph" class="headerlink" title="Exploded SuperGraph"></a>Exploded SuperGraph</h5><p>通过将<code>flow function</code>转换成为<code>representation relations</code>子图来建造<code>exploded superGraph G#</code>。</p><p>每一个<code>flow function</code>被一个<code>2(D + 1)</code>个<code>node</code>组成的<code>Graph</code>代表，<font color="blue">其中<code>D</code>表示的是一个<code>dataflow facts</code>的<strong>有限集合</strong>。</font></p><p><img src="4.png" width="50%" height="50%" alt=""></p><p>这里的<code>representation relation</code>R<sub>f</sub> ⊆ (D ⋃ 0) X (D ⋃ 0)，符合如下规则：</p><ul><li>{0, 0}  <code>Edge</code>: <font color="red">0 ⟶ 0</font></li><li>{(0, y)|y∊f(∅)}  <code>Edge:</code> <font color="red">0 ⟶ d<sub>1</sub></font></li><li>{(x, y)| y∉f(∅) and y∊f({x})}  <code>Edge</code>: <font color="red">d<sub>1</sub> ⟶ d<sub>2</sub></font></li></ul><p>其中<code>0</code>和<code>0</code>之间自动连一条边；如果在没有输入的情况下输出为<code>y</code>则自动连一条<code>0</code>到d<sub>1</sub>的边；如果输入为<code>x</code>而输出是<code>f</code>并且输入为∅的时候的输出不为<code>y</code>，则需要在两个<code>dataflow facts</code>之间连一条边。</p><p>在将<code>superGraph G*</code>转化为<code>exploded superGraph G#</code>的过程中：和传统数据流分析不一样的是——其中的<code>edge</code>代表了一个<code>flow functino</code>。所以在转化时候<code>G*</code>的每一个<code>node</code>都被转化成为<code>D+1</code>个<code>nodes</code>，而一条<code>edge</code>分别连接的两个<code>D+1</code>个<code>nodes</code>（故一个<code>flow function</code>被转化为<code>2(D+1)个node</code>组成的子图）共同被转化成为<code>representation relation</code>子图。</p><h5 id="Edge-0⟶0"><a href="#Edge-0⟶0" class="headerlink" title="Edge 0⟶0"></a>Edge 0⟶0</h5><p>对于一个特定的数据流分析问题，它有<code>D</code>个<code>data facts</code>。但是在构造<code>exploded superGraph</code>的时候为什么一个<code>node</code>需要转换成为<code>D + 1</code>个<code>nodes</code>呢？</p><p>回顾一下传统的数据流分析，如果想要确定一个<code>program point</code>是否还保持一个<code>data fact</code>比如<code>definition</code>是否是<code>reachable</code>的，我们需要判断从程序入口到该<code>program point</code>的流动中该<code>data fact</code>是否会传播到该点。</p><p><img src="5.png" width="50%" height="50%" alt=""></p><p>即OUT[p] = f4○f3○f2○f1(IN[n1])。准确的说<strong>Data facts are propagated via the composition of flow functions.</strong>——这里最重要的是一个<strong>composition</strong>的概念，实际上对于<code>IFDS</code>框架来说，如何在如图可达性问题中实现这种连接，否则会导致整个分析的结果无法沿着<code>edge</code>进行传播，而<code>Glue Edge:0⟶0</code>便解决了这个问题。</p><h5 id="Tabulation-Algorithm"><a href="#Tabulation-Algorithm" class="headerlink" title="Tabulation Algorithm"></a>Tabulation Algorithm</h5><p>最后一步在构建好<code>G#</code>之后，最终在其上应用<code>Tabulation</code>算法来寻找从<s<sub>main&lt;/sub&gt;, 0&gt;开始的所有<code>realizable paths</code>来决定该分析问题的所有<code>MRP solutions</code>。</s<sub></p><p>理解一下整个算法的核心：</p><font color="purple">Let n be a program point, data fact d ∊ MRP<sub>n</sub>, iff there is a realizable path in G# from <s<sub>main, 0> to <n, d="">.</n,></s<sub></font><p>首先解释<s,d>指的是在<code>program point</code>点S的一个<code>data fact</code>即<code>d</code>。如果对于一个<code>program point</code>点<code>n</code>，如果在<code>G#</code>上可以从<s<sub>main&lt;/sub&gt;, 0&gt;到&lt;<font color="red">n</font>,<font color="blue">d</font>&gt;有一条<code>realizable path</code>——则就说<code>data fact d</code>在<code>program point n</code>这一点是holds的。</s<sub></s,d></p><p>关于该算法的核心暂时不深入理解。比如这里的<code>summary</code>思想也是为了处理同一个方法被冗余处理。</p><h4 id="Distributivity"><a href="#Distributivity" class="headerlink" title="Distributivity"></a>Distributivity</h4><p>这里我们了解一下<code>IFDS</code>的可分配性<code>Distributivity</code>：  </p><ul><li>F(X ^ Y) = F(X) ^ F(Y)</li></ul><p>而根据定义，对于处理<code>constant propagation</code>来说比如<code>z = x + y</code>，需要同时考虑两个输入，<strong>而<code>IFDS</code>一次只能处理一个输入:F(x)^F(y)。本质上每一个<code>representation relation</code>只能处理如果<code>x</code>存在则…，但是无法处理如果<code>x and y</code>同时存在则…。</strong>故常量传播是不可分配的。</p><p>In IFDS, each data fact(circle) and its propagation(edges) could be handled independently, and doing so will affect the correctness of the final results.</p><p>就是说其<code>data fact</code>和<code>edge</code>都是可以分开处理，到最后一步才进行<code>union/intersection</code>——即可分配性。而<code>Pointer analysis</code>因为需要处理别名<code>alias</code>信息，这样的话需要考虑多个输入信息——故其本质上也不是可分配性的。</p><h3 id="Soundiness"><a href="#Soundiness" class="headerlink" title="Soundiness"></a>Soundiness</h3><p>虽然所有的程序分析算法都在强调其可以捕捉到所有的程序运行时行为。但是学术界和工业界的理论和工具在实际应用中都会产生<code>unsound</code>的结果。<strong>这是因为编程语言本身会有一些<code>Hard Feature</code>导致程序分析无法进行。</strong></p><ul><li>Java: Reflection，native code，dynamic class loading …</li><li>C/C++:  Pointer arithmetic, function pointer…</li></ul><p>这些特性使得程序分析精度受损。故学术界引入一个新词<code>Soundiness</code>表示：</p><p>A soundy analysis typically means that the analysis is mostly sound, with well-identified unsound treatments to hard/specific language features.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abastract&quot;&gt;&lt;a href=&quot;#Abastract&quot; class=&quot;headerlink&quot; title=&quot;Abastract&quot;&gt;&lt;/a&gt;Abastract&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;IFDS&lt;/code&gt;出现之前，经典&lt;code&gt;intra-procedural analysis&lt;/code&gt;框架(&lt;font color=&quot;red&quot;&gt;D&lt;/font&gt;,&lt;font color=&quot;green&quot;&gt;L&lt;/font&gt;,&lt;font color=&quot;blue&quot;&gt;F&lt;/font&gt;)对于程序分析问题的研究还停留在①多项式时间处理&lt;code&gt;specific individual problem&lt;/code&gt;比如&lt;code&gt;constant propagation/pointer analysis&lt;/code&gt;②多项式时间处理&lt;code&gt;locally separable proble&lt;/code&gt;（经典&lt;code&gt;bit-vector/gen-kill&lt;/code&gt;问题——&lt;code&gt;reaching definitions,available expressions,live variabl&lt;/code&gt;的过程间分析）③对普遍分析问题提供&lt;strong&gt;非多项式时间&lt;/strong&gt;的算法方案。&lt;/p&gt;
&lt;p&gt;随着&lt;code&gt;POPL&amp;#39;1995&lt;/code&gt;发表的&lt;a href=&quot;http://web.cs.ucla.edu/~harryxu/courses/253/sp2013/papers/popl95.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Precise Interprocedural Dataflow Analysis via Graph Reachability&lt;/a&gt;通过将一类&lt;code&gt;inter-procedural analysis&lt;/code&gt;问题转化为&lt;code&gt;a special kind of graph-reachability problem&lt;/code&gt;图可达性问题——&lt;font color=&quot;red&quot;&gt;&lt;code&gt;IFDS&lt;/code&gt;&lt;/font&gt;框架横空出世。&lt;strong&gt;&lt;code&gt;IFDS&lt;/code&gt;除了针对&lt;code&gt;separable problems&lt;/code&gt;，还针对包括&lt;code&gt;truly-live variables,copy constant propagation,possibly-uninitialized variablestruly-live variables&lt;/code&gt;在内的&lt;code&gt;non-separable problems&lt;/code&gt;等一大类普遍性分析问题都提供了多项式时间的精确解决手段。&lt;/strong&gt;由于&lt;code&gt;IFDS&lt;/code&gt;本身的约束，作者在&lt;code&gt;Theoretical Computer Science&amp;#39;1996&lt;/code&gt;上还发表过一篇&lt;a href=&quot;https://pdf.sciencedirectassets.com/271538/1-s2.0-S0304397500X00448/1-s2.0-0304397596000722/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJIMEYCIQDHEEjOJdEm0cLtUB%2BHaJKZnI%2BPN5tMP4ElOR%2FgbYtzIgIhAJLujFNrXghpU6i4dLJlbR4WmRz%2FBokVzMrouNR8thheKvoDCEMQBBoMMDU5MDAzNTQ2ODY1IgwWTLJMo41Prpn%2F%2FEgq1wPGTtVLFsiVIF9uO3Jqe%2Fc7DNIZ2aCoMKASRnKPldZG3DL%2Fkla1b4JCb1utfraGJZeeG8LZFHTKpNPPAfY8Ax4cYe2D2fM1efeJUEv%2FGD2v21Ge7INGhUegLgtSJXoz%2FTGqXHronY0wS56U4dQHPyuDJ9pJYu8tQi5bCN93m1E%2BvoIrIoPK1IBlinh9LCUHfggCjlfJcrUWdkz6FvAO9pGlBB2bSWVrDJQZhf6k8%2FEA5%2BXg3GaNvYrHvzSnNokhfIAooqmnr9POzK6%2B3%2Fx0h%2Bs4dh9hNMSBVThSuNZlmYyRaRKHAukdzlgx7Lu9cQrKYEbMA9sr6UbY1CBGWM0IkEQ7hmxoPj3%2BkLlagNcZRd2FVg7zQcCPjdYrEeuUM6FicieZyU64gwrF%2Fl2Jq9GQPaZpYcndiEruIB8ggW%2F6moNCZs2IDLW40fNnp3Hm32GGMPuJDgPa9Yg7iD9Rfrr7uPhjSB8oKcpFqUKwmYqMn4W6pM74elsDHPsbw%2FsaqXNJCU42md6tfWSTBmByS3IQHgs6NpJWs3QckjVDmQYfTXv%2FgpMfrR%2FVnq7q6gGUgGrsgttCWa9VagHvZlUoLrIsFwlkjVjx7LNyflLfYyQBjsMjVKKQ7qw9kLMwrfi2kQY6pAGC4F0%2Bu4eJObfe5rQlGYJgI2OFVr6PyiBiTn4XcTtHOC2fbkj4Rre9Pj4QydLxF0oSXJqJCXkBJhzxpC9ouKJpDzYffbmPkpIA6rzdujGyRGluGCeiM2cOu7JtFEx1nvPsB%2BLlMN8JJBJQL3QWxnV36yu6ycImjADRWzn2Oe1Hn59BdoZO9nzL8zTLFHgS9jRZeYlTJQnh6FZe4I4upbqHwxemIw%3D%3D&amp;amp;X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Date=20220313T104326Z&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Expires=300&amp;amp;X-Amz-Credential=ASIAQ3PHCVTY3WOOQG6M%2F20220313%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Signature=d189220faa10689b60977d689048eeee379847ff107227365fec1a7742463d7d&amp;amp;hash=c12a21daeaec6fe0aaf5b9fb5ec0259bf755743c2eea8ab65f566cece9ee2d36&amp;amp;host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&amp;amp;pii=0304397596000722&amp;amp;tid=spdf-17632b09-bb7d-4bc0-9605-080c373f0575&amp;amp;sid=d0b19308547fc443ae8b53f5ca290b286a01gxrqa&amp;amp;type=client&amp;amp;ua=50040252510d525a5a05&amp;amp;rr=6eb42b298d006da7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Precise interprocedural dataflow analysis with applications to constant propagation&lt;/a&gt;提出&lt;code&gt;IDE&lt;/code&gt;框架来处理&lt;code&gt;interprocedural constant propagation&lt;/code&gt;等&lt;code&gt;IFDS&lt;/code&gt;框架处理不了的&lt;code&gt;non-distributive&lt;/code&gt;问题。这两篇论文为程序分析领域引入新的血液。&lt;/p&gt;
&lt;p&gt;近年&lt;code&gt;Sparse Value IFDS,Disk-Assisted IFDS&lt;/code&gt;等课题一直是学术界的研究热点。在工业界比如&lt;a href=&quot;https://linkspringer.53yu.com/content/pdf/10.1007%2F978-3-030-17465-1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;phasar&lt;/a&gt;等程序分析工具中&lt;code&gt;IFDS/IDE&lt;/code&gt;也有具体&lt;a href=&quot;https://github.com/secure-software-engineering/phasar&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;实现&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(4-Taint-Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/06/03/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-4-Taint-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/06/03/NJU静态程序分析-4-Taint-Analysis/</id>
    <published>2021-06-02T16:33:35.000Z</published>
    <updated>2022-03-16T09:59:27.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>同符号执行一样，<code>Taint-Analysis</code>也是分析代码安全漏洞，检测攻击方式的重要手段。对于<code>Web</code>应用程序中存在着的大量安全漏洞,如跨站脚本攻击，<code>SQL</code>注入等~污点分析都可以进行有效地检测。而污点传播技术是当前<code>Taint-Analysis</code>领域的重要课题，<strong>通过和静态程序分析技术相结合，在不运行代码且不修改代码的前提下通过分析程序变量之间的相互依赖关系以此获得更高效，更精确的分析结果。</strong>  </p><p>Taint analysis tracks how tainted data flow through the program and observes if they can flow to locations of interest(call sinks).  </p><p>比如通过利用静态指针分析算法完成简化的显式流<code>explicit flow</code>分析，不讨论<a href="https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/" target="_blank" rel="noopener">路径爆炸</a>和其他动态漏洞分析技术。</p><a id="more"></a><h3 id="Information-Flow-Security"><a href="#Information-Flow-Security" class="headerlink" title="Information Flow Security"></a>Information Flow Security</h3><p>当服务器和客户机在网络上进行通信的时候就会存在<code>Information Flow</code>，从而产生了相应的安全问题——Prevent unwanted information flow。如何防止客户端的信息不被流入到黑客手中，目前主流有两种途径：</p><h4 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h4><p>通过使用<strong>权限</strong>的方式来控制程序是否可以访问敏感数据，主要是通过管理<strong>如何获取数据</strong>的方式来完成数据保护，但是它仅仅可以保证获取时的保护，但是获取到数据之后呢？</p><h4 id="Information-Flow-Security-1"><a href="#Information-Flow-Security-1" class="headerlink" title="Information Flow Security"></a>Information Flow Security</h4><p><font color="red">信息流安全</font>是一种<code>end to end</code>的数据保护方式，它追踪信息流是如何在程序中流动的来确保程序能更安全的处理敏感数据，主要是通过管<strong>如何传播数据</strong>的方式来完成数据保护。</p><p>这两种方式共同作用，才可以真正保证敏感数据的安全。</p><p>下面介绍信息流的概念:如果在变量<code>x</code>中的信息被传入到了变量<code>y</code>中，那么在<code>x——&gt;y</code>之间就有信息流。而实现信息流安全实际上还需要两种方式：</p><h5 id="security-levels"><a href="#security-levels" class="headerlink" title="security levels"></a>security levels</h5><p>通过将信息流分为不同的等级来控制数据的获取权限，最基本的模型就是<code>two-level policy</code>，分为<code>H</code>和<code>L</code>两个级别，<code>H</code>指的是安全等级高的敏感信息，<code>L</code>指的是敏感信息低的可公开信息。比如</p><ul><li><code>h = getPassword();</code>    h为<code>H</code></li><li><code>Broadcast(l);</code>      l为<code>L</code></li></ul><p>对于更复杂的数据模型，安全等级实际上可以按照<code>lattice</code>来进行建模。</p><h5 id="information-flow-policy"><a href="#information-flow-policy" class="headerlink" title="information flow policy"></a>information flow policy</h5><p>在不同等级的信息流之间采取不一样的安全策略。比如<strong>Noninterference policy</strong>规定高级别的信息流数据不可以影响(should not interfere with)低级别的信息流。<strong>换句话讲，机器的操作不能使得信息流从高级别的数据传播到低级别的数据中。</strong></p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>这种安全策略需要使得信息流只能沿着<code>lattice</code>的<code>upwards</code>方向进行传播。可以是<code>H——&gt;H、L——&gt;L、L——&gt;H</code>但是不可以是<code>H——&gt;L</code>。</p><h3 id="Confidentiality-and-Integrity"><a href="#Confidentiality-and-Integrity" class="headerlink" title="Confidentiality and Integrity"></a>Confidentiality and Integrity</h3><p><strong>保密性</strong>和<strong>完整性</strong>从另一个视角解读了安全策略<code>information flow policy</code>如何从本质上保证信息流安全。</p><p>对于已经分级好的信息，高级别的信息不可以流到低级别的信息中可以看成是为了保密性，防止数据泄露。而低级别的信息也不能流到高级别的信息中可以看成是为了保护数据的完整性。保密性已经介绍过了，这里介绍一下完整性。</p><h4 id="Integrity"><a href="#Integrity" class="headerlink" title="Integrity"></a>Integrity</h4><p>完整性需要保证一些无关紧要的信息流无法污染，破坏重要的敏感信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = readInput();  //untrusted</span><br><span class="line">cmd = &quot;...&quot; + x;</span><br><span class="line">execute(cmd);    //critical (trusted)</span><br></pre></td></tr></table></figure><p>比如一些常见的注入错误基本上都是因为破坏了数据的完整性才导致安全问题：</p><ul><li>Command injection</li><li>SQL injection</li><li>XSS attacks</li></ul><p><strong>对于已经分好级别的数据来说，保证安全就是需要在从高级别数据向低级别的信息流中防止泄露的同时，还需要在从低级别数据向高级别数据的信息流中防止污染。确保做到根据不同的信息流向应用不同的信息流安全策略。</strong></p><p>从更加广泛的角度来看的话，信息里安全需要保证的是信息的正确性，完整性以及数据的一致性：</p><ul><li>正确性：高级别的数据防止被污染</li><li>完整性：数据得到正确存储</li><li>一致性：保证在读写上数据能保持一致</li></ul><h3 id="Explicit-Flows-and-Convert-Channels"><a href="#Explicit-Flows-and-Convert-Channels" class="headerlink" title="Explicit Flows and Convert Channels"></a>Explicit Flows and Convert Channels</h3><p>这里引入两个安全领域常见的概念，显式<code>explicit</code>和隐式<code>implicit</code>。</p><p>对于一些基本的信息流传播都是显式的比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xh = Yh;</span><br><span class="line">Xl = Yh;</span><br><span class="line">Xl = Yl + Zh</span><br></pre></td></tr></table></figure><p>可以看到数据都是直接通过赋值或者引用这些显式的修改语句直接进行传播的，成为显示流。而对于下面这些情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">secret = getSecret();</span><br><span class="line">if(secret &lt; 0)&#123;</span><br><span class="line">public = 1;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">public = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况属于隐式流——即数据的传播都是通过一些被敏感数据控制的<code>if/while</code>语句来完成的。在上面的例子中，public是低级别数据可以直接被观测到，而secret是高级别的敏感数据，但是我们通过观测到public的值是否为1还是0就可以判断出高级别数据的最终值，这就是隐式流传播。</p><p><strong>隐式流的数据是通过程序的控制流信息进行传播的。</strong>也是安全领域最难以处理的一类安全问题。</p><h3 id="Taint-Analysis"><a href="#Taint-Analysis" class="headerlink" title="Taint Analysis"></a>Taint Analysis</h3><p>污点分析是信息流安全领域最常见的检测手段。污点分析将数据分为两种：</p><ul><li><code>tainted data</code>: 整个分析需要关注到的污点数据</li><li><code>other data</code>: 其他数据</li></ul><p>污点数据的来源被成为<code>sources</code>，从实现角度污点数据通常来自于函数的返回值，即在指针分析需要处理的<code>Call</code>语句。</p><p>Taint analysis tracks how tainted data flow through the program and observes if they can flow to locations of interest(called sinks).  </p><p>污点分析就是通过追踪从<code>sources</code>发出的污点数据是如何在数据流上传播的，并观察这些污点数据是否会流到敏感源中(sinks)。不难看出，<strong>污点分析既可以检测高级别的数据是否被泄露——保密性，也可以检测低级别数据是否造成污染——完整性。</strong></p><p>而究其本质，污点分析就是在问：污点数据是否可以流到敏感源中——而这和指针分析的目的不谋而合，<strong>即污点分析/指针分析的目的都是为了追踪污点数据/抽象对象是如何在程序中传播的</strong>：</p><ul><li>Can tainted data flow to a sink?</li><li>Which tainted data a pointer (at a sink)can point to?</li></ul><h4 id="Domains-and-Notations"><a href="#Domains-and-Notations" class="headerlink" title="Domains and Notations"></a>Domains and Notations</h4><p>如何使用指针分析来对污点分析进行建模，只需完成<code>tainted data</code>⟶<code>object</code>,<code>sources</code>⟶ <code>allocation sites</code>这两个映射。</p><ul><li><font color="red">Variables</font>:   x, y ∊ V   </li><li>Fields: f, g ∊ F</li><li>Objects:  o<sub>i</sub>，o<sub>j</sub> ∊ O</li><li>Tainted data: t<sub>i</sub>，t<sub>j</sub> ∊ T ⊂ O   污点数据就是在调用点产生的对象中被特殊标记的部分</li><li><font color="red">Instance fiedls</font>: o<sub>i</sub>.f, o<sub>j</sub>.g ∊ O x F</li><li><font color="red">Pointers</font>:  Pointer = V ⋃ (O x F)</li><li>Points-to relations:    pt: Pointer ⟶ 𝓟(O)</li></ul><p>其中t<sub>i</sub>代表了从<code>call-site</code>调用点<code>i</code>产生的污点数据。𝓟(O)代表了O的幂集，<code>pt(p)</code>代表了指针变量<code>p</code>的指向集合。 </p><h4 id="Taint-Analysis-Input-amp-Outputs"><a href="#Taint-Analysis-Input-amp-Outputs" class="headerlink" title="Taint Analysis: Input &amp; Outputs"></a>Taint Analysis: Input &amp; Outputs</h4><p>污点分析的输入为<code>sources</code>——一系列返回值产生污点数据的函数集合，<code>Sinks</code>——一些敏感函数的集合，一旦污点数据流入这些函数将会触发安全问题。</p><p>污点分析的输出是<code>TaintFlows</code>:污点数据和Sinks函数的pairs集合。<strong>比如<t<sub>i&lt;/sub&gt;, m&gt;表示从<code>call-sites</code>调用点<code>i</code>产生的<code>tainted-data</code>可能会流入<code>sink-method</code></t<sub></strong>。</p><h4 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h4><p>整个污点分析需要处理的规则和指针分析大体一致，而对于调用语句<code>Call</code>的处理需要完成两种——<code>sources</code>和<code>sinks</code>的处理，分别用于产生污点数据和产生污点信息流。</p><h5 id="Sources"><a href="#Sources" class="headerlink" title="Sources"></a>Sources</h5><p><img src="2.png" width="50%" height="50%" alt=""></p><p>规则的前提是如果调用边集合<code>CG</code>中存在从<code>l</code>到<code>m</code>的一条调用边——<code>l⟶m</code>，而<code>m</code>恰好是<code>sources</code>函数集合中的元素，则需要将该调用语句的指针变量集合<code>pt(r)</code>加上一条污点数据t<sub>i</sub>。</p><h5 id="Sinks"><a href="#Sinks" class="headerlink" title="Sinks"></a>Sinks</h5><p><img src="3.png" width="50%" height="50%" alt=""></p><p>该规则的前提是如果调用边集合<code>CG</code>中存在一条调用边——<code>l⟶m</code>，而<code>m</code>恰好属于<code>sinks</code>函数集合中的元素，而在<code>m</code>的参数中还存在着污点数据集合中的元素t<sub>j</sub>，则会产生一条<code>TaintFlows</code>从t<sub>j</sub>到<code>m</code>函数即<t<sub>j&lt;/sub&gt;,m&gt;。</t<sub></p><p>污点分析的学习至此结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;同符号执行一样，&lt;code&gt;Taint-Analysis&lt;/code&gt;也是分析代码安全漏洞，检测攻击方式的重要手段。对于&lt;code&gt;Web&lt;/code&gt;应用程序中存在着的大量安全漏洞,如跨站脚本攻击，&lt;code&gt;SQL&lt;/code&gt;注入等~污点分析都可以进行有效地检测。而污点传播技术是当前&lt;code&gt;Taint-Analysis&lt;/code&gt;领域的重要课题，&lt;strong&gt;通过和静态程序分析技术相结合，在不运行代码且不修改代码的前提下通过分析程序变量之间的相互依赖关系以此获得更高效，更精确的分析结果。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;Taint analysis tracks how tainted data flow through the program and observes if they can flow to locations of interest(call sinks).  &lt;/p&gt;
&lt;p&gt;比如通过利用静态指针分析算法完成简化的显式流&lt;code&gt;explicit flow&lt;/code&gt;分析，不讨论&lt;a href=&quot;https://www.k0rz3n.com/2019/03/01/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;路径爆炸&lt;/a&gt;和其他动态漏洞分析技术。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(3-Pointer-Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/05/14/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-3-Pointer-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/05/14/NJU静态程序分析-3-Pointer-Analysis/</id>
    <published>2021-05-13T17:34:59.000Z</published>
    <updated>2022-03-16T10:08:39.152Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>过程间分析需要基于程序的<code>Call Graph</code>来完成。由于<code>CHA Analysis</code>过度追求速度造成误报——而<code>false positive</code>对于常量传播这样的<code>must</code>分析来说是不可接受的。因此指针分析在<code>POPL&#39;1980</code>被第一次提出<a href="https://static.aminer.org/pdf/PDF/000/546/844/interprocedural_data_flow_analysis_in_the_presence_of_pointers_procedure.pdf" target="_blank" rel="noopener">Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure Variables, and Label Variables</a>。  </p><p>Pointer Analysis computes an over-approximation of the set of which memory-locations(objects) a pointer can point to.  </p><p>指针分析除了可以构建<code>Call Graph</code>等程序基本信息之外，还可以用于编译优化，程序鲁棒性和安全等各个领域，是最基础的静态分析算法之一——比如流行的别名分析<code>Alias Analysis</code>就是从指针分析中派生出来的:Alias information can be derived from points-to relations.在指针分析的输出指向关系中是否有两个指针可以指向同一个对象。</p><a id="more"></a><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>指针分析是一种<code>may</code>分析，输入时整个程序，分析结果的输出是类似于map的一系列指向关系<code>Points-to relations</code>。</p><p><img src="1.png" width="50%" height="50%" alt=""></p><h4 id="KeyFactors"><a href="#KeyFactors" class="headerlink" title="KeyFactors"></a>KeyFactors</h4><p>作为一项比较复杂的技术，指针分析框架的<strong>精度</strong>和<strong>速度</strong>取决于四个很主要的因素：</p><div class="table-container"><table><thead><tr><th>Factor</th><th>Problem</th><th>Choice</th></tr></thead><tbody><tr><td>Heap abtraction</td><td>How to model heap memory?</td><td><font color="red">Allocation-site</font>/Storeless</td></tr><tr><td>Context sensitivity</td><td>How to model calling contexts?</td><td><font color="red">Context-sensitive/Context-insensitive</font></td></tr><tr><td>Flow sensitivity</td><td>How to model control flow?</td><td>Flow-sensitive/<font color-red="">Flow-insensitive</font></td></tr><tr><td>Analysis scope</td><td>Which parts of program should be analyzed?</td><td><font color="red">Whole-program</font>/Demand-driven</td></tr></tbody></table></div><h5 id="Heap-Abstraction"><a href="#Heap-Abstraction" class="headerlink" title="Heap Abstraction"></a>Heap Abstraction</h5><p>如何抽象堆操作，比如循环和递归会在动态运行时创建很多的堆对象，如何将这些<code>unbounded</code>的操作进一步简化抽象成<code>finite</code>的静态分析对象。</p><p><img src="2.png" width="50%" height="50%" alt=""></p><p>学术界有两个流派来完成堆抽象：<code>Store based model</code>和<code>Storeless model</code>。本节课介绍第一个流派下面的<code>Allocation sites</code>方法来对所有堆对象完成建模——<code>One abstract object per allocation site</code>。<strong>即每一个分配点<code>new</code>的堆对象都抽象到一个<code>object</code>中。</strong></p><h5 id="Context-Sensitivity"><a href="#Context-Sensitivity" class="headerlink" title="Context Sensitivity"></a>Context Sensitivity</h5><p>在函数调用的时候会产生上下文<code>context</code>。<strong>一个<code>method</code>被调用多次的话如何对每一次的上下文进行抽象。</strong>关于上下文抽象也有两种流派:</p><ul><li><code>Context-sensitive</code>:  对每一次调用都区别对待，具体调用具体分析</li><li><code>Context-insensitive</code>: 对一个<code>method</code>的所有调用都merge到一起，一次性处理</li></ul><p>上下文敏感是提高静态分析效率非常有效的工具之一，是这门课需要讨论的重点。</p><h5 id="Flow-Sensitivity"><a href="#Flow-Sensitivity" class="headerlink" title="Flow Sensitivity"></a>Flow Sensitivity</h5><p>如何对控制流抽象，也有两种流派：</p><ul><li><code>Flow-sensitive</code>: 确保程序的执行顺序<code>execution order</code>，维护每一个程序点的<code>points-to relations</code>表</li><li><code>Flow-insensitive</code>:忽略执行顺序，维护整个程序的指向表</li></ul><p>目前学术界还没有直接研究表明<code>flow sensitivity</code>相比于<code>flow insensitivity</code>对<code>Java</code>这样的OOP语言会有多少优势。</p><h5 id="Analysis-Scope"><a href="#Analysis-Scope" class="headerlink" title="Analysis Scope"></a>Analysis Scope</h5><p>在进行指针分析的时候，如何选取需要分析的程序段？</p><ul><li>Whole-program</li><li>Demand-driven</li></ul><p>是直接分析整套程序还是以需求为驱动进行特定程序片段的分析。实际上如果需求很多的话，单独分析的复杂度和直接进行整套程序分析的复杂度不相上下。</p><h4 id="Concerned-Statements"><a href="#Concerned-Statements" class="headerlink" title="Concerned Statements"></a>Concerned Statements</h4><p>上述的<code>Key Factors</code>是具有全局性质的-<strong>即针对整个指针算法框架</strong>，那在实现上-<strong>即针对<code>Java</code>编程语言的具体指针分析框架</strong>来说，更细粒度的<code>Concerned Statements</code>会是什么呢？</p><h5 id="Pointers-in-Java"><a href="#Pointers-in-Java" class="headerlink" title="Pointers in Java"></a>Pointers in Java</h5><p>首先需要总结一下<code>Java</code>中所有可以用作指针的声明。</p><ul><li><code>Local variable：x</code></li><li><code>Static field: C.f</code></li><li><code>Instance field: x.f</code></li><li><code>Array element: array[i]</code></li></ul><p>共有4中具体的指针类型——<code>static field</code>是一种全局变量。数组元素在分析时可以忽略掉索引，看成是可以指向任何数组元素<strong>field</strong>的指针类型<code>array.arr</code>，因此也被看成是一种<code>Instance field</code>。<font color="red">综上来看，针对Java语言的指针分析主要处理<code>Local variable</code>和<code>instance field</code>两种指针类型。</font>  </p><h5 id="Pointer-Affecting-Statements"><a href="#Pointer-Affecting-Statements" class="headerlink" title="Pointer-Affecting Statements"></a>Pointer-Affecting Statements</h5><p>明确了指针分析研究对象<strong><code>Pointers</code>的具体类型</strong>之后，继续思考全程序的指针分析如何更具体的完成实现？就语句本身来说例如<code>if/for/break</code>这样的控制流并不会对指针分析的结果造成影，我们需要关注真正的<font color="red">pointer-affecting statements</font>如下：</p><ul><li><code>New:      x = new T()</code></li><li><code>Assign:    x = y</code></li><li><code>Store:  x.f = y</code></li><li><code>Load:  y = x.f</code></li><li><code>Call:    r = x.k(a, ...)</code>     重点关注<code>virtual calls</code></li></ul><h3 id="Foundations"><a href="#Foundations" class="headerlink" title="Foundations"></a>Foundations</h3><h4 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h4><h5 id="Domains-and-Notations"><a href="#Domains-and-Notations" class="headerlink" title="Domains and Notations"></a>Domains and Notations</h5><p>指针分析是一种以指向关系作为传递信息的数据流分析。所以其理论也需要引入域和某些符号解释：</p><ul><li><font color="red">Variable</font>:   x, y ∊ V</li><li>Fields:  f,g ∊ F</li><li>Objects:  o<sub>i</sub>,o<sub>j </sub>∊ O    (Allocation sites)</li><li><font color="red">Instance fields</font>:  o<sub>i</sub>.f, o<sub>j</sub>.g ∊ O⨉F</li><li><font color="red">Pointers</font>:   Pointer = V⋃(O⨉F)</li></ul><p>其中Variable表示程序中的所有变量指针类型。Object和Fields分别指的是程序中分配堆对象的创建点和抽象堆对象中的域——对象和域组合起来的Instance Fields也表示程序中一种指针。<strong>Pointers指的是程序中所有的<code>variable</code>和<code>instance field</code>——<code>V ⋃ (O x F)</code>。</strong>  </p><p>最后引入<strong>指向关系<code>pt</code>(其本身就是一种映射， 代表指针可能指向的对象的集合)</strong>： </p><ul><li><p><font color="blue">Points-to relations</font>:  <code>pt: Pointer ⟶ 𝓟(O)</code></p><ul><li><p><code>𝓟(O)</code>表示对象O的<code>powerset</code></p></li><li><p><code>pt(p)</code>表示指针p的<strong>指向关系集合</strong></p></li></ul></li></ul><p><strong>理解上，指针指向对象——指针p的值域就是<code>V ⋃ (O x F)</code>，对象o的值域就是<code>𝓟(allocation sites)</code>。<code>p⟶o ≡ o∊pt(p)</code>即指针p指向对象o等价于对象o属于指针p的指向关系集合。</strong></p><p>在此基础上，引入如何处理<code>Pointer-Affecting Statements</code>的形式化Rules：</p><p><img src="3.png" width="50%" height="50%" alt=""></p><p>分数上面是前提<code>premise</code>而下面是结论<code>conclusion</code>。</p><ul><li><p>New:  <code>New</code>规则中的o<sub>i</sub> 表示一个<code>Allocation site</code>在这一点创建出来的对象，那么指针分析如何处理一个<code>New</code>语句——<strong>即执行完这条语句后让x指向o<sub>i</sub>即o<sub>i</sub> ∊ pt(x)</strong>。</p></li><li><p>Assign: 如果o<sub>i</sub>属于y的指向集，<strong>那在执行完这条语句后o<sub>i</sub>则需要加入到x的指向集中。</strong></p></li><li><p>Store: 将新对象保存到该对象的一个域f——如果x指向o<sub>i</sub>而y指向o<sub>j</sub>，<strong>那执行完这条语句之后o<sub>i</sub>.f需要指向o<sub>j</sub>。</strong></p></li><li><p>Load: 将某个对象的域f加载到新对象中——如果x指向o<sub>i</sub>而o<sub>i</sub>的域f指向o<sub>j</sub>，<strong>那执行完后将o<sub>j</sub>加入到y的指针集当中。</strong></p></li></ul><h4 id="How-to-Implement-Pointer-Analysis"><a href="#How-to-Implement-Pointer-Analysis" class="headerlink" title="How to Implement Pointer Analysis"></a>How to Implement Pointer Analysis</h4><p>在确定好Domain和Rules之后开始明确如何实现<strong>全程序的指针分析算法</strong>。</p><p>Essentially，pointer analysis is to <font color="red">propagate</font> points-to information among pointers(variables &amp; fields).  </p><p><strong>在两种指针(<code>variable</code>和<code>fields</code>)之间根据<code>Pointer-Affecting Statements</code>建立和传递指向关系<code>points-to</code>。</strong>从另一个角度来说指针分析就是在解决指针之间的<code>inclusion constraints</code>即对于<code>x = y</code>语句指针x一定包含指针y的所有指向信息。<strong>而关键的是当<code>pt(x)</code>更新时，这些改变也需要传递给x的其他相关指针</strong>。    </p><p>而在实现上，我们用<code>Graph</code>来连接相关联的指针，当<code>pt(x)</code>更新时，将更新的数据流（数据流分析根据Domain不同而不同，指向关系也是一种数据流信息）传递给<code>x</code>的后继元素，这个图就是<code>Pointer Flow Graph</code>。</p><h5 id="Pointer-Flow-Graph-PFG"><a href="#Pointer-Flow-Graph-PFG" class="headerlink" title="Pointer Flow Graph(PFG)"></a>Pointer Flow Graph(PFG)</h5><p>一个程序的<code>PFG</code>是一种表示<code>points-to</code>信息如何在<code>pointers</code>之间流动的有向图，图中的节点代表了<code>V ⋃ (O ⨉ F)</code>——变量或者<strong>抽象对象</strong>(因为PFG是静态分析建立的，所以是抽象的堆对象)的域，边代表了对象在指针之间的流动关系<code>Pointer ⨉ Pointer</code>——比如<code>x⟶y</code>代表了指针x的指向对象集合<font color="red">可能(指针分析是<code>may</code>分析)会流动到</font>y的指向集合。  </p><p>PFG中的节点就是程序中的各种指针，而边是根据指针分析的Rules建立的。</p><p><img src="4.png" width="50%" height="50%" alt=""></p><p>有了PFG，指针分析问题就可以看成是在PFG上求其<strong>传递闭包</strong>的问题，比如PFG中a点到b点是可达的，那a中的数据流信息就可以直接流到b节点上。  </p><p>综上，指针分析的思路主要有两部分：创建PFG——&gt;在PFG上传递指向信息。而难点在于这两者是互相依赖的。为什么创建PFG也会依赖指向信息呢？</p><p><img src="5.png" width="50%" height="50%" alt=""></p><p>因为在处理<code>instance fields</code>的指向关系的时候，前提是需要知道这些<code>field</code>的<code>object</code>的指向信息——由<code>allocation sites</code>更新得到。<strong>因此<code>PFG</code>本身也是随着指针分析的过程动态更新的。</strong></p><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p>本节具体实现数据流分析算法，首先是使用到的数据结构：</p><ul><li><code>S</code>:  输入程序的语句集合</li><li><code>WL</code>:  work list存储了需要处理的指向关系pair，<strong>其中每一项<code>&lt;n,𝓟(O)&gt;*</code>意味着在<code>𝓟(O)</code>中的信息需要传递给<code>n</code>的指向关系集合<code>pt(n)</code>中</strong>，用</li><li><code>PFG</code>:  有向图，表示成为边的集合，其中<code>s⟶t</code>表示<code>s</code>的指向关系流向<code>t</code>的指向关系</li><li><code>Hybrid-Set</code>: 用来存在<code>pt(s)</code>，即当元素小于16时用<code>HashSet</code>大于16时用<code>BitVector</code></li></ul><h5 id="Main-Algorithm"><a href="#Main-Algorithm" class="headerlink" title="Main Algorithm"></a>Main Algorithm</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Solve(S) &#123;</span><br><span class="line">  WL = [], PFG = &#123;&#125;</span><br><span class="line">  foreach i: x=new T() ∊ S do          //处理New语句</span><br><span class="line">    add &lt;x, &#123;O_i&#125;&gt; to WL              </span><br><span class="line"></span><br><span class="line">  foreach x=y ∊ S do       //处理Assign语句</span><br><span class="line">    AddEdge(y, x)</span><br><span class="line"></span><br><span class="line">   while WL is not empty do</span><br><span class="line">     remove &lt;n, pts&gt; from WL</span><br><span class="line">     𝚫 = pts - pt(n)</span><br><span class="line">     Propagate(n, 𝚫)     </span><br><span class="line">     if n represents a variable x then</span><br><span class="line">       foreach o_i ∊ 𝚫 do </span><br><span class="line">         foreach x.f=y ∊ S do</span><br><span class="line">           AddEdge(y, o_i.f)     //处理Store语句 </span><br><span class="line">         foreach y=x.f ∊ S do    </span><br><span class="line">           AddEdge(o_i.f, y)    //处理Load语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddEdge(s, t) &#123;   //构建PFG</span><br><span class="line">  if s⟶t ∉ PFG then      </span><br><span class="line">    add s⟶t to PFG</span><br><span class="line">    if pt(s) is not empty then</span><br><span class="line">      add &lt;t, pt(s)&gt; to WL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Propagate(n, pts) &#123;    //更新pt(x)</span><br><span class="line">  if pts is not empty then</span><br><span class="line">    pt(n) ⋃= pts //核心： 传递数据流</span><br><span class="line">    foreach n⟶s ∊ PFG do </span><br><span class="line">      add &lt;s, pts&gt; to WL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AddEdge"><a href="#AddEdge" class="headerlink" title="AddEdge"></a>AddEdge</h5><p>首先每一条<code>New</code>语句生成一条指向关系完成对<code>WL</code>的初始化。这套算法的输入语句<code>S</code>是流不敏感<code>insensitive</code>的，即处理过程不会关注语句顺序。</p><p><code>AddEdge</code>函数主要是通过处理<code>Assign</code>语句构建<code>PFG</code>。每一条<code>s⟶t</code>都对应着图上一条边，根据指针分析的<code>inclusion constraints</code>原理将<code>&lt;t, pt(s)&gt;</code>加入<code>WL</code>中实现把指针<code>s</code>的指向集合加到指针<code>t</code>中。</p><h5 id="Propagate"><a href="#Propagate" class="headerlink" title="Propagate"></a>Propagate</h5><p>在构建完最基础的的<code>PFG</code>之后，算法进入<code>While</code>循环开始迭代处理<code>WL</code>中的指向关系。取出一项<code>&lt;n, pts&gt;</code>，<strong>过滤掉指针<code>s</code>指向关系中指针<code>n</code>已经存在的抽象对象即𝚫=pts-pt(n)——主要是为了避免更多的冗余操作已达到<code>Differential Propagation</code></strong>  </p><p>然后开始<code>Propagate</code>函数，<font color="red">这个函数是真正修改了指针的指向关系即完成数据流的传递，换句话讲指针分析的过程就是在迭代过程中不断向<code>pts</code>中加入新的数据流</font>。而进入到函数内的𝚫是真正需要传递给<code>n</code>的指向集合，接着又根据<code>inclusion constraints</code>需要把指针<code>n</code>刚更新过的指向集合加到其在<code>PFG</code>上的后继中，故遍历整个图找到所有的后继节点<code>s</code>并把<code>&lt;s, pts&gt;</code>加到<code>WL</code>中等待下一轮更新。</p><h5 id="Differential-Propagation"><a href="#Differential-Propagation" class="headerlink" title="Differential Propagation"></a>Differential Propagation</h5><p><strong>查分传播</strong>是为了避免处理冗余的指针信息。这是因为在<code>PFG</code>上任意点的指向集合信息<code>pt(n)</code>一定已经传播到了其后继元素，没有必要在传播一次。在整个算法中一共有两处查分传播，分别是在<code>𝚫=pts-pt(n)</code>语句以及处理<code>Store/Load</code>语句的代码片段<code>foreach O_i ∊ 𝚫 do</code>。   </p><p>首先<code>Store/Load</code>语句映射到<code>PFG</code>上的操作正好相反：</p><ul><li><code>Store：x.f=y</code> o<sub>i</sub>.f ⟵ y</li><li><code>Load: y=x.f</code>   y⟵ o<sub>i</sub>.f</li></ul><p>关键是需要知道指针<code>x</code>指向的抽象对象<code>o_i</code>然后继续操作。而<code>foreach o_i∊𝚫 do</code>正好清除掉指针<code>x</code>以前的指向信息而保留了这次迭代中<strong>新加入</strong>的抽象对象。 </p><p><img src="6.png" width="50%" height="50%" alt=""></p><p>就<code>Store/Load</code>语句本身而言也是通过<code>AddEdge</code>的方式来更新<code>PFG</code>的，但这里要注意的是<strong>因为有可能两个变量会指向相同的抽象对象o<sub>i</sub>，即虽然o<sub>i</sub>对于x来说是新加入的指向信息，但是有可能在前几次迭代中有<code>z.f=y</code>中的指针<code>z</code>也指向抽象对象o<sub>i</sub>，<font color="red">即因为指针o<sub>i</sub>.f中o<sub>i</sub>是一个对象——有可能会被多个指针指向，因此这里的<code>AddEdge</code>操作不能保证一定会引入新的<code>PFG</code>边</font></strong>。</p><h5 id="Fixed-Point"><a href="#Fixed-Point" class="headerlink" title="Fixed Point"></a>Fixed Point</h5><p>算法符合不动点原理——<code>WL</code>的功能就是向<code>pt</code>中添加信息，而核心<code>pt(n) ⋃ =pts</code>之后如果直接检查合并前后<code>pt</code>集合是否有变化也以判断达到不动点。</p><h4 id="How-To-Deal-With-Method-Calls"><a href="#How-To-Deal-With-Method-Calls" class="headerlink" title="How To Deal With Method Calls"></a>How To Deal With Method Calls</h4><p>全程序的指针分析算法还需要处理方法调用。和所有过程间分析一样，<code>Inter-procedural pointer analysis</code>也需要建立<code>call graph</code>。不过相比于<code>CHA analysis</code>仅仅通过<code>receiver object</code>的声明类型来构建调用图不同，指针分析还使用指向信息<code>points-to relations</code>来使得<code>call graph</code>的构建更加精确。比如<code>void foo(A a) {... b = a.bar();...}</code>中<strong><code>points-to relations</code>和<code>Call Graph</code>都是在指针分析的过程中动态更新的，比如想要建立<code>pt(a)</code>需要知道函数<code>foo</code>的调用边，而如果想要给<code>a.bar()</code>建立调用边则也需要<code>pt(a)</code>，这种方法被称为<code>on-the-fly call graph construction</code></strong>。</p><ul><li><code>CHA</code>:  基于<code>a</code>声明类型解析<code>call targets</code></li><li><code>pointer analysis</code>: 基于<code>pt(a)</code>解析<code>call targets</code></li></ul><h5 id="Rule-Call"><a href="#Rule-Call" class="headerlink" title="Rule: Call"></a>Rule: Call</h5><p>首先引入指针分析处理方法调用Rules的形式化描述：</p><p><img src="7.png" width="50%" height="50%" alt=""></p><p>指针分析器在遇到了<code>r = x.k(a1, ...)</code>调用语句的时候，肯定会模拟编译器的运行时行为并解析：</p><ul><li>o<sub>i</sub>∊pt(<font color="blue">x</font>),m=Dispatch(o<sub>i</sub>,k) ⟶ o<sub>i</sub>∊pt(<font color="blue">m<sub>this</sub></font>)，其中x是<code>caller</code>变量</li><li>o<sub>u</sub>∊pt(<font color="blue">a<sub>j</sub></font>) ⟶ o<sub>u</sub>∊pt(<font color="blue">m<sub>pj</sub></font>)，其中a<sub>j</sub>是形参</li><li>o<sub>v</sub>∊pt(<font color="blue">m<sub>ret</sub></font>)⟶o<sub>v</sub>∊pt(<font color="blue">m<sub>r</sub></font>)，其中m<sub>ret</sub>是返回值</li></ul><p>为了解释的更清楚，下面对规则进行了进一步的解释：</p><ul><li>根据<code>pt(x)</code>得到被调用方法<code>k</code>的<code>receiver object</code>即o<sub>i</sub>，然后调用<code>Dispatch(O_i, k)</code>解析出<code>target method</code>即<code>m</code>   </li><li>将目标函数<code>m</code>的<code>this</code>指针指向变量<code>x</code>实际指向的对象即o<sub>i</sub></li><li>将形参<code>m_pj</code>的指针指向实参变量指向的对象集合<code>pt(aj)</code>，<font color="red">并将形参变量和对应实参变量之间加上<code>PFG</code>边(a1⟶m_p<sub>j</sub>)</font></li><li>将调用语句的<code>LHS</code>指向目标函数<code>m</code>的返回值变量指向的对象结婚<code>m_ret</code>，<font color="red">并将这两个变量之间加上<code>PFG</code>的边(r⟵m<sub>ret</sub>)</font></li></ul><p>主要需要关注的是<code>receiver object</code>，<code>target method</code>，<code>arguments</code>和<code>return value</code>。</p><p><img src="8.png" width="50%" height="50%" alt=""></p><p>而这里对形参和实参之间，返回值和左值之间连上<code>PFG</code>的边而没有给目标方法和调用者之间加边的原因是<strong>因为<code>caller</code>变量<code>x</code>有可能有多个指向对象<code>pt(x)</code>，而对于<code>Dispatch</code>函数来说，只要<code>receiver object</code>确定那<code>target method</code>也是确定的。如果我们需要保证OOP语言中所有函数的<code>this</code>指针都指向唯一正确的<code>receiver object</code>即o<sub>i</sub>，前提就是保证不能让其他虚假的<code>pt(x)</code>信息直接流入<code>this</code>指针——</strong>如果贸然给<code>x</code>和目标方法的<code>this</code>指针之间加上<code>PFG</code>只会导致引入虚假<code>spurious</code>信息。  </p><h5 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm"></a>Algorithm</h5><p>在过程间指针分析中，调用图的构建和指向关系的构建都是同步动态更新的，引入<code>reachable</code>可达的概念：即从<code>main</code>函数开始，将真正调用到的函数依次纳入可达方法集合中，所有的分析只从这些集合中完成。首先介绍算法中使用到的数据结构：</p><ul><li><code>S</code>: 可达语句<code>reachable statements</code>的集合</li><li><code>S_m</code>:  函数<code>m</code>中的语句集合</li><li><code>RM</code>:  可达函数集合</li><li><code>CG</code>:  调用边<code>Call Graph</code>集合</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Solve(m_entry) &#123;</span><br><span class="line">WL = &#123;&#125;, PFG = &#123;&#125;, RM = &#123;&#125;, CG = &#123;&#125;</span><br><span class="line">AddReachable(m_entry)</span><br><span class="line">while(WL is not empty) &#123;</span><br><span class="line">remove &lt;n, pts&gt; from WL</span><br><span class="line">𝚫 = pts - pt(n)</span><br><span class="line">Propagate(n, 𝚫)</span><br><span class="line">if n represents a variable x &#123;</span><br><span class="line">foreach o_i∊𝚫 do</span><br><span class="line">foreach x.f=y∊S do</span><br><span class="line">        AddEdge(y, o_i.f)</span><br><span class="line">        foreach y=x.f∊S do</span><br><span class="line">        AddEdge(o_i.f, y)</span><br><span class="line">        ProcessCall(x, o_i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddReachable(m) &#123;</span><br><span class="line">if m∉RM then</span><br><span class="line">add m to RM</span><br><span class="line">S ⋃= S_m</span><br><span class="line">foreach i:x=new T()∊S_m do</span><br><span class="line">add &lt;x, &#123;o_i&#125;&gt; toWL</span><br><span class="line">foreach x=y∊S_m do</span><br><span class="line">AddEdge(y, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessCall(x, o_i) &#123;</span><br><span class="line">foreach l:r=x.k(a1,...an)∊S do</span><br><span class="line">m = Dispatch(o_i,k)</span><br><span class="line">add &lt;m_this,&#123;o_i&#125;&gt; to WL</span><br><span class="line">if l⟶m∉CG then</span><br><span class="line">add l⟶m to CG</span><br><span class="line">AddReachable(m)</span><br><span class="line">foreach parameter p_i of m do</span><br><span class="line">AddEdge(a_i, p_i)</span><br><span class="line">AddEdge(m_ret, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="AddReachable"><a href="#AddReachable" class="headerlink" title="AddReachable"></a>AddReachable</h6><p>这个函数的功能就是将被调用的方法加入<code>RM</code>，并将对应的语句加入到<code>S</code>中。<code>AddReachable</code>函数在整个算法一共两个地方被调用——一个是初始化将<code>main</code>函数首先加入，其次就是在每一次有新的<code>Call Graph edge</code>被创建的时候。函数本身还需要处理当前<code>Reachable Method</code>中的<code>New/Assign</code>语句。<strong>这是因为<code>Load/Store/Call</code>语句的分析都是根据指向信息的变化（比如<code>x.f=y</code>如果<code>x</code>又指向了一个新对象）来更新处理的，但是<code>New/Assign</code>不需要任何信息就可以独立完成分析。</strong>这也是<code>Differential</code>的目的。</p><h6 id="ProcessCall"><a href="#ProcessCall" class="headerlink" title="ProcessCall"></a>ProcessCall</h6><p>该函数处理方法调用的<code>Rules</code>。<strong>整个函数执行的前提就是该函数的<code>receiver object</code>即<code>x</code>有新的指向关系o<sub>i,j,k…</sub>被加入到𝚫时，</strong>这两个参数被传入到函数中开始执行。  </p><p>首先使用<code>Dispatch</code>函数解析出来<code>target method</code>即<code>m</code>变量。通过把<m<sub>this&lt;/sub&gt;,{o<sub>i</sub>}&gt;加入到<code>WL</code>中来完成将目标函数<code>m</code>的<code>this</code>指针指向变量<code>x</code>实际指向对象即o<sub>i</sub>。</m<sub></p><p>接下来添加<code>Call Graph</code>，这里之所以要有<code>if</code>语句判断该条调用边存在性即<code>Differential</code>，是因为<strong>有可能之前有和o<sub>i</sub>相同类型的对象o<sub>j</sub>已经触发了<code>ProcessCall</code>函数执行并加上调用边——因为整个<code>While</code>循环继续执行的前提就是<code>pt(x)</code>被更新，那更新前后的o<sub>i,j,k…</sub>完全有可能是同一个类型。</strong>  </p><p>添加完调用边之后，最后添加参数和返回值。整个算法的输出是<code>Points-to relations</code>和<code>Call Graph</code>。至此上下文不敏感的全程序指针分析算法就介绍完了。</p><h3 id="Context-Sensitivity-1"><a href="#Context-Sensitivity-1" class="headerlink" title="Context Sensitivity"></a>Context Sensitivity</h3><p>上下文敏感是提升指针分析精度（尤其是针对<code>Java</code>语言的指针分析）最有效的技术，也是指针分析领域近年来研究的热点。</p><h4 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h4><p>在程序动态运行的过程中，一个<code>method</code>可能会在不同的<code>context</code>下被调用多次。而在不同的上下文中<code>method</code>的指针可能会指向不同的<code>object</code>。<strong><code>Context Insensitivity .aka. C.I.</code>导致这些不同上下文的<code>objects</code>通过返回值都被传递到程序的其他分支中进而产生虚假数据流信息。</strong>比如程序中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = id(n1);</span><br><span class="line">y = id(n2);</span><br><span class="line">int i = x.get();</span><br><span class="line">Number id(Number n) &#123;</span><br><span class="line">return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数<code>id</code>被调用两次，故形式参数<code>n</code>被传入两条<code>PFG</code>边——分别是实参<code>n1</code>和<code>n2</code>，而这两个指针对象又分别指向不同的o<sub>i</sub>和o<sub>j</sub>，<strong>导致返回值<code>n</code>的指向关系集合<code>pt(n)</code>里增加了o<sub>i</sub>和o<sub>j</sub>。</strong>而<code>n</code>和<code>x</code>,<code>y</code>又各自连着<code>PFG</code>故导致<code>pt(x)/pt(y)</code>的指向关系也是o<sub>i</sub>和o<sub>j</sub>——如果是过程间的常量传播则最终分析的结果就是<code>x/y = NAC</code>，很明显丧失了精度。  </p><p>Context sensitivity models calling contextx by <font color="red">distinguishing </font>different data flows of different contextx to improve precision.  </p><p>下面讨论开展上下文敏感的指针分析算法所需要考虑的几个方面：</p><h5 id="Call-site-sensitivity"><a href="#Call-site-sensitivity" class="headerlink" title="Call-site sensitivity"></a>Call-site sensitivity</h5><p><code>Context sensitivity .aka. C.S.</code>用来区别不同上下文的方式中最常见的是<code>call-site sensitivity</code>——每一个上下文都抽象成本次方法调用的<strong>动态运行时调用栈</strong>即一系列<code>call-sites</code>组成的列表(随着调用层次深入<code>c</code>的长度会增加，区别于用<code>l</code>行号代表当前调用点)，比如上面一段代码中的<code>id</code>方法共有两个<code>context</code>分别是<code>[1]</code>和<code>[2]</code>。从实现的角度来看，<code>Cloning-Based Context Sensitivity</code>是实现<code>C.S.</code>最直接的方式——同一个<code>method</code>的多次调用都根据各自的<code>context</code>区分成不同的<code>Cloning-Based</code>版本，<code>method</code>中的调用也随着各自的<code>Cloning-Based</code>区分出来——<code>one clone per context</code>。</p><p><img src="9.png" width="50%" height="50%" alt=""></p><h5 id="Context-Sensitive-Heap"><a href="#Context-Sensitive-Heap" class="headerlink" title="Context-Sensitive Heap"></a>Context-Sensitive Heap</h5><p>从更细粒度的角度看，OOP是<code>heap-intensive</code>的语言——所有的对象都是建立在堆区<code>by new</code>。在实际设计中，上下文敏感的指针分析算法还需要考虑到堆敏感的问题——这是因为所有的语句其实都有自己的作用域，OOP的作用域就是函数。<strong>创建新对象的<code>new</code>语句就是一个<code>allocation site</code>，而当<code>new</code>语句出现在一个函数中恰巧该函数又被多次调用的时候，同一个<code>allocation site</code>会在不同的上下文背景下建立各自的对象</strong>，所以同一个方法中的堆对象也需要根据不同的<code>heap context</code>来进行区分。最直接的方式就是直接继承其所在<code>method</code>的上下文并从更加细粒度的角度处理指针分析算法：</p><p><img src="10.png" width="50%" height="50%" alt=""></p><h4 id="Rules-1"><a href="#Rules-1" class="headerlink" title="Rules"></a>Rules</h4><p>下面引入上下文敏感指针分析的<code>Rules</code>：</p><h5 id="Domains-and-Notations-1"><a href="#Domains-and-Notations-1" class="headerlink" title="Domains and Notations"></a>Domains and Notations</h5><p>在上下文敏感分析中，程序中的所有元素（变量，方法，对象）都加上了上下文。首先引入上下文的集合<code>C</code>,</p><ul><li>c,c’,c’’ ∊ C</li></ul><p>而程序中的方法，变量和对象都和<code>context</code>做了<code>product</code>：</p><ul><li><font color="red">Context-sensitive methods</font>:   <font color="red">c:</font>m   ∊    <font color="red">C</font> x M</li><li><font color="red">Context-sensitive variables</font>:   <font color="red">c:</font>x, <font color="red">c’:</font>y  ∊  <font color="red">C</font> x V</li><li><font color="red">Context-sensitive objects</font>:       <font color="red">c:</font>o<sub>i</sub>, <font color="red">c’:</font>o<sub>j</sub>  ∊   <font color="red">C</font> x O</li><li>Fields:    f, g ∊ F</li><li>Instance fields:    <font color="red">c:</font>o<sub>i</sub>.f, <font color="red">c’:</font>o<sub>j</sub>.g  ∊  <font color="red">C</font> x O x F</li></ul><p>最后，引入这些程序中的两种上下文敏感的指针类型：</p><ul><li><font color="red">Context-sensitive pointers</font>:    CSPointer = (<font color="red">C</font> x V) ⋃ (<font color="red">C</font> x O x F)</li></ul><p>以及指向关系集合：</p><ul><li>Points-to relations:     pt:   CSPointer ⟶ 𝓟(<font color="red">C</font> x O)</li></ul><h5 id="Regular-Rules"><a href="#Regular-Rules" class="headerlink" title="Regular Rules"></a>Regular Rules</h5><p>这些规则和之前针对<code>Java</code>语言的数据流分析框架规则基本一样，只是元素都加上了不同的上下文以区分，重点需要关注这些语句中的<font color="green">指针变量</font>和<font color="blue">堆对象</font>是否都在同一个<code>context</code>中：</p><p><img src="11.png" width="50%" height="50%" alt=""></p><p><code>new</code>语句中<code>x</code>和分配的堆对象o<sub>i</sub>同属于一个上下文，那是因为指针变量的初始化堆内存一定是在一个作用域中。<code>assign</code>语句中会发现只有<code>x = y</code>是在一个<code>context</code>中，而其两个指针变量共同指向的堆内存部分<code>pt(y)</code>却<strong>共同</strong>在另一个<code>context</code>中这是因为有参数传递的可能。<code>Store/Load</code>语句中<code>x</code>和<code>y</code>在同一个上下文中但是它们的指向对象却<strong>分别</strong>在不同的<code>context</code>下。</p><h5 id="Call-Rule"><a href="#Call-Rule" class="headerlink" title="Call Rule"></a>Call Rule</h5><p>上下文敏感的规则中最重要的就是<code>Call</code>规则，它主导并传递了不同的数据流使得精度提升成为可能。  </p><p><img src="12.png" width="50%" height="50%" alt=""></p><p>假设用<code>c</code>代表当前所在方法也就是调用者<code>Caller</code>的上下文，而用c<sup>t</sup>代表被调用者<code>Callee</code>的上下文。首先得到指针变量<code>x</code>的<code>receiver object</code>即o<sub>i</sub>，该堆对象有可能是在不同的上下文中因此和其指针的上下文不同。其次使用o<sub>i </sub>和方法签名<code>k</code>作为参数，<code>Dispatch</code>出真正的<code>target method</code>。最后使用和<code>call-site</code>相关的信息：<code>call-site</code>，当前上下文<code>c</code>以及所指向的堆对象<code>c&#39;:o_i</code>作为参数使用函数<code>Select</code>来取得该<code>target method</code>的上下文c<sup>t</sup>。<strong>需要注意的就是<font color="red">o<sub>i,j,k…</sub> = pt(x)&lt;</font>中的o<sub>i,j,k…</sub>和<code>x</code>两者之间的上下文是没有直接关系的，所以严格讲这两个的<code>c</code>都应该是不同的。</strong></p><p><img src="13.png" width="50%" height="50%" alt=""></p><p>这时候基本上所有<code>Cloning-Based</code>的程序元素都取得了，就和上下文不敏感指针分析处理<code>Call</code>的规则基本一致。</p><h4 id="Algorithm-2"><a href="#Algorithm-2" class="headerlink" title="Algorithm"></a>Algorithm</h4><p>上下文敏感的算法和上下文不敏感的指针分析算法整体上框架是一样的。<strong>构建上下文敏感的指针流图并通过PFG with C.S.传递指向信息。</strong>只是这些PFG的节点和边为了更高的精度被加上了新的约束——上下文信息，从而变成了<code>context-sensitive variable/abstract object</code>的指针类型。</p><ul><li><code>Node: CSPointer = (C x V) ⋃ (C x O x F)</code></li><li><code>Edges:CSPointer x CSPointer</code></li></ul><p>PFG中的每一个节点都被上下文<code>c</code>区分开，每一条边都有了更细粒度的解释：</p><ul><li><code>x = y</code>:   c:x ⟵ c:y</li><li><code>x.f = y</code>:  c’:o<sub>i</sub>.f ⟵ c:y</li><li><code>y = x.f</code>:  c:y ⟵ c’:o<sub>i</sub>.f</li></ul><p>下面就是上下文敏感的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Solve(m_entry) &#123;</span><br><span class="line">  WL=&#123;&#125;, PFG=&#123;&#125;, S=&#123;&#125;, RM=&#123;&#125;, CG=&#123;&#125;</span><br><span class="line">  AddReachable([]:m_entry)     //上下文敏感函数</span><br><span class="line">  while WL is not empty do</span><br><span class="line">    remove &lt;n, pts&gt; from WL</span><br><span class="line">    𝚫 = pts - pt(n)</span><br><span class="line">    Propagate(n, 𝚫)</span><br><span class="line">    if n represents a variable c:x then   //上下文敏感的指针变量</span><br><span class="line">        foreach c&apos;:o_i ∊ 𝚫 do     //上下文敏感的堆对象</span><br><span class="line">        foreach x.f = y ∊ S do</span><br><span class="line">              AddEdge(c:y, c&apos;:o_i.f)  //对上下文敏感的指针和堆对象加PFG边</span><br><span class="line">            foreach y = x.f ∊ S do</span><br><span class="line">              AddEdge(c&apos;:o_i.f, c:y)</span><br><span class="line">            ProcessCall(c:x, c&apos;:o_i)    //处理上下文敏感的方法调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddReachable(c:m) &#123;</span><br><span class="line">  if c:m ∉ RM then</span><br><span class="line">    add c:m to RM</span><br><span class="line">    S ⋃= S_m</span><br><span class="line">    foreach i:x = new T() ∊ S_m do</span><br><span class="line">      add&lt;c:x, &#123;c:o_i&#125;&gt; to WL   //修改PFG</span><br><span class="line">    foreach x = y ∊ S_m do</span><br><span class="line">      AddEdge(c:y, c:x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessCall(c:x, c&apos;:o_i)&#123;</span><br><span class="line">     foreach l: r = x.k(a1, ..., an)∊S do</span><br><span class="line">        m = Dispatch(o_i, k)</span><br><span class="line">        ct = Select(c, l, c&apos;:o_i)   // 核心： 选择target method的上下文ct</span><br><span class="line">        add &lt;ct:m_this, &#123;c&apos;:o_i&#125;&gt; to WL   //this指针和堆对象加PFG</span><br><span class="line">          if c:l ⟶ ct:m to CG      //添加调用边</span><br><span class="line">            add c:l ⟶ ct:m to CG</span><br><span class="line">              AddReachable(ct:m)   </span><br><span class="line">              foreach parameter p_i of m do //处理参数</span><br><span class="line">              AddEdge(c:a_i, ct:p_i)</span><br><span class="line">             AddEdge(ct:m_ret, c:r)   //处理返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Variants"><a href="#Variants" class="headerlink" title="Variants"></a>Variants</h4><p>上述算法中引入了一个新的<strong>函数<code>Select(c, l, c&#39;:o_i)</code>——在<code>caller</code>函数中利用相关信息获取当前<code>callee</code>的上下文。</strong>该信息包括调用者上下文<code>caller context</code>，调用点<code>call-ste</code>，堆上下文敏感的对象<code>receiver object with heap context</code>。</p><p><img src="14.png" width="50%" height="50%" alt=""></p><p>介绍三个版本的<code>Select</code>函数。</p><h5 id="Call-site-sensitivity-1"><a href="#Call-site-sensitivity-1" class="headerlink" title="Call-site sensitivity"></a>Call-site sensitivity</h5><p>该版本的<code>context</code>由一系列<code>call-site</code>（在代码中由行号来表示）组成的列表。<strong><code>callee-context</code>是在每次调用点将当前的行号append到<code>caller-context</code>上</strong>——本质上是在模拟调用栈：</p><ul><li>Select(c, l, …) = [<font color="red">l’, …, l’’</font>, l], where c = [<font color="red">l’, …, l’’</font>]</li></ul><p>这个列表的长度可以规定，故又称为<code>k-CFA</code>。而这种抽象在递归程序中会导致出现无数个<code>callee-context</code>,又比如在实际工程项目中调用栈很深的情况下上下文过于冗长：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;   //context:[]</span><br><span class="line">...</span><br><span class="line">a.foo();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo() &#123;   //context:[3]</span><br><span class="line">...</span><br><span class="line">b.bar();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void bar()&#123;   //Context:[3,9], [3,9,15], [3,9,15,15...]  无数个</span><br><span class="line">...</span><br><span class="line">bar();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>k-Limiting Context</code>通过对上下文的长度进行了限制保证了不会过度增长。一般情况下长度≤3。而且<code>method context</code>和<code>heap context</code>使用不同的长度保证不会互相有影响。</p><h5 id="Object-sensitivity"><a href="#Object-sensitivity" class="headerlink" title="Object sensitivity"></a>Object sensitivity</h5><p>该版本的<code>context</code>是由一系列抽象对象<code>abstract objects</code>（由其<code>allocations site</code>表示）组成的。</p><ul><li>Select(,,c’:o<sub>i</sub>) = [<font color="red">o<sub>j</sub>,…,o<sub>k</sub></font>,o<sub>i</sub>]  where c’=[<font color="red">o<sub>j</sub>,…,o<sub>k</sub></font>]</li></ul><p>这里一个有意思的点就是不管是<code>Object</code>还是<code>Call-site</code>都有自己的局限性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">B f;</span><br><span class="line">void set(B b)&#123;</span><br><span class="line">this.doSet(b);</span><br><span class="line">&#125;</span><br><span class="line">void doSet(B p)&#123;</span><br><span class="line">this.f = p;</span><br><span class="line">&#125;</span><br><span class="line">B get()&#123;</span><br><span class="line">return this.f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a1 = new A();</span><br><span class="line">a2 = new A();</span><br><span class="line">b1 = new B();</span><br><span class="line">b2 = new B();</span><br><span class="line">a1.set(b1);</span><br><span class="line">a2.set(b2);</span><br><span class="line">x = a1.get();</span><br></pre></td></tr></table></figure><p>则使用<code>1-call-site</code>敏感来完成时，会发现因为<code>set</code>中套用了<code>doSet</code>函数而导致<code>c:b1</code>和<code>c&#39;:b2</code>都指向了<code>c&#39;&#39;:doSet_this</code>函数，从而引入虚假信息。而使用<code>1-object</code>则因为<code>doSet</code>函数分别在两个堆对象下所以更精确。</p><p>下面的代码下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class C&#123;</span><br><span class="line">static void main() &#123;</span><br><span class="line">C c = new C();</span><br><span class="line">c.m()</span><br><span class="line">&#125;</span><br><span class="line">Number id(Number n) &#123;</span><br><span class="line">return n;</span><br><span class="line">&#125;</span><br><span class="line">void m() &#123;</span><br><span class="line">Number n1, n2, x, y;</span><br><span class="line">n1 = new One();</span><br><span class="line">n2 = new Two();</span><br><span class="line">x = this.id(n1);</span><br><span class="line">y = this.id(n2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>1-object</code>的时候因为这里两次调用<code>id</code>函数都是在<code>c</code>对象下的因此导致<code>c:n1</code>和<code>c&#39;:n2</code>都指向<code>c_this</code>函数从而引入虚假信息，而<code>1-call-site</code>则因为是两个<code>call-site</code>因此更加精确。</p><p>故本质上很多时候指针分析本质和语言的性质有非常密切的关系。</p><h5 id="Type-sensitivity"><a href="#Type-sensitivity" class="headerlink" title="Type sensitivity"></a>Type sensitivity</h5><p>该版本的<code>context</code>使用一系列<code>InType</code>组成，不深入了。</p><p>至此指针分析的学习结束。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;过程间分析需要基于程序的&lt;code&gt;Call Graph&lt;/code&gt;来完成。由于&lt;code&gt;CHA Analysis&lt;/code&gt;过度追求速度造成误报——而&lt;code&gt;false positive&lt;/code&gt;对于常量传播这样的&lt;code&gt;must&lt;/code&gt;分析来说是不可接受的。因此指针分析在&lt;code&gt;POPL&amp;#39;1980&lt;/code&gt;被第一次提出&lt;a href=&quot;https://static.aminer.org/pdf/PDF/000/546/844/interprocedural_data_flow_analysis_in_the_presence_of_pointers_procedure.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure Variables, and Label Variables&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;Pointer Analysis computes an over-approximation of the set of which memory-locations(objects) a pointer can point to.  &lt;/p&gt;
&lt;p&gt;指针分析除了可以构建&lt;code&gt;Call Graph&lt;/code&gt;等程序基本信息之外，还可以用于编译优化，程序鲁棒性和安全等各个领域，是最基础的静态分析算法之一——比如流行的别名分析&lt;code&gt;Alias Analysis&lt;/code&gt;就是从指针分析中派生出来的:Alias information can be derived from points-to relations.在指针分析的输出指向关系中是否有两个指针可以指向同一个对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(2-CHA-Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/05/10/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-2-CHA-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/05/10/NJU静态程序分析-2-CHA-Analysis/</id>
    <published>2021-05-10T10:23:58.000Z</published>
    <updated>2022-03-16T10:12:10.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>根据<code>safe-approximation</code>，过程内数据流分析<code>Intraprocedural</code>对所有的函数调用<code>method call</code>做出过度保守的假设——即所有分析结果必须<code>safe</code>，而根据<code>Lattice</code>理论这种处理会使<code>must</code>和<code>may</code>分析都变的<code>less precise</code>。所以引入<strong>过程间数据流分析</strong><code>Interprocedural Analysis</code>，通过<code>Call Graph</code>来实现过程间的数据流传递，从而进一步提高分析的精度。<strong>因此如何构造这些<code>call-graph</code>就是过程间分析的关键环节。</strong></p><p>For Better precision, we need Interprocedural Analysis：propagate data-flow information along <strong>interprocedural control-flow edges</strong> i.e., call and return edges</p><p><code>Class hierarchy analysis</code>是用来构造<code>Call Graph</code>的一种经典方法——也是过程间分析的基础。</p><a id="more"></a><h3 id="CHA"><a href="#CHA" class="headerlink" title="CHA"></a>CHA</h3><p>从下面开始我们开始研究包含函数调用的程序——调用图反映了程序中的调用关系<code>calling relationships</code>，确切的说就是<strong>一系列从调用点<code>call-sites</code>指向目标方法<code>callees</code>的边的集合</strong>，可以看出<code>Call Graph</code>是极其重要的程序信息。</p><p>如何构造<code>Call Graph</code>？鉴于<code>OOPLs</code>语言是目前软件领域绝对的领导者，因此本节课也主要针对<code>Java</code>来构造调用图。一共有四种构造算法:</p><ul><li>Class hierarchy analysis(CHA)</li><li>Rapid type analysis(RTA)</li><li>Variable type analysis(VTA)</li><li>Pointer analysis(k-CFA)</li></ul><p>它们的分析精度从上到下越来越准确，而分析时间也相应的越来越长，这里主要介绍第一种CHA。</p><h4 id="Methods-Calls-invocations-in-Java"><a href="#Methods-Calls-invocations-in-Java" class="headerlink" title="Methods Calls(invocations) in Java"></a>Methods Calls(invocations) in Java</h4><div class="table-container"><table><thead><tr><th></th><th>Static call</th><th>Special call</th><th>Virtual call</th></tr></thead><tbody><tr><td>Instruction</td><td>Invokestatic</td><td>Invokespecial</td><td>Invokeinterface/invokevirtual</td></tr><tr><td>Receiver objects</td><td>⨉</td><td>✓</td><td>✓</td></tr><tr><td>Target methods</td><td>Static methods</td><td>constructors/private instance methods/superclass instance methods</td><td>Other instance methods</td></tr><tr><td>#Target methods</td><td>1</td><td>1</td><td>≥1(<font color="red">polymorphism</font>)</td></tr><tr><td>Determinacy</td><td>Compile-time</td><td>Compile-time</td><td>Run-time</td></tr></tbody></table></div><p>Java的函数调用主要分为三种类型。其中<code>static call</code>调用静态方法因此没有<code>instance</code>实例，而编译器在编译期就可以解析出函数地址。<code>special call</code>有三个目标函数——构造函数，私有成员函数以及父类函数，因为该调用的<code>receiver object</code>类型确定所以也可以再编译期确定。难点在于虚函数调用，<strong>所谓运行时绑定指的是只有在运行时才可以确定其目标函数（多态），</strong>因此构造调用图的关键就在于对虚函数调用完成构建。</p><h4 id="Method-Dispatch"><a href="#Method-Dispatch" class="headerlink" title="Method Dispatch"></a>Method Dispatch</h4><p>一个虚函数调用<font color="blue">o<sup>1</sup>.foo(…)<sup>2</sup></font>在运行时根据两点被解析：</p><ul><li><code>Receiver object</code>的类型，即变量o指向的对象类型</li><li>在<code>call site</code>的函数签名，即foo(…)</li></ul><p>关于对象类型，是变量指向的实际类型——比如<code>A x = new B()</code>和<code>B x = new B()</code>的<code>receiver objecte</code>类型都是<code>B</code>。关于函数签名<code>signatrue</code>的功能就是能唯一代表一个函数：</p><ul><li>Signatrue = <font color="red">class type</font> + <font color="blue">method name</font> + <font color="green">descriptor</font></li><li><font color="green">Descriptor</font> = <font color="green">return type</font> + <font color="green">parameter types</font></li></ul><p>比如<code>class C{T foo(P p, Q q, R r){...}}</code> 中函数foo的函数签名可以写成<code>C.foo(P, Q, R)</code>。</p><p>接着引入函数<font color="red">Dispatch</font>(c, m)来模拟运行时函数自动绑定的过程：</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>其中<code>c</code>是<code>receiver object</code>的类型，而<code>m</code>就是<code>call sites</code>的函数签名。<code>Dispatch</code>函数在<code>c</code>中寻找和函数签名<code>m</code>相符合的<strong>非抽象函数<code>non-abstract method</code></strong>，如果没有找到则去<code>c</code>的父类中继续找直到找到为止，该函数是CHA分析的核心。</p><h4 id="CHA-1"><a href="#CHA-1" class="headerlink" title="CHA"></a>CHA</h4><p><code>CHA</code>是Jeffrey Dean在ECOOP上提出来的一种优化算法<a href="https://www.researchgate.net/profile/David-Grove/publication/2509356_Optimization_of_Object-Oriented_Programs_Using_Static_Class_Hierarchy_Analysis/links/0912f50b6c1a600bb9000000/Optimization-of-Object-Oriented-Programs-Using-Static-Class-Hierarchy-Analysis.pdf?origin=publication_detail" target="_blank" rel="noopener">Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis</a>。  </p><p><strong>该算法可以根据<code>receiver object</code>的声明类型（区别于实际类型）来解析虚函数调用。</strong>它需要整个程序的继承链作为信息基础，比如<code>A a = ...;  a.foo()</code>中该算法假设变量<code>a</code>可以指向<code>class  A</code>及其所有子类，据此解析出多个可能的目标方法。下面是CHA的算法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Resolve(cs) &#123;</span><br><span class="line">T = &#123;&#125;</span><br><span class="line">m = method signature at cs</span><br><span class="line">if cs is a static call then</span><br><span class="line">T = &#123;m&#125;</span><br><span class="line">if cs is special call then</span><br><span class="line">c_m = class type of m</span><br><span class="line">T = &#123;Dispatch(c_m, m)&#125;</span><br><span class="line">if cs is a virtual call then</span><br><span class="line">c = declared type of receiver variable at cs</span><br><span class="line">foreach c&apos; that is a subclass of c or c itself do</span><br><span class="line">add Dispatch(c&apos;, m) to T</span><br><span class="line">return T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对<code>Java</code>的三种调用类型都做了解析，参数<code>cs</code>是程序中的调用点——即每一种调用实际发生的地方。<code>static call</code>可以直接根据函数签名得到目标函数；对于<code>special call</code>由于进行<code>super-call</code>调用的时候需要进一步解析父类中的函数（还不能保证父类一定存在函数需要进一步上升）所以使用了<code>Dispatch</code>函数。  </p><p><strong>虚函数调用只需要拿到在<code>call-site</code>处<code>receiver variable</code>的声明类型，然后对该类型以及该类型的所有子类对象做Dispatch解析即可。</strong></p><p>该算法只考虑调用点处<code>reveriver variable</code>的类型和它的继承链而忽略了其他数据流和控制流信息，因此速度上非常快，但是精度一般。故其主要应用就是IDE的补全上，满足速度快贴合需求但是精度也保持在一个很好的接受范围内。</p><h4 id="Call-Graph-Construction"><a href="#Call-Graph-Construction" class="headerlink" title="Call Graph Construction"></a>Call Graph Construction</h4><p>在CHA分析的基础上，我们可以设计出构造调用图<code>Call Graph</code>的完整算法，该算法应用<code>BFS</code>的思路从<code>entry</code>出发对每一个<code>method</code>，解析该函数在所有调用点<code>cs</code>的目标方法<code>Resolve(cs)</code>直到所有的<code>method</code>都完成解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BuildCallGraph(m_entry) &#123;</span><br><span class="line">WL = [m_entry], CG = &#123;&#125;, RM = &#123;&#125;</span><br><span class="line">while WL is not empty do</span><br><span class="line">remove m from WL</span><br><span class="line">if m ∉ RM then</span><br><span class="line">add m to RM</span><br><span class="line">foreach call-site cs in th m do     // Resolve target methods via CHA</span><br><span class="line">T = Resolve(cs)</span><br><span class="line">foreach traget method m&apos; in T do</span><br><span class="line">add cs ⟶ m&apos; to CG    // Add call edges to call graph</span><br><span class="line">add m&apos; to WL</span><br><span class="line">return CG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>WL包含即将被解析的<code>method</code></li><li>CG包含构建出来的调用边<code>call-edges</code>集合</li><li>RM包含已经解析完成的<code>method</code></li></ul><h3 id="Inter-procedural-Control-Flow-Graph"><a href="#Inter-procedural-Control-Flow-Graph" class="headerlink" title="Inter-procedural Control-Flow Graph"></a>Inter-procedural Control-Flow Graph</h3><p>构建<code>Call Graph</code>的目的就是为了进一步构建<code>ICFG</code>，如果说<code>CFG</code>表示单个函数的结构，那<code>ICFG</code>表示的就是整个程序的结构。有了<code>ICFG</code>我们就可以进行过程间分析了，<code>ICFG</code>主要由两部分构成:</p><ul><li>程序中所有函数的CFG </li><li>两种新加的edges<ul><li>Call edges: 从<code>call-site</code>指向<code>callees</code>的<code>entry</code></li><li>Return edges: 从<code>callees</code>的返回语句指向<code>return-site</code>(紧跟着<code>call-site</code>的语句)</li></ul></li></ul><p><img src="2.png" width="50%" height="50%" alt=""></p><p>而这两种新加的边信息就来自于<code>Call Graph</code>。对于整个程序的<code>ICFG</code>，只需要将函数调用语句单独作为一个<code>Basic Block</code>即可，其他的不变。  </p><p>从上图中可以看到，数据流从<code>call-site</code>沿着<code>call edges</code>流向<code>callees</code>，接着从<code>callees</code>的返回语句流向<code>return-site</code>。<strong>而<code>call-site</code>和<code>return-site</code>之间还有一条边<code>call-to-return edge</code>是为了传递本地函数的数据流，</strong>以免这些信息跟着<code>call graph</code>绕远路。</p><h3 id="Inter-procedural-Data-Flow-Analysis"><a href="#Inter-procedural-Data-Flow-Analysis" class="headerlink" title="Inter-procedural Data-Flow Analysis"></a>Inter-procedural Data-Flow Analysis</h3><p>在构建好<code>ICFG</code>之后，就可以进行过程间数据流分析了。  </p><p>这里对比过程内<code>Intraprocedural</code>和<code>Interprocedural</code>两种分析：</p><div class="table-container"><table><thead><tr><th></th><th><font color="red">Intra</font>procedural</th><th><font color="red">Inter</font>procedural</th></tr></thead><tbody><tr><td>Program representation</td><td>CFG</td><td>ICFG = CFGs + <font color="red">call &amp; return edges</font></td></tr><tr><td>Transfer functions</td><td>Node transfer</td><td>Node transfer + <font color="red">edge transfer</font></td></tr></tbody></table></div><p>可以看到过程间分析比过程内分析多了一些<code>edge analysis</code>。从理论上看这些<code>edge analysis</code>完成了函数调用过程中的跨函数数据流比如参数，返回值的传递。</p><ul><li>Call edge transfer: 传递参数（从call-site到entry of callee）</li><li>Return edge transfer: 传递返回值(从return ofcallee到return-site)</li></ul><p>而过程间分析和过程内分析的<code>Transfer Function</code>相比，多了一条规则：</p><p>For each call node(call-site), kill data-flow value for the LHS variable. Its value will flow to return site along the return edges.</p><p>即要<code>kill</code>掉调用点语句的<strong>左值变量</strong>。</p><p>&lt;img src=3.png” width=”50%” height=”50%” alt=””&gt;</p><p>因为左值的数据流会在<code>callee</code>中得到更新最终沿着<code>return edge</code>传递，而如果该值在<code>call-to-return edge</code>中继续传递下去，在<code>merge</code>的时候回损失精度比如常量传播中c<sub>1</sub> ⊓ c<sub>2</sub> = NAC。故拿常量传播来说的话，<code>Interprocedural constant propagation</code>要比<code>Intraprocedural constant propagation</code>更加精确。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;根据&lt;code&gt;safe-approximation&lt;/code&gt;，过程内数据流分析&lt;code&gt;Intraprocedural&lt;/code&gt;对所有的函数调用&lt;code&gt;method call&lt;/code&gt;做出过度保守的假设——即所有分析结果必须&lt;code&gt;safe&lt;/code&gt;，而根据&lt;code&gt;Lattice&lt;/code&gt;理论这种处理会使&lt;code&gt;must&lt;/code&gt;和&lt;code&gt;may&lt;/code&gt;分析都变的&lt;code&gt;less precise&lt;/code&gt;。所以引入&lt;strong&gt;过程间数据流分析&lt;/strong&gt;&lt;code&gt;Interprocedural Analysis&lt;/code&gt;，通过&lt;code&gt;Call Graph&lt;/code&gt;来实现过程间的数据流传递，从而进一步提高分析的精度。&lt;strong&gt;因此如何构造这些&lt;code&gt;call-graph&lt;/code&gt;就是过程间分析的关键环节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For Better precision, we need Interprocedural Analysis：propagate data-flow information along &lt;strong&gt;interprocedural control-flow edges&lt;/strong&gt; i.e., call and return edges&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Class hierarchy analysis&lt;/code&gt;是用来构造&lt;code&gt;Call Graph&lt;/code&gt;的一种经典方法——也是过程间分析的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(1-Data Flow Analysis)</title>
    <link href="http://haotianmcihael.github.io/2021/05/04/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-1-Data-Flow-Analysis/"/>
    <id>http://haotianmcihael.github.io/2021/05/04/NJU静态程序分析-1-Data-Flow-Analysis/</id>
    <published>2021-05-03T16:12:53.000Z</published>
    <updated>2022-03-16T10:20:48.443Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>编译器中大部分机器无关的全局优化是基于<code>Data-flow Analysis</code>实现的。数据流分析技术从代码中收集程序语义相关的信息，是程序分析的基础。</p><p><strong>In each data-flow analysis application, we associate with every program point a data-flow value that represents an abstraction of the set of all possible program states that can be observed for that point.</strong></p><p>在工业界的<a href="https://www.zhihu.com/question/41959902" target="_blank" rel="noopener">主流编译器</a>中，<code>C</code>系的<code>LLVM</code>，<code>Java</code>系的<code>HotSpot</code>都是基于<code>SSA</code>做数据流分析而不是传统的<code>lattice</code>。南大这节课中是基于<code>Lattice</code>来讲解过程内<code>Intra-procedural</code>，无别名<code>no aliases</code>的经典数据流分析框架。</p><a id="more"></a><h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><h5 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h5><p>分析框架都是建立在<code>control-flow-graph</code>上的，这是一种<code>IR</code>——由<code>basic-blocks</code>通过<code>control-flows</code>连接而成，可以分别看成是<code>CFG</code>的<code>nodes</code>和<code>edges</code>。  如何通过源码（单个函数）生成<code>CFG</code>见课件。</p><p><img src="1.png" width="50%" height="50%" alt=""></p><h5 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h5><p>数据流分析用来描述所谓<strong>数据</strong>如何在<strong>CFG</strong>中流动。这里的<code>data</code>指的是程序语义信息的一种<code>abstraction</code>，<code>CFG</code>中的<code>nodes</code>和<code>edges</code>分别映射<code>transfer-function</code>和<code>control-flow handling</code>。所以整个分析是建立在一套成熟的理论框架之上的。</p><ul><li><code>data(application-specific)</code>: 不同的数据流分析应用会有不同的抽象值<code>value</code>，比如分析变量数值时：<code>+;-;0;UND;UNKNOW;</code><ul><li><code>domain</code>: 抽象数据流的值域即所有<code>value</code>定义的集合</li></ul></li><li><code>transfer-functions</code>:不同的程序会有不同的<code>CFG</code>表示，进一步需要深刻<code>CFG</code>中<code>statements</code>，<code>basic-blocks</code>在被映射成<code>transfer-functions</code>时的区别和联系</li><li><code>control-flows</code>:控制流基本上只有三个——顺序，汇聚以及分流</li></ul><h5 id="safety-analysis"><a href="#safety-analysis" class="headerlink" title="safety analysis"></a>safety analysis</h5><p>大部分的分析框架要求分析结果是<code>Sound</code>的即<code>over-approximation</code>。而实际上并非所有如此——这里正式将所有分析分成两类：<code>may analysis</code>和<code>must analysis</code>。</p><ul><li><code>may analysis</code>: 要求分析结果中必须全部包含所有正确答案，换个角度理解就是<strong>不放过任何一个动态运行时的可能出错的行为</strong>——一旦发现就要报错，即<code>over</code>的概念</li><li><code>must analysis</code>: 要求分析结果一定是正确的，即不能有误报，即<code>under</code>的概念</li></ul><p>而<code>over</code>和<code>under</code>在不同的应用中都代表了各自最<code>safe</code>的结果，因此所有的静态程序分析可以总结成：<code>abstraction</code>和<code>safe-approximation</code>两个阶段，不同的数据流分析有不同的<code>abstraction</code>和<code>safe-approximation strategies</code>即不同的<code>transfer-functions</code>和<code>control-flow handlings</code>。</p><h4 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h4><h5 id="Input-and-Output-States"><a href="#Input-and-Output-States" class="headerlink" title="Input and Output States"></a>Input and Output States</h5><p>所有的操作对象都是在一个<code>CFG</code>中。  </p><p><code>statements</code>  是<code>CFG</code>中的执行的最小单位——每一条<code>statements</code>的执行都会改变程序的状态。 </p><p><strong>每一个<code>statements</code>前后都有自己的<code>program point</code>分别代表<code>input/output state</code>，记作<code>IN[S_i]/OUT[S_i]</code>。又因为一个<code>basic-blocks</code>中的所有<code>statements</code>可以结合在一起（因为BB内部只能顺序执行）故每个<code>basic-blocks</code>开始和结束也有自己的<code>program point</code>，记作<code>IN[B_i]/OUT[B_i]</code>。</strong>  </p><p><code>control flow</code>表示了各个<code>basic-blocks</code>的执行顺序关系。分为三种：顺序，汇聚和分流</p><p><img src="2.png" width="50%" height="50%" alt=""></p><ul><li>顺序：<code>IN[s2] = OUT[s1]</code></li><li>汇聚:  <code>IN[s2] = OUT[s1] ^ OUT[s3]</code><ul><li>操作符<code>^</code>指的是<code>meet operator</code>，不同的算法有不同操作比如并集，交集等</li></ul></li><li>分流:  <code>IN[s2] = IN[s3] = OUT[s1]</code></li></ul><p><strong>需要关注的是每个BB或者Statement的<code>program point</code>，数据流分析会给每个<code>program point</code>一个<code>data-flow value</code>来抽象出当前位置程序的部分语义信息，再进一步利用各种<code>safe-approximation-directed constraints</code>以达到分析目的，这里的<code>constraints</code>具体指的是不同的<code>transfer functions</code>和<code>control flow handlings</code>。</strong></p><h5 id="Notations-for-Transfer-Functions’-Constraints"><a href="#Notations-for-Transfer-Functions’-Constraints" class="headerlink" title="Notations for Transfer Functions’ Constraints"></a>Notations for Transfer Functions’ Constraints</h5><ul><li><p>Forward Analysis： OUT[s] = F_s(IN[s]),其中F_s就是针对具体输入的<code>Transfer Function</code>，前向分析是从输入推导输出</p><p><img src="3.png" width="50%" height="50%" alt=""></p></li><li><p>Backward Analysis：IN[s]  = F_s(OUT[s]),后向分析是从输出推导输入</p><p><img src="4.png" width="50%" height="50%" alt=""></p></li></ul><h5 id="Notations-for-Control-Flows’-Constraints"><a href="#Notations-for-Control-Flows’-Constraints" class="headerlink" title="Notations for Control Flows’ Constraints"></a>Notations for Control Flows’ Constraints</h5><h6 id="control-flow-within-a-BB"><a href="#control-flow-within-a-BB" class="headerlink" title="control flow within a BB"></a>control flow within a BB</h6><p>在一个BB内部，<code>IN[S_(i+1)] = OUT[S_(i)], for all i = 1, 2,...n-1</code>——这个很好理解，一个BB中的<code>statements</code>只能顺序执行故只会有一个输入输出。</p><h6 id="control-flow-among-BBs"><a href="#control-flow-among-BBs" class="headerlink" title="control flow among BBs"></a>control flow among BBs</h6><p>对于一个<code>basic block</code>来说：<code>IN[B] = IN[S_1];   OUT[B] = OUT[S_n]</code>。  而BB之间的执行不仅仅是顺序关系。还有汇聚和分流的执行顺序。  </p><p>首先是汇聚：<code>OUT[B] = F_b(IN[B])</code>，其中<code>F_b = F_sn * ...* F_s2 * F_s1</code>也就是一个BB的的<code>Transfer Function</code>由内部<code>statements</code>各自的<code>transfer function</code>组成，<code>IN[B] = ^ OUT[P]</code>，表示所有汇聚的输出的并集都成为下一个的输入，这里的<code>^</code>就是表示并集的<code>meet operator</code>而<code>P</code>表示<code>B</code>的所有前驱<code>basic blocks</code>。  </p><p> <img src="5.png" width="50%" height="50%" alt=""></p><p>其次是分流：<code>IN[B] = F_b(OUT[B])</code>;<code>OUT[B] = ^IN[S]</code>这里表示<code>B</code>的输出都成为所有<code>S</code>的输入，<code>S</code>是<code>B</code>的所有后继。</p><p> <img src="6.png" width="50%" height="50%" alt=""></p><p>有了前面的基础，下面先介绍三种经典的数据流分析算法：</p><h4 id="Reaching-Definitions-Analysis"><a href="#Reaching-Definitions-Analysis" class="headerlink" title="Reaching Definitions Analysis"></a>Reaching Definitions Analysis</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>A definition d at <strong>program point</strong> p reaches a point q if <strong>there is</strong> a path from p to q such that d is not “killed” along that path.(A definition of a variable is a statement that assigns a value to v).</p><p><img src="7.png" width="50%" height="50%" alt=""></p><p>首先<strong><code>definition</code>-定义</strong>指的是对变量<code>v</code>进行赋值的语句。一般来讲<strong>定义</strong>都是从一个<code>program point</code>上完成的。</p><p>在p点上的，一个对变量<code>v</code>的<code>definition</code>能<code>reach</code>到某一个新的点q，取决于在控制流上是否<strong>存在</strong>一条从p到q的路径，同时在这条路径上该变量<code>v</code>不会被重新定义，就说是这个<code>definition</code>可以reach到q点。  </p><h5 id="分析类型"><a href="#分析类型" class="headerlink" title="分析类型"></a>分析类型</h5><p>从定义的<code>there is</code>可以看出，这是一个<code>may analysis</code>——即控制流上从p到q的所有路径而言，只需要有一条路径没有被重新定义，那这两个<code>program point</code>之间就是<code>Reached</code>的。并且还知道这是一个<code>forward analysis</code>——因为是前面的<code>program point</code>上的<code>definition</code>可以<code>reach</code>到后面的<code>program point</code>。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><p>该分析可以用来<strong>检查未定义的变量</strong>。对于所有需要检测的变量，在<code>CFG</code>的<code>entry</code>入口处都赋值为<code>dummy definition</code>——实际上就是一个<code>undefined</code>的标签，如果变量<code>v</code>的可以<strong>到达</strong>某一个使用点，那这个变量就有可能是未定义前使用。</p><h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><h6 id="Data-Flow-Values-Fact"><a href="#Data-Flow-Values-Fact" class="headerlink" title="Data Flow Values/Fact"></a>Data Flow Values/Fact</h6><p>首先数据流分析需要对分析的对象进行抽象，<strong>这里使用<code>BitVector</code>来表示一个<code>CFG</code>（即一段过程内程序中）上所有变量的<code>definition</code>。</strong>（注意关注对象<code>definition</code>不是变量本身，而是定义这个变量的所有<code>program point</code>。）</p><h6 id="Transfer-Function"><a href="#Transfer-Function" class="headerlink" title="Transfer Function"></a>Transfer Function</h6><p>根据<code>IN</code>求出每一个<code>statemetns/basic blocks</code>的<code>OUT</code>的。由该分析的目的可以得出：<code>OUT[B] = gen_B ∪ (IN[B] - kill_B)</code>，即对于每一个<code>program point</code>来说，其<code>OUT</code>就是在该点处新增加的对变量的<code>definitions</code>除掉别处这些变量的<code>definitions</code>。</p><h6 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h6><p>根据上一个<code>statements/basic blocks</code>的<code>OUT</code>求出下一个的<code>IN</code>。因为作为<code>may</code>分析，其不放过任何一个运行时的行为，所以针对所有留到该<code>IN</code>的<code>OUT</code>都要接收。即<code>IN[B] = ∪_p(p是B所有的前驱结点)OUT[P]</code>。</p><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INPUT: CFG(kill_B and gen_B computed for each basic blocks B)</span></span><br><span class="line"><span class="comment">OUTOUT: IN[B] and OUT[B] for each basic block B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">OUT[entry] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (each basic block B\entry)</span><br><span class="line">OUT[B] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(changes to ant OUT occur) </span><br><span class="line"><span class="keyword">for</span>(each basic blocks B\entry) &#123;</span><br><span class="line">   IN[B] = ∪_OUT[P];</span><br><span class="line">   OUT[B] = gen_B ∪ (IN[B] - kill_B);      </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这是非常典型的<strong>不动点算法</strong>，如果我们简化模型仅仅只是关注每一个<code>basic blocks</code>的<code>IN</code>和<code>OUT</code>,会发现对于有限的<code>definition</code>集合，在经过多次迭代之后，正向的增加<code>gen/survivors</code>一定会导致<code>OUT</code>达到一个定值。</p><h4 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>Live variables analysis tells whether the value of variable v at program point p <strong>could be used </strong>along some path in CFG starting at p. If so, v is live at p; otherwise, v is dead at p.</p><p><img src="8.png" width="50%" height="50%" alt=""></p><p>分析<strong>变量<code>v</code>在一个<code>program point</code>-p上是否是活跃的</strong>，取决于是否存在一条从p点开始一直到程序执行结束的路径，该路径中有使用过<code>v</code>的地方，<strong>并且从p点到使用点期间<code>v</code>不可以被重新定义</strong>——则说明该变量<code>v</code>在p点是活跃的。</p><h5 id="分析类型-1"><a href="#分析类型-1" class="headerlink" title="分析类型"></a>分析类型</h5><p>根据定义可以知道这是一个<code>may</code>分析，该变量只要有使用点则分析结果就是活跃的。又因为分析的过程是从后往前的故该分析也是一个<code>backward analysis</code>。</p><h5 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h5><p>该分析可以用来完成<strong>寄存器分配</strong>。比如在执行到程序的某一点需要将操作数加载到其中一个寄存器中——而这时候所有的<code>registers</code>都满了。如何选择合适的寄存器呢？如果选择的是一个<code>dead</code>不活跃的寄存器值（未来不会被用到），那就可以直接替换掉。而如果这个寄存器中的变量值是活跃的，那后面再次使用到的时候就需要把它再次从内存读到寄存器，浪费了资源。</p><h5 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h5><h6 id="Data-Flow-Value-Fact"><a href="#Data-Flow-Value-Fact" class="headerlink" title="Data Flow Value/Fact"></a>Data Flow Value/Fact</h6><p>该分析关注的对象，<strong>就是变量本身</strong>，使用<code>BitVector</code>表示。</p><h6 id="Transfer-Function-1"><a href="#Transfer-Function-1" class="headerlink" title="Transfer Function"></a>Transfer Function</h6><p><code>IN[B] = use_B ∪ (OUT[B] - def_B)</code>。这里的<code>use_B</code>指的是<strong>所有在重新定义之前变量的使用点，</strong>通过<code>backward</code>的思路来分析，对于一个<code>basic block</code>，给出其<code>OUT</code>来得到其<code>IN</code>需要关注在BB中变量是否是满足活跃的前提要求的。</p><p><img src="9.png" width="50%" height="50%" alt=""></p><h6 id="Control-Flow-1"><a href="#Control-Flow-1" class="headerlink" title="Control Flow"></a>Control Flow</h6><p>因为作为<code>may</code>分析，其不放过任何一个运行时的行为，所以针对所有留到该<code>IN</code>的<code>OUT</code>都要接收。即<code>IN[B] = ∪_s(s是B所有的前驱结点)OUT[s]</code>。</p><h5 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INPUT: CFG(def_B and use_B computed for each basic blocks B)</span></span><br><span class="line"><span class="comment">OUTOUT: IN[B] and OUT[B] for each basic block B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IN[<span class="built_in">exit</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (each basic block B\<span class="built_in">exit</span>)</span><br><span class="line">IN[B] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(changes to ant IN occur) </span><br><span class="line"><span class="keyword">for</span>(each basic blocks B\<span class="built_in">exit</span>) &#123;</span><br><span class="line">OUT[B] = ∪_IN[S];</span><br><span class="line">OUT[B] = use_B ∪ (OUT[B] - def_B);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将两个算法的<code>Transfer Func</code>放到一起对比：</p><ul><li>RDA: <code>OUT[B] = gen_B ∪ (IN[B] - kill_B)</code></li><li>LVA: <code>IN[B] = use_B ∪ (OUT[B] - def_B)</code></li></ul><p>会发现很多的数据流分析算法都是<code>GEN/KILL Problem</code>，统计一下公式就是<code>OUT = gen ∪ (IN - kill)</code>。</p><h4 id="Available-Expressions-Analysis"><a href="#Available-Expressions-Analysis" class="headerlink" title="Available Expressions Analysis"></a>Available Expressions Analysis</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>An expression x op y is available at program point p if (1) <strong>all paths </strong>from the entry to p must pass through the evaluation of x op y, and (2) <strong>after the last evaluation of x op y, there is no redefinition of x or y</strong>.</p><p><img src="10.png" width="50%" height="50%" alt=""></p><p>在<code>CFG</code>上的所有的复合型表达式都会被拆成三地址码。<strong>判断一个<code>expression</code>-<code>x op y</code>在p点是<code>available</code>的</strong>，取决于从<code>entry</code>到<code>p</code>点所有的路径都必须有该表达式的<code>evaluation</code>求值，并且在最后一个求值之后不能对<code>x/y</code>重新赋值，即就说这个表达式在p点事<code>available</code>的。</p><h5 id="分析类型-2"><a href="#分析类型-2" class="headerlink" title="分析类型"></a>分析类型</h5><p>必须保证所有的<code>path</code>都有<code>evaluation of expression</code>分析结果才是<code>available</code>。因此这是一个<code>must</code>分析，即不能有误报但可以有漏报，比如下图中的情况，假设<code>x = 3</code>前后都成立那么实际上这个表达式也是可以被优化的，但是根据该<code>must</code>分析的定义这个分析结果是<code>not avaliable</code>的。</p><p><img src="11.png" width="50%" height="50%" alt=""></p><h5 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h5><p>该分析可以用来进行<strong>公共子表达式删除</strong>，即用<code>the last evaluation of available expression</code>直接替换该表达式，从而优化代码。</p><h5 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h5><h6 id="Data-Flow-Value-Fact-1"><a href="#Data-Flow-Value-Fact-1" class="headerlink" title="Data Flow Value/Fact"></a>Data Flow Value/Fact</h6><p>顾名思义就是程序中所有的<code>expression</code>。</p><h6 id="Transfer-Function-2"><a href="#Transfer-Function-2" class="headerlink" title="Transfer Function"></a>Transfer Function</h6><p>根据定义<code>OUT[B] = gen_B ∪ (IN[B] - kill_B)</code>，对于所有的输入的表达式，产生的新表达式并且删除掉在其变量被重新赋值的表达式。</p><h6 id="Control-Flow-2"><a href="#Control-Flow-2" class="headerlink" title="Control Flow"></a>Control Flow</h6><p>因为是<code>must</code>分析对于所有的情况都要考虑，所以<code>IN[B] = ∩(p:predecessors of B)OUT[p]</code>。</p><h5 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INPUT: CFG(kill_B and gen_B computed for each basic blocks B)</span></span><br><span class="line"><span class="comment">OUTOUT: IN[B] and OUT[B] for each basic block B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">out[entry] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (each basic block B\entry)</span><br><span class="line">OUT[B] = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(changes to ant OUT occur) </span><br><span class="line"><span class="keyword">for</span>(each basic blocks B\entry) &#123;</span><br><span class="line">IN[B] = ∪_IN[P];</span><br><span class="line">OUT[B] = gen_B ∪ (OUT[B] - kill_B);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于这三种分析来说，如何理解<code>may/must</code>，<code>false positive/false negative</code>和在所有<code>CFG</code>上程序的运行时行为之间的关系是很关键的问题。</strong></p><h3 id="Foundations"><a href="#Foundations" class="headerlink" title="Foundations"></a>Foundations</h3><h4 id="Mathematics-Prerequisite"><a href="#Mathematics-Prerequisite" class="headerlink" title="Mathematics Prerequisite"></a>Mathematics Prerequisite</h4><h5 id="Partial-Order"><a href="#Partial-Order" class="headerlink" title="Partial Order"></a>Partial Order</h5><p>定义<code>poset</code>偏序集<code>(P, ≼)</code>表示一个集合<code>p</code>，符号<code>≼</code>定义在该集合的<code>partial ordering</code>有如下性质：</p><ul><li><em>Reflexivity</em>. ∀ x∊P, x≼x  </li><li><em>Antisymmetry.</em> ∀ x,y∊P, x≼y ∧ y≼x ⟹ x=y.</li><li><p><em>Transitivity</em>. ∀ x,y,z∊P, x≼y ∧ y≼z ⟹ x≼z.</p><p>如何理解偏序-<code>partial ordering</code>？<strong>在集合<code>p</code>中定义了一种<code>order</code>，但并不是所有两个元素之间都必须满足这种<code>order</code>——即集合中两个元素之间可以是<code>incomparable</code>的</strong>。比如<code>power set</code>是非常典型的<code>poset</code>。</p></li></ul><p><img src="12.png" width="50%" height="50%" alt=""></p><h5 id="Upper-and-Lower-Bounds"><a href="#Upper-and-Lower-Bounds" class="headerlink" title="Upper and Lower Bounds"></a>Upper and Lower Bounds</h5><p>给定偏序集<code>(P, ≼)</code>以及该集合的一个子集<code>S ⊆ P</code>。我们使用集合<code>P</code>中的<strong>一个元素<code>u ∊ P</code></strong>来定义<strong>集合<code>S</code>的<code>upper bound</code>和<code>lower bound</code>:</strong></p><ul><li>∀x∊S, x≼u ⟹ u∊P is an <em>upper bounds</em> of S</li><li>∀x∊S, l≼x ⟹ l∊P is an <em>lower bound</em> of S</li></ul><p>在此基础上，我们进一步定义<strong>集合<code>S</code>的<code>least upper bound(lub or join)</code>简写为<code>⊔S</code>，以及<code>greatest lower bound(glb or meet)</code>简写为<code>⊓S</code>:</strong></p><ul><li>for every <em>upper bound</em> of S, say u: <code>⊔S ≼ u</code></li><li>for every <em>lower bound</em> of S, say l:<code>l ≼ ⊓S</code></li></ul><p>根据<code>⊔S/⊓S</code>的定义，如果集合<code>S</code>中只有两个元素<code>a and b</code>。那么：</p><ul><li><code>⊔S</code> ≡ <code>a ⊔ b</code>(a和b的并集)</li><li><code>⊓S</code> ≡ <code>a ⊓ b</code>（a和b的交集）</li></ul><p><strong>不是所有的偏序集都有<code>⊓S/⊔S</code>，但是如果一个偏序集同时有<code>⊔S/⊓S</code>的话，那该偏序集就是唯一的。</strong></p><h5 id="Lattic"><a href="#Lattic" class="headerlink" title="Lattic"></a>Lattic</h5><p>对于一个偏序集<code>P</code>，如果集合中<strong>任意两个元素（构成的子集S）</strong><code>a</code>和<code>b</code>，它们的<code>a⊔b</code>和<code>a⊓b</code>都存在，则这个偏序集就是一个<code>lattice</code>。</p><ul><li>Given poset (P, ≼),   ∀a,b∊P,  if  ∃ a⊔b, ∃ a⊓b ∃ then P is calles a lattice</li></ul><p>在此基础上，如果这个偏序集P中的任意两个元素只有<code>a⊔b</code>或者<code>a⊓b</code>中的一个，则这个偏序集分别称为<code>join semilattice</code>和<code>meet semilattice</code>。</p><h5 id="Complete-Lattice"><a href="#Complete-Lattice" class="headerlink" title="Complete Lattice"></a>Complete Lattice</h5><p>对于一个偏序集<code>P</code>，如果集合中<strong>任意一个子集S</strong>都存在<code>⊔S</code>和<code>⊓S</code>，则这个偏序集便称为<code>complete lattice</code>。<strong>全格和格的区别主要在于，格对其子集的要求是只需要有两个元素而全格对子集元素的数量没有限制。</strong></p><p>在此基础上，对于一个<code>complete lattice</code>，都有存在：</p><ul><li>a greatest element ⊤ = ⊔P called <font color="red">top</font></li><li>a least     element ⊥ = ⊓P called <font color="blue">bottom</font></li></ul><p><strong>每一个<code>finite lattice</code>都是一个<code>complete lattice</code>。但是一个<code>complete lattice</code>却不一定是<code>finite lattice</code></strong>。</p><h5 id="Product-Lattice"><a href="#Product-Lattice" class="headerlink" title="Product Lattice"></a>Product Lattice</h5><p>给定多个<code>lattice</code>-<code>Li = (Pi, ≼i)</code>的笛卡尔积构成的一个新的<code>lattice，</code>如果这些<code>lattice</code>每一个都有<code>lub</code>和<code>glb</code>的话<strong>(这里没有说明子集S的个数主要是因为它可以是只有两个元素的普通<code>lattice</code>也可以是包括任意元素的<code>complete lattice</code>，换句话说如果一个<code>product lattice</code>是<code>complete lattice</code>的笛卡尔积，那么它本身也是一个<code>complete lattice</code>)</strong>则称其积为<code>product lattice</code>并满足下面性质:</p><ul><li>P = P1 x P2…x Pn</li><li>(x1, …, xn) ≼ (y1, …, yn) ≡ (x1 ≼ y1)∧…∧(xn≼yn)</li><li>(x1, …, xn) ⊔ (y1, …, yn) ≡ (x1 ⊔ y1)∧…∧(xn ⊔ yn)</li><li>(X1, …, xn) ⊓ (y1, …, yn) ≡ (x1 ⊓ y1)∧…∧(xn ⊓ yn)</li></ul><p>即一个<code>product lattice</code>中的每一个元素<code>lattice</code>满足的性质它都满足。</p><h4 id="Data-Flow-Analysis-Framework-via-Lattice"><a href="#Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h4><h5 id="Iterative-Algorithm"><a href="#Iterative-Algorithm" class="headerlink" title="Iterative Algorithm"></a>Iterative Algorithm</h5><p>回顾前面三个具体的数据流分析算法，即相应的<code>may/must</code>分析从各自的初始状态出发，<strong>经过不断迭代（Transfer Function/Control Flow）</strong>最终到达<strong>不动点</strong>——整个程序的数据流不会发生变化，算法停止。</p><p>这里从更具体的角度来理解这个算法：</p><p>给定一个<code>CFG</code>，其中有<code>k</code>个节点(这里简化成为只带一个<code>statement</code>的<code>basic block</code>)。<strong>而迭代算法在每次迭代中更新这k个节点的输出<code>OUT</code></strong>，引入一个<code>k-tuple</code>:</p><ul><li>(OUT[n<sub>1</sub>], OUT[n<sub>2</sub>], …, OUT[n<sub>k</sub>]) ≡ <font color="red">(V<sub>1</sub> x V<sub>2</sub> … x V<sub>k</sub>)</font></li></ul><p><strong><code>k-tuple</code>就是每一次迭代后所有节点输出值的<code>product</code>记为V<sup>k</sup>。</strong>而更具体的解释就是<strong>不同的数据流分析算法在每次迭代中通过应用各种<code>Transfer Function/Control Flow</code>来更新<code>k-tuple</code>的值——可以将每一次迭代抽象出成为一个函数:F: V<sup>k</sup>  ⟶  V<sup>k</sup></strong>。而当最后一次迭代的输出没有发生变化便到达了不动点。</p><p><img src="13.png" width="50%" height="50%" alt=""></p><p>This general <em>iterative algorithm</em> produces a solution to data flow analysis，根据<strong>函数F的一个不动点</strong>的定义：</p><ul><li>X is a <font color="yellow">fix point</font> of Function F if <font color="yellow">X = F(X)</font>&gt;</li></ul><p>可以得到<font color="red">当把每一个迭代抽象成为一个函数的时候，<code>Iterative Algorithm</code>最终会到达一个<strong>不动点</strong>，而这个<strong>不动点</strong>就是数据流分析的一个结果</font>。</p><h5 id="Data-Flow-Analysis-Framework-via-Lattice-1"><a href="#Data-Flow-Analysis-Framework-via-Lattice-1" class="headerlink" title="Data Flow Analysis Framework via Lattice"></a>Data Flow Analysis Framework via Lattice</h5><p>定义一个数据流分析框架主要有三个部分(<font color="red">D</font>, <font color="green">L</font>, <font color="blue">F</font>):</p><ul><li><font color="red">D</font>:  指的是分析的方向是<code>backwwards/forwards</code></li><li><font color="green">L</font>:  核心部分是<code>lattice</code>，代表所分析的<strong>数据流值域</strong>，和<strong>一个<code>meet⊓</code>或者<code>join⊔</code>运算符</strong>（一般一个数据流分析算法只会用到其中一个运算符——故其实是<code>semilattice</code>）</li><li><font color="blue">F</font>:  指的是分析中的<code>Transfer Functions</code></li></ul><p><strong>分析框架就可以看成是在一个<code>lattice</code>的值上不停的迭代<code>transfer functions</code>和<code>join/meet operations</code></strong>。</p><h5 id="Fixed-Point-Theorem"><a href="#Fixed-Point-Theorem" class="headerlink" title="Fixed Point Theorem"></a>Fixed Point Theorem</h5><p>在学完<strong><code>Iterative Algorithm</code></strong>以及<strong><code>Data FLow Analysis Framework</code></strong>之后，我们需要进一步理解这两者之间的关系，并更深层次的理解<strong>在<code>lattice</code>上定义的函数的不动点原理-<code>Fixed Point Theorem</code></strong>，首先对<code>Iterative Algorithm</code>提出一些核心的问题:</p><ul><li>迭代算法能保证<strong>一定会到达不定点么？</strong></li><li>假设可以到达不动点，那这个<strong>不动点是唯一的么</strong>，或者<strong>通过迭代算法到达的不动点是最精确的么？</strong> </li><li>假设可以到达不动点，那<strong>什么时候可以到达？</strong></li></ul><p>前两个问题引出了<strong>不动点理论及其存在性以及精确性</strong>。由于前面介绍的<code>Iterative Algorithm</code>也是建立在<code>Lattice</code>之上的，所以为了<strong>回答这三个<code>Iterative Algorithm</code>有关的问题，首先应该引入建立在<code>Lattice</code>上的函数并研究该函数不动点的性质，最后将这个函数与<code>Iterative Algorithm</code>联系起来。</strong></p><h6 id="Monotonicity"><a href="#Monotonicity" class="headerlink" title="Monotonicity"></a>Monotonicity</h6><p>引入<strong>在<code>Lattice</code>定义上的函数f</strong>并定义其单调性:</p><ul><li><code>f: L ⟶ L (L is a Lattice)</code> is monotonic if ∀x,y∊L,  x≼ y ⟹ f(x) ≼ f(y)</li></ul><p>在此基础上引入<code>Fixed-Point Theorem</code>:</p><font color="red">对于一个`complete lattice(L, ≼)`，如果①在其上的函数`f:L⟶L`是单调的，②L是`finite lattice`： 那么通过迭代f(⊥), f(f(⊥)), ..., f^k(⊥)可以得到`least fixed point`；  通过迭代f(⊤), f(f(⊤)), ..., f^k(⊤)可以得到`greatest fixed point`。</font><p>可以通过证明该理论来回答前两个问题。证明分为两步:</p><ul><li>不动点的存在</li><li>迭代到达最小/大不动点</li></ul><h6 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h6><blockquote><p><em>Proof-Existence of Fixed Point:</em>  </p><p>​    <em>∵ <code>⊥</code>是<code>Lattice</code>最小元素，由<code>f:L⟶L</code>的定义可知<code>f(⊥)</code>也是<code>Lattice</code>上的元素⟹ ⊥ ≼ f(⊥)</em></p><p>​    <em>∵ <code>f</code>是单调的 ⟹ f(⊥) ≼ f(f(⊥))=f<sup>2</sup>(⊥) 相似的 ⟹ ⊥≼ f(⊥) ≼ f<sup>2</sup>(⊥) … ≼ f<sup>i</sup>(⊥)</em></p><p>​    <em>∵<code>L</code>是<code>finite</code>的  ⟹ f<sup>k</sup>(⊥) = f<sup>(k+1)</sup>(⊥)</em></p><p>​    <em>∴ 不动点存在</em></p><p><em>Proof-Least Fixed Point:</em></p><p>​    <em>假设有另一个不动点<code>x</code>，⟹  <code>x = f(x)</code>, <code>⊥ ≼ x</code></em></p><p><code>Induction:</code></p><p>​    <em>∵ f 是单调的 ⟹ f(⊥) ≼ f(x)</em></p><p>​    <em>假设f^i(⊥) ≼ f<sup>i</sup>(x), ∵ f单调 ⟹ f<sup>(i+1)</sup>(⊥) ≼ f<sup>(i+1)</sup>(x)</em></p><p>​    <em>∴根据归纳法 ⟹ f<sup>i</sup>(⊥) ⟹ f<sup>i</sup>(x)</em></p><p>​    <em>∵<code>x</code>是不动点，f<sup>i</sup>(⊥) ≼ f<sup>i</sup>(x) = x， 又∵f<sup>fix</sup>=f<sup>k</sup>(⊥)是从⊥开始迭代停止的不动点 ⟹ f<sup>k</sup>(⊥) ≼ x</em></p><p>​    <em>∴f<sup>k</sup>(⊥)是唯一的最小不动点(最大不动点证明类似)</em></p></blockquote><h6 id="Iterative-and-Fixed-Point"><a href="#Iterative-and-Fixed-Point" class="headerlink" title="Iterative and Fixed-Point"></a>Iterative and Fixed-Point</h6><p> 理解数据流分析的最后一步，就是将分析的<code>Iterative Algorithm</code>与前面建立在<code>Lattice</code>上<code>Fixed-Point Theorem</code>联系起来，而关于不动点原理的前提:</p><ul><li>a complete lattice(L, ≼)， L is finite</li><li><code>f: L ⟶ L</code> is monotonic</li></ul><p>可以看出<strong>只需要将迭代算法抽象成一个个定义在<code>Lattice</code>上的单调函数即可(根据不动点原理该函数一定会达到最大/小不动点)</strong>——下面具体对<code>Iterative Algorithm</code>进行抽象:</p><p>迭代算法中的<code>CFG</code>每一个节点的输出V<sub>i</sub>都可以抽象成一个<code>Lattice</code>，<strong>故全部<code>CFG</code>的输出V<sup>k</sup>就是一个<code>product lattice</code></strong>。又因为节点是有限的，故这个<code>product lattice</code>是<code>complete lattice</code>。</p><p><img src="15.png" width="50%" height="50%" alt=""></p><p>又因为迭代算法的核心就是V<sup>k</sup>应用<code>Transfer Function</code>和<code>meet/join Function</code>完成一次又一次的迭代，<strong>这里的<code>Transfer /meet.join Function</code>可以抽象成定义在<code>Lattice</code>上的函数。</strong></p><p><img src="16.png" width="50%" height="50%" alt=""></p><p>只要保证<code>Transfer Function</code>和<code>meet/join Function</code>是单调的，就可以完成迭代算法到不动点理论的映射。  </p><p>其实所有的<code>Transfer Function</code>本质上都是<code>gen/kill problems</code>，因此简化为函数f<sub>i</sub>: L ⟶ L。其基本公式可以简化成为<font color="red">OUT[S] = gen<sub>S</sub> ⋃ (IN[S] - kill<sub>S</sub>)</font> 。从基本公式中可得:</p><ul><li>gen<sub>S</sub>和kill<sub>S</sub>是根据数据流分析算法的定义决定的，所以<strong>保持不变</strong></li><li>gen<sub>S</sub>是单调的(OUT[S]只会增加)，IN[S]要么被kill掉，要么也加入到OUT[S]中</li><li><strong>因此<code>OUT[S] never shrinks</code></strong></li></ul><p>由于输入一定是有限的(输入就是数据流比如<code>all definitions/all variables/all expressions</code>)因此该函数一定也是单调有界的。</p><p>相对来说<code>meet/join Function</code>函数⊔/⊓:L x L ⟶ L，只证明⊔是单调的，⊓类似:</p><blockquote><p><em>Poof.</em></p><p><em>∀x, y, z ∊ L, x ≼ y, 我们要证明 x⊔z ≼ y⊔z</em></p><p><em>∵ x≼y, y ≼ y⊔z ⟹ x ≼ y⊔z</em></p><p><em>∵ x⊔z是least upper bound of x and z</em></p><p><em>∴x⊔z ≼ y⊔z</em></p></blockquote><p>得证该函数也是单调的。</p><p>到此为止，我们完美的将<code>data-flow analysis</code>的<code>iterative algorithm</code>转化成为<code>fixed-point theorem</code>的已知条件，故<code>fixed-point theorem</code>的结论当然也适用于<code>iterative algorithm</code>。我们也回答了这一节最开始关于迭代算法不动点存在性和精度的问题。</p><h6 id="Complexity"><a href="#Complexity" class="headerlink" title="Complexity"></a>Complexity</h6><p>关于迭代算法的不动点理论还有最后一个问题，就是算法会在什么时候到达不动点即<code>when can we get the solution</code>?<strong>这就涉及到了在<code>Lattice</code>建立的函数的复杂度：</strong></p><p>首先引入<code>Lattice</code>的高度<code>height</code>，即从<code>lattice</code>的<code>top</code>到<code>bottom</code>最长的一条路径<code>h</code>，假设该<code>CFG</code>中节点的数目是<code>k</code>，<strong>那最坏情况需要<code>i = h* k</code>次迭代才能到达不动点。</strong></p><p>到此为止，所有的理论部分都介绍结束了！</p><h4 id="May-Must-Analysis-On-Lattice"><a href="#May-Must-Analysis-On-Lattice" class="headerlink" title="May/Must Analysis On Lattice"></a>May/Must Analysis On Lattice</h4><p>前面一部分主要从数学角度引入<strong>在<code>lattice</code>上定义的函数的不动点定理，然后证明了数据流分析的算法本质上就是通过迭代来达到不动点。</strong>但是实际上不同的数据流分析算法有不同的应用场景，各自对精度和Soundness的要求也不相同——因此如何理解<code>may</code>和<code>must</code>分析的<strong>初始化条件</strong>以及<strong>最大/小不动点</strong>？ 本节解决 ①<code>may/must data-flow analysis</code>如果用<code>lattice</code>表述会是什么样子?②这些分析和求解<code>lattice</code>上的不动点有什么关系？即<code>may</code>求解最小不动点而<code>must</code>求解最大不动点？③求解不动点和分析的<code>Soundness</code>和分析精度有什么关系？这部分讲解十分精彩，图见课件，这里只是记录我认为最核心的需要理解的部分。</p><h5 id="may-analysis"><a href="#may-analysis" class="headerlink" title="may analysis"></a>may analysis</h5><p><code>may</code>分析从⊥到⊤。  </p><p>拿<code>Reaching Definition</code>应用于<font color="red">检测未定义变量</font>为例：</p><h6 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h6><p>分析的<code>⊥</code>是no definitions can reach，<strong>⊥就意味着所有变量都不是未定义</strong>，这个分析结果一定是<code>unsafe</code>的（因为实际上哪怕只有一个未定义变量没有被检测出来，<strong>运行时也一定会报错</strong>）。</p><h6 id="top"><a href="#top" class="headerlink" title="top"></a>top</h6><p>分析的<code>⊤</code>是all definitions may reach，就意味着所有的变量都是未定义，故分析结果一定是<code>safe</code>的（因为就算有一个定义过的变量被检测成未定义，<strong>运行时也不会报错</strong>）。</p><h6 id="safe-amp-precision"><a href="#safe-amp-precision" class="headerlink" title="safe &amp; precision"></a>safe &amp; precision</h6><p>分析算法继续迭代，沿着更加<code>safe</code>的方向走，直到到达最小不动点——这部分是已经证明过的了，问题是如何理解分析的精度和安全。  </p><p>回顾<code>may</code>分析结果<strong>可以有误报但不可以有漏报</strong>即<code>false-positive</code>或者<code>sound</code>。我理解是<font color="red">这里的<code>safe</code>和<code>precision</code>都是针对运行时来说的</font>，<strong>⊥一定会在运行时报错，⊤程序不会运行</strong>，而如何保证<code>safe</code>是由设计者自己设计的<code>Transfer Function</code>决定的。<strong>另一方面精度问题针对在<code>safe</code>的前提下是否可以尽量少误报</strong>，因为不动点有很多而最终我们需要的只是最小的那个。</p><h5 id="must-analysis"><a href="#must-analysis" class="headerlink" title="must analysis"></a>must analysis</h5><p><code>must</code>分析从⊤到⊥。  </p><p>拿<code>available expression</code>应用于<font color="red">优化公共子表达式删除</font>为例：</p><h6 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h6><p>分析的⊤是all expressions must be available，<strong>就意味着所有的表达式都是可以被优化的</strong>，这个分析结果一定是<code>unsafe</code>的（因为哪怕有一个表达式不是公共的，那优化结果一定是错的）。</p><h6 id="bottom-1"><a href="#bottom-1" class="headerlink" title="bottom"></a>bottom</h6><p>分析的⊥是no expressions are available的，就意味着所有的表达式都不可被优化，故分析结果一定是<code>safe</code>的（因为哪怕有一个公共表达式为被检测出来，那也仅仅只是少几个优化）。</p><h6 id="safe-amp-precision-1"><a href="#safe-amp-precision-1" class="headerlink" title="safe &amp; precision"></a>safe &amp; precision</h6><p>回顾<code>must</code>分析结果<strong>可以有漏报但是不可以有误报</strong>即<code>false-negative</code>或者<code>complete</code>。我理解是<font color="red">这里的<code>safe</code>和<code>precision</code>也是针对程序运行结果而言的</font>，<strong>⊥少几个优化，⊤的程序一定出现问题。</strong>如何保证<code>safe</code>是由设计者自己设计的<code>Transfer Function</code>决定的。<strong>另一方面精度问题针对在<code>safe</code>的前提下是否可以尽量少漏报，</strong>因为不动点有很多而最终我们需要的只是最大的那个。</p><font color="red">由此可以看出`may/must`分析完全针对的是不同的场景，但是其分析结果的`safe`和`precision`却都是针对程序运行时和最终的结果。</font><h5 id="another-view"><a href="#another-view" class="headerlink" title="another view"></a>another view</h5><p>老师在这里提供了另一个角度，就是在<code>lattice</code>上迭代函数，其中<code>Transfer Function</code>本身是固定的，<strong>而两种分析的<code>join/meet Function</code>根据<code>lattice</code>的性质其就是两个元素的<code>least/greatest upper/lower bound</code>，加上分别从<code>⊥</code>和<code>⊤</code>开始，</strong>故每次迭代函数走的都是最小/大的路径，故到达的也是最小/最大不动点。</p><h4 id="MOP-and-Distributivity"><a href="#MOP-and-Distributivity" class="headerlink" title="MOP and Distributivity"></a>MOP and Distributivity</h4><p>前面讨论了数据流分析<code>Iterative Algorithm</code>最后到达的不动点是最精确的。但是如何衡量这个精度？这一小节引入一个很经典的<strong>概念</strong><code>Meet-Over-All-Paths Solution</code>即<code>MOP</code>。  </p><p><code>MOP</code>概念引入<code>CFG</code>的每一条路径都是从<code>entry</code>一直到其执行结束。</p><ul><li>P = Entry ⟶ S<sub>1</sub> ⟶ S<sub>2</sub> ⟶… ⟶ S<sub>i</sub></li></ul><p><code>MOP</code>每一条<code>path</code>的<code>Transfer Function</code>是该条路径上所有<code>statements</code>的<code>Transfer Function</code>的合力，最后应用<code>meet operator</code>来计算数据流值: MOP[S<sub>i</sub>] = ⊔/⊓ F<sub>P</sub>(OUT[Entry])。<code>MOP</code>仅仅作为一个理论上的概念存在是因为应用中很多路径是<code>not executable</code>的，<code>Unbounded</code>的以及<code>not enumerable</code>的，故对于那种指数爆炸的程序<code>MOP</code>是<code>impractical</code>的。<strong>这里主要通过<code>MOP</code>概念对比<code>Iterative Algorithm</code>。</strong>对于同一个<code>CFG</code>:</p><p><img src="17.png" width="50%" height="50%" alt=""></p><p>迭代算法是在每一个<code>control flow</code>应用函数:<em>IN[S<sub>4</sub>] = f<sub>S<sub>3</sub>&lt;/sub&gt;(f<sub>S<sub>1</sub>&lt;/sub&gt;(OUT[Entry]) ⊔ f<sub>S<sub>2</sub>&lt;/sub&gt;(OUT[Entry]))</sub></sub></sub></em></p><p>而<code>MOP</code>只会在路径结束之后应用函数:<em>MOP[S<sub>4</sub>] = f<sub>S<sub>3</sub>&lt;/sub&gt;(f<sub>S<sub>1</sub>&lt;/sub&gt;(OUT[Entry])) ⊔ f<sub>S<sub>3</sub>&lt;/sub&gt;(f<sub>S<sub>2</sub>&lt;/sub&gt;(OUT[Entry]))</sub></sub></sub></sub></em></p><p>简化一下就是:</p><ul><li>Ours = F(x ⊔ y)</li><li>MOP = F(x) ⊔ F(y)</li></ul><p>可以证明<strong>迭代算法的精度要比<code>MOP</code>更不准。</strong>只有当F函数是<code>distributive</code>的时候才能保证<code>F(x⊔y) = F(x) ⊔ F(y)</code>即两种算法的精确度是一样的。前面的所有<code>Bit-vector/Gen/Kill</code>问题的数据流分析算法它们的<code>meet/join</code>函数都是<code>distributive</code>的。</p><h4 id="Constant-Propagation"><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h4><p>常量传播是一个<code>non-distributive</code>的数据流分析算法。  </p><p>Given a variable x at program point p, determine whether x is guaranteed to hold a constant value at p.  </p><p>按照数据流分析框架(<font color="red">D</font>, <font color="green">L</font>, <font color="blue">F</font>)来解释的话，该分析一定是前向分析<code>forward-analysis</code>，由于作为优化算法其必须保证运行时不可以出错故是<code>must</code>分析。其<code>lattice</code>的domain是一个pair<code>(x, v)</code>其中<code>x</code>是变量而<code>v</code>表示变量的值（有<code>constant</code>, <code>undefined</code>，<code>notAconstant</code>三种选项），分析的<code>meet operator</code>和之前的算法不同——不是单一的⊔/⊓：</p><ul><li>NAC ⊓ v = NAC</li><li>UNDEF ⊓ v = v</li><li>c ⊓ v = ?<ul><li>c ⊓ c = c</li><li>c<sub>1</sub> ⊓ c<sub>2</sub> = NAC</li></ul></li></ul><p>给定<code>s: x = ...</code>是一个赋值语句，因此该语句OUT则是IN的所有变量减掉<code>x</code>(因为x被重新赋值了)再加上该语句中新gen出来的变量。故定义常量传播的<code>Transfer Function</code>F: OUT[s] = gen ⋃ (IN[s] - {(x, _)})。其中gen函数:</p><ul><li>s: x = c; //c is a constant   ⟹  gen = {(x, c)}</li><li>s: x = y;      ⟹    gen = {(x, val(y))}</li><li>x: x = y op z;   ⟹   gen = {(x, f(y, z))}<ul><li>val(y) op val(z)     // if val(y) and val(z) are constants</li><li>NAC    // if val(y) or val(z) is NAC</li><li>UNDEF    //UNDEF op UNDEF   or UNDEF op NAC</li></ul></li></ul><p>下面的这个例子中：</p><p><img src="18.png" width="50%" height="50%" alt=""></p><p>用数据流分析迭代算法以及<code>MOP</code>算法来完成常量传播求值之后进行一次对比:</p><ul><li>Ours:   F(X ⊓ Y) = {(a, NAC), (c, NAC), <font color="green">(c, NAC)</font>}</li><li>MOP:   F(X) ⊓ F(Y) = {(a, NAC), (b, NAC), <font color="green">(c, 10)</font>}</li></ul><p>按照<code>must</code>分析的不动点理论，分析是从⊤到⊥（⊤就是UNDEF，⊥是NAC）进行的。而<code>Ours</code>的值要比<code>MOP</code>的值更靠近⊥故其分析则<code>less precise</code>。因此<code>F(X⊓Y)≠ F(X)⊓ F(Y)</code>进而<code>F(X⊓Y) ⋞ F(X)⊓ F(Y)</code>。所以该分析是<code>Nondistributive</code>的。</p><h4 id="Worklist-Algorithm"><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h4><p>在实际的数据流分析中会使用迭代算法的优化版本即<code>Worklist Algorithm</code>。  </p><p>迭代算法的主要复杂度在<code>CFG</code>中一个节点输出有变化都需要使得整个<code>CFG</code>迭代，而<code>Worklist Algorithm</code>则是迭代算法的一种剪枝优化。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OUT</span>[entry] = nullptr;</span><br><span class="line"><span class="title">for</span>(each basic block\entry)</span><br><span class="line"><span class="type">OUT</span>[<span class="type">B</span>] = nullptr;</span><br><span class="line"><span class="type">Worklist</span> ⟵ all basic blocks</span><br><span class="line"><span class="title">while</span>(<span class="type">Worklist</span> is not empty) </span><br><span class="line"><span class="type">Pick</span> a basic block <span class="type">B</span> from <span class="type">Worklist</span></span><br><span class="line">old_OUT = <span class="type">OUT</span>[<span class="type">B</span>]</span><br><span class="line"><span class="type">IN</span>[<span class="type">B</span>] = ⊔<span class="type">OUT</span>[<span class="type">P</span>]</span><br><span class="line"><span class="type">OUT</span>[<span class="type">B</span>] = gen_B ⋃ (<span class="type">IN</span>[<span class="type">B</span>] - kill_B)</span><br><span class="line"><span class="keyword">if</span>(old_OUT ≠ <span class="type">OUT</span>[<span class="type">B</span>]) </span><br><span class="line">add all successors <span class="keyword">of</span> <span class="type">B</span> to <span class="type">Worklist</span></span><br></pre></td></tr></table></figure><p>至此，数据流分析的学习告一段落。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;编译器中大部分机器无关的全局优化是基于&lt;code&gt;Data-flow Analysis&lt;/code&gt;实现的。数据流分析技术从代码中收集程序语义相关的信息，是程序分析的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;In each data-flow analysis application, we associate with every program point a data-flow value that represents an abstraction of the set of all possible program states that can be observed for that point.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在工业界的&lt;a href=&quot;https://www.zhihu.com/question/41959902&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;主流编译器&lt;/a&gt;中，&lt;code&gt;C&lt;/code&gt;系的&lt;code&gt;LLVM&lt;/code&gt;，&lt;code&gt;Java&lt;/code&gt;系的&lt;code&gt;HotSpot&lt;/code&gt;都是基于&lt;code&gt;SSA&lt;/code&gt;做数据流分析而不是传统的&lt;code&gt;lattice&lt;/code&gt;。南大这节课中是基于&lt;code&gt;Lattice&lt;/code&gt;来讲解过程内&lt;code&gt;Intra-procedural&lt;/code&gt;，无别名&lt;code&gt;no aliases&lt;/code&gt;的经典数据流分析框架。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>NJU静态程序分析(0-Introduction)</title>
    <link href="http://haotianmcihael.github.io/2021/05/02/NJU%E9%9D%99%E6%80%81%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90-0-Introduction/"/>
    <id>http://haotianmcihael.github.io/2021/05/02/NJU静态程序分析-0-Introduction/</id>
    <published>2021-05-01T19:00:36.000Z</published>
    <updated>2022-03-16T10:22:34.756Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>编译器作为工业界对PL理论的部分实现——和编程语言，运行时环境一样只是机器解释世界的一个角度。而当我解锁了从更加PL的方式看待<code>计算</code>这件事情之后，又打开了一扇通往新世界的大门。过去的几十年里<code>Programming Language</code>的内核并没有变化多少——但是程序本身却随着应用需求变的更加庞大和复杂。而静态程序分析作为PL的重要应用，其目的就在于在编译期确保程序的可靠性，安全性等各种性质。</p><p>​    <strong>Static Analysis analyzes a program P to reasono about its behaviors and determines whether it satisfies some properties before running P.</strong>  </p><p>​     主要的学习资源是<a href="https://pascal-group.bitbucket.io/teaching.html" target="_blank" rel="noopener">NJU-PASCAL团队的静态分析课程</a>以及<a href="https://book.douban.com/subject/3774682/" target="_blank" rel="noopener">龙书</a>和<a href="https://book.douban.com/subject/1400374/" target="_blank" rel="noopener">鲸书</a>中的部分章节。  </p><a id="more"></a><h3 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static-Analysis"></a>Static-Analysis</h3><p>​    PL的大框架大体上可以分成三个部分:</p><ul><li>Theory</li></ul><p>包括如何设计一个语言内核，一个类型系统，如何完成语义分析，如何形式化等等不同的理论，更多是作为学术研究的课题</p><ul><li>Environment</li></ul><p>针对特定场景设计的编译器和运行时环境等</p><ul><li>Application</li></ul><p>程序分析，程序合成，程序验证</p><p> 而静态程序分析主要关注在程序的<strong>Reliability</strong>比如在程序运行前检测到空指针异常，内存泄漏等问题防止程序在运行过程中报运行时错误；<strong>Security</strong>比如隐私数据泄露，注入攻击<code>injection attack</code>等；<strong>Optimization</strong>编译优化等方面。</p><h3 id="Rice‘s-Theorem"><a href="#Rice‘s-Theorem" class="headerlink" title="Rice‘s Theorem"></a>Rice‘s Theorem</h3><p>Any non-trivial property of the behavior of programs in a <strong>recursively enumerable</strong> language is undecidable.</p><p>这个定理有点哥德尔不完备定理的感觉——不存在一个完美的分析算能准确预测出程序的各种关键行为，即No Silver Bullet。这也引出了在实践中最重要的一个评判标准Sound和Complete。</p><p>这里的<code>recursively enumerable</code>递归可枚举是<strong>图灵完备</strong>的另一种说法，简写为<code>r.e.</code>。</p><h3 id="Sound-and-Complete"><a href="#Sound-and-Complete" class="headerlink" title="Sound and Complete"></a>Sound and Complete</h3><p>假设一个程序中存在10个<code>unknown error</code>，一套分析框架不可能精确定位到这十个。而是在其值域范围内波动——不仅仅包含这10的集合就是<code>Sound</code>，只包含这10个的子集就是<code>Complete</code>。  </p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>伴随着这一对概念还有一对——<code>false negatives</code>和<code>false positives</code>。</p><ul><li>False negatives</li></ul><p>就是<code>Compromise soundness</code>也就是缩小原来分析的量，这样会更加的<code>complete</code>——便会产生<strong>漏报</strong></p><ul><li>False positives</li></ul><p>就是<code>Compromise completeness</code>也就是增大原来分析的量，这样会更加的<code>sound</code>——便会产生<strong>误报</strong></p><p>其实这里为什么要引入这一对概念我没有太理解……有点往回绕的意思。 这个图得好好理解一下。</p><p> <img src="2.png" width="50%" height="50%" alt=""></p><p>在实践中，用的更多的标准是<code>compromising completeness</code>也就是要让结果更加的<code>sound</code>但是损失了精确度。<strong>换句话讲，分析的结果一定要全面，但不一定精确。也就是说宁可误报一些分析行为，也不允许程序在运行时报异常——这样整个系统付出代价会更高。</strong></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;&#125;;</span><br><span class="line">class Base&#123;</span><br><span class="line">  A fld;</span><br><span class="line">&#125;;</span><br><span class="line">class B : A&#123;&#125;;</span><br><span class="line">class C : A&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base a = new Base();</span><br><span class="line">if(condition) &#123;</span><br><span class="line">  B b = new B();</span><br><span class="line">a.fld = b;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">  C c = new D();</span><br><span class="line">a.fld = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// case</span><br><span class="line">B bTmp = (B)a.fld;</span><br></pre></td></tr></table></figure><p>可以看到上例中的case中进行了一次强制转换，如果控制流走的是<code>!condition</code>那么就会报错。如果分析器是<code>sound</code>的这里就应该检测出该程序的控制流错误——从而减少了BUG。</p><h4 id="tradeoff"><a href="#tradeoff" class="headerlink" title="tradeoff"></a>tradeoff</h4><p>因为<code>sound</code>会分析出比理论更多的结果，所以导致分析的速度会变慢。  </p><p> Static Analysis ensure soundness, while making good trade-offs between analysis precision and analysis speed——分析过程的本质上也是一种速度和精度之间的权衡。</p><h3 id="To-Conclude"><a href="#To-Conclude" class="headerlink" title="To Conclude"></a>To Conclude</h3><p>​    大部分分析方式可以总结为下面的两个部分：</p><ul><li>Abstraction</li></ul><p>就是将具体的程序特征和行为进一步抽象成分析器的元符号，完成一定意义的所谓<strong>形式化</strong></p><ul><li><p>Over-approximation</p></li><li><p>transfer functions</p></li></ul><p>In static analysis, transfer functions define how to evaluate different program statements on abstract values. Its defined according to “analysis problem” and the “semantics” of different program statements.</p><ul><li>control flows</li></ul><p>程序的本质其实就是语句及语句之间的关联，映射到static analysis中就是（语句）<code>transfer functions</code>和（关联）<code>control flows</code>。在抽象的基础上，进一步颗粒化程序运行行为。比如<code>transfer functions</code>定义为程序中<code>statements</code>和程序异常行为的语义比如声明语句，除零异常等。而<code>control flows</code>定义了程序的控制流比如一些if-else分支。<strong>这样就能更加细粒度的完成程序行为的建模，然后在模型基础上完成分析器预定的sound的分析结果。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;编译器作为工业界对PL理论的部分实现——和编程语言，运行时环境一样只是机器解释世界的一个角度。而当我解锁了从更加PL的方式看待&lt;code&gt;计算&lt;/code&gt;这件事情之后，又打开了一扇通往新世界的大门。过去的几十年里&lt;code&gt;Programming Language&lt;/code&gt;的内核并没有变化多少——但是程序本身却随着应用需求变的更加庞大和复杂。而静态程序分析作为PL的重要应用，其目的就在于在编译期确保程序的可靠性，安全性等各种性质。&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;Static Analysis analyzes a program P to reasono about its behaviors and determines whether it satisfies some properties before running P.&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;​     主要的学习资源是&lt;a href=&quot;https://pascal-group.bitbucket.io/teaching.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NJU-PASCAL团队的静态分析课程&lt;/a&gt;以及&lt;a href=&quot;https://book.douban.com/subject/3774682/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;龙书&lt;/a&gt;和&lt;a href=&quot;https://book.douban.com/subject/1400374/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鲸书&lt;/a&gt;中的部分章节。  &lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://haotianmcihael.github.io/categories/Java/"/>
    
    
      <category term="Software-Analysis" scheme="http://haotianmcihael.github.io/tags/Software-Analysis/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程（Ocaml）</title>
    <link href="http://haotianmcihael.github.io/2021/04/18/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88Ocaml%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2021/04/18/函数式编程（Ocaml）/</id>
    <published>2021-04-18T09:48:24.000Z</published>
    <updated>2022-03-16T09:52:27.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>最近在实验室实习的过程中学到了很多有意思的东西，对<code>Programming Languages</code>也有了更深的了解，<code>Ocaml</code>是一门支持多范式的函数式编程语言。<strong>程序描述计算，但是又不仅仅是计算</strong>。<code>Ocaml</code>的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:</p><ul><li>关于<code>scripting/imperative/object-oriented/functional PL</code>的基本概念<ul><li><code>Higher-order Functions</code></li><li><code>State-Full vs State-Free Computation</code></li><li><code>Modelling Objects and Closures</code></li><li><code>Exceptions/Continuations to Defer Control</code></li><li><code>Polymorphism</code></li><li><code>Partial Evaluation/Lazy Programming/Modules</code></li></ul></li><li>关于<code>reason about programs</code>的方法<ul><li><code>Type Checking</code></li><li><code>Induction</code></li><li><code>Operational Semantics</code></li><li><code>QuickCheck</code></li></ul></li><li>关于设计一门语言的基本规则</li></ul><a id="more"></a><h3 id="FP’s-Basic-Concepts"><a href="#FP’s-Basic-Concepts" class="headerlink" title="FP’s Basic Concepts"></a>FP’s Basic Concepts</h3><p><code>Ocaml is a statically typed functional programminng language</code>。函数式编程中，<code>function</code>永远是一等公民，程序中只有<code>expression</code>的概念，通过<code>functions</code>递归处理<code>values</code>来完成<code>computations</code>。<code>Ocaml</code>通过<code>pattern matching</code>模式匹配的方式来定义递归数据结构和函数，进而写出更简洁的程序。  </p><p>在函数式中还有一个和<code>imperative PL.</code>中不同的概念称为<code>effect-free programming</code>。在命令式语言中，我们通过给<code>variables/fields</code>赋值来修改程序状态并将赋值行为的结果看成是<code>effects</code>。但是比如函数式就不会<code>explicitly</code>的分配内存，甚至没有<code>exception handling</code>来改变控制流状态——<strong>不支持<code>effect</code>被称为<code>pure functiional</code>比如<code>Haskell</code></strong>。<code>Ocaml</code>不是纯函数式语言。所以支持<code>effectful/state-full programming</code>和<code>pure FP</code>。  </p><p>最后一个关键字就是<code>statically typed</code>静态类型。<code>Types statically approximate the runtime behaviour of an expression.</code>意思就是<code>static type checking</code>本身是在程序运行之前进行类型检查——通过<code>syntatic structure of expressions</code>。它可以保证通过静态类型检查的程序在运行时一定不会<code>core dump</code>。这样的<code>statically typed PL.</code>比如<code>Ocaml/Java/ML/Haskell/Scala等</code>也被称为是<code>type-safe</code>的。</p><h4 id="Expressions-Names-Values-and-Types"><a href="#Expressions-Names-Values-and-Types" class="headerlink" title="Expressions, Names, Values and Types"></a>Expressions, Names, Values and Types</h4><p>在函数式中没有语句<code>statements</code>，最基本的<code>expression</code>就是<code>numbers/strings/booleans</code>。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">2</span> + <span class="number">3</span>;;</span><br><span class="line">- : <span class="built_in">int</span> = <span class="number">5</span></span><br><span class="line"># <span class="number">4.0</span> /. <span class="number">2.0</span>;;</span><br><span class="line">- : <span class="built_in">float</span> = <span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>上面代码中的格式为<code>&lt;name&gt; : &lt;type&gt; = &lt;value&gt;</code> 。我们将<code>;;</code>之前的式子称为<code>expressions</code>，将整个计算过程称为<code>evaluation</code>，而将计算的结果称为<code>values</code>。</p><p>注意在<code>Ocaml</code>中基础运算符并没有被重载，故浮点运算都是在后面有一个<code>,</code>。这主要是因为<code>Ocaml</code>是静态类型的，不会在运行时去根据运算符参数来推导重载的<code>operators</code>。  </p><p>通过类型检查的程序，其<code>evaluation</code>要么更新到一个新的<code>state</code>要么报一个<code>built-in runtime error</code>。比如:</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">3</span> / <span class="number">0</span>;;</span><br><span class="line"><span class="type">Exception</span>: <span class="type">Division_by_zero</span></span><br></pre></td></tr></table></figure><h4 id="Variables-Bindings-and-Functions"><a href="#Variables-Bindings-and-Functions" class="headerlink" title="Variables, Bindings and Functions"></a>Variables, Bindings and Functions</h4><p><code>Ocaml</code>是一个<code>call-by-value</code>的语言——<code>it binds values to variable names not expressions</code>。这里有一个<code>binding</code>的概念，区分于<code>assignment</code>。我们只是在<code>values</code>和<code>name</code>之间建立了“链接”——并没有新的<code>state</code>被创建——我理解和<code>imperative PL.</code>不同的应该是内存模型比如<code>C</code>中对局部变量是放在栈上的但是确实创建了内存。当然这种“链接”也是可以更新的。在<code>Ocaml</code>中用<code>let</code>表达式来建立一个绑定。</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">let</span> x = <span class="number">3</span> * <span class="number">3</span>;;</span><br><span class="line"><span class="keyword">val</span> x : <span class="built_in">int</span> = <span class="number">9</span></span><br><span class="line"># <span class="keyword">let</span> x = <span class="number">42</span>;;</span><br><span class="line"><span class="keyword">val</span> x : <span class="built_in">int</span> = <span class="number">42</span></span><br></pre></td></tr></table></figure><p>变量的作用域是根据<code>binding stack</code>来确定的。局部或者临时创建的<code>binding</code>都会被<code>push</code>进<code>binding stack</code>中，在不需要的时候会被<code>GC</code>清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># let k = 4;;</span><br><span class="line">val k : int = 4</span><br><span class="line"># let k = 3 in k * k ;;</span><br><span class="line">- : int = 9</span><br><span class="line"># k;;</span><br><span class="line">- : int = 4</span><br></pre></td></tr></table></figure><p>这里有一个新的<code>let &lt;name&gt; = &lt;expression 1&gt; in &lt;expression 2&gt;</code>结构——将<code>expression1</code>的<code>value</code>绑定到<code>name</code>上，然后继续使用这个新的绑定对<code>expression 2</code>进行<code>evalutions</code>。  </p><p>在函数式中<code>let</code>不仅可以绑定基本类型，还可以绑定函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let area : float -&gt; float = function r -&gt; pi *. r *. r;;</span><br><span class="line">let area : float -&gt; float = fun r -&gt; 3.14 *. r *. r;;</span><br><span class="line">let area (r:float) = pi *. r *. r;;</span><br><span class="line">let a1 = area(2.0);;</span><br></pre></td></tr></table></figure><p>上面的三种写法是等价的，都得到函数类型<code>val area : float -&gt; float = &lt;fun&gt;</code>。<strong>有意思的是函数作为一种绑定，也是在<code>binding stack</code>中的，所以它只能看到过去的绑定：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># let (pi*float) = 3.0</span><br><span class="line">val pi : float = 3.14</span><br><span class="line"># let area (r:float) = pi *. r *.r;;</span><br><span class="line">val area : float -&gt; float = &lt;fun&gt;</span><br><span class="line"># let a1 = area(2.0);;</span><br><span class="line">val a1 : float = 12.0</span><br><span class="line"># let (pi*float) = 4.0</span><br><span class="line">val pi : float = 4.0</span><br><span class="line"># let a2 = area(2.0);;</span><br><span class="line">val a2 : float = 12.0</span><br></pre></td></tr></table></figure><p>最后介绍一下递归函数。在<code>Ocaml</code>中递归函数使用<code>let rec</code>来声明。比如定义<code>factorial</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># exception Domain;;</span><br><span class="line"># let rec fact n = </span><br><span class="line">if n &lt; 0 then raise Domain</span><br><span class="line">else if n = 0 then 1</span><br><span class="line">else n * fact(n - 1);;</span><br></pre></td></tr></table></figure><p>在函数式中所有的函数都可以被写成尾递归的形式然后进一步优化——这是因为尾递归函数的栈帧可以被优化掉。比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># let fact_tr n = </span><br><span class="line">let rec f n acc = </span><br><span class="line">if n = 0 then acc else f (n - 1) (n * acc)</span><br><span class="line">in</span><br><span class="line">f n 1</span><br></pre></td></tr></table></figure><h4 id="Data-Types-and-Pattern-Matching"><a href="#Data-Types-and-Pattern-Matching" class="headerlink" title="Data Types and Pattern Matching"></a>Data Types and Pattern Matching</h4><p>这一节可以在<code>Ocaml</code>中定义自己的递归/非递归的数据类型。</p><p><code>Ocaml</code>使用<code>type</code>来定义<strong>有限无序的非递归集合</strong>，这里举一个扑克牌的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># type suit = Clubs | Spades | Hearts | Diamonds;;</span><br><span class="line">type suit = Clubs | Spades | Hearts | Diamonds</span><br><span class="line"># type rank = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace;;</span><br><span class="line"># type card = rank * suit;;</span><br><span class="line">type card = rank * suit</span><br><span class="line"># type hand = Empty | Hand of card * hand;;</span><br><span class="line">type hand = Empty | Hand of card * hand</span><br><span class="line"># let rec dom (s1, s2) = match (s1, s2) with </span><br><span class="line">| (Spades, _) -&gt; true</span><br><span class="line">| (Hearts, Diamonds)  -&gt; true</span><br><span class="line">| (s1, s2) -&gt; s1 = s2</span><br></pre></td></tr></table></figure><p><code>Ocaml</code>使用<code>pattern matching</code>模式匹配来操作这些数据结构。这里有两个概念——<code>patterns</code>和<code>constructors</code>。每一个<code>pattern</code>由不同的<code>constructors</code>填充——这里的构造器指的是每一个和类型元素同名的构造器比如<code>Clubs</code>。<code>Ocaml</code>规定构造器首字母必须大写，且匹配是从上到下的顺序。  </p><p>进一步的，为了简化代码而支持<code>inductively</code>的<code>deep pattern</code>构造形式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># let rec add c1 c2 = match c1 c2 with</span><br><span class="line">| (Hearts, v1), (Hearts, v2) -&gt; v1 + v2</span><br><span class="line">| _, _ -&gt; 0;;</span><br><span class="line">val add : (&apos;a -&gt; (suit * int) * (suit * int)) -&gt; &apos;a -&gt; int = &lt;fun&gt;</span><br></pre></td></tr></table></figure><p>这里会发现构造了一个比较复杂的类型<code>(&#39;a -&gt; (suit*int)*(suit*int)) -&gt; &#39;a -&gt; int</code>。其中<code>type1 * type2</code>为一个<code>pair</code>，而<code>`a</code>为任意类型。    </p><p>上述函数的基本类型推导过程为两个任意类型为输入参数，<code>int</code>为输出。其中任意类型为<code>(suit*int)*(suit*int)</code>的。</p><p>上面扑克牌的例子中<code>hand</code>定义一组<strong>无限递归集合</strong>。在<code>hand</code>类型中，<code>Empty</code>和<code>Hand</code>分别为两个<code>constructors</code>。<code>Empty</code>没有输入参数，而<code>Hand</code>以<code>a tuple of a card and another hand</code>的一个<code>tuple</code>为输入参数。看下面的实例化例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># let hand0: hand = Empty</span><br><span class="line">let hand1: hand = Hand((Ace, Hearts), Empty)</span><br><span class="line">let hand2: hand = Hand((Queen, Diamonds), hand1)</span><br><span class="line">let hand3:hand = </span><br><span class="line">Hand((Ace, Spades),</span><br><span class="line">Hand((Ten, Diamonds), </span><br><span class="line">Hand((Seven, Clubs),</span><br><span class="line">Hand((Queen, Spades),</span><br><span class="line">Hand((Eight, Clubs), Empty)))));;</span><br></pre></td></tr></table></figure><p>这个<code>hand</code>类型实际上就是一棵退化的二叉树（只能靠右生长）——叶子是<code>Empty</code>， 而<code>Hand</code>构造器使用两个参数来建树。</p><p>下面我们定义一个函数，这里函数的类型是<code>suit -&gt; hand -&gt; hand</code>，功能是给定一个<code>suit -&gt; hand</code>的输入，然后从<code>hand</code>中找有匹配到<code>suit</code>类型的<code>hand</code>然后返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># let rec extract (s:suit) (h:hand) = match h with </span><br><span class="line">| Empty -&gt; Empty</span><br><span class="line">| Hand ((_, s&apos;) as c, h&apos;) -&gt;</span><br><span class="line">if s = s&apos; then Hand(c, extract s h&apos;)</span><br><span class="line">else extract s h&apos;</span><br></pre></td></tr></table></figure><p>上一个函数中的<code>Empty</code>实际上就是一个终结符，意味着如果<code>hand</code>类型都不匹配的话就直接返回<code>Empty</code>。但是如果我要匹配一个<code>card</code>的话，没有匹配上该怎么返回呢？<code>Ocaml</code>引入一个<code>optional data type</code>。比如下面的函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># type &apos;a option = None | Some of &apos;a</span><br><span class="line">type &apos;a option = None | Some of &apos;a</span><br><span class="line"># let rec find (r, h) = match h with</span><br><span class="line">| Empty  -&gt; None</span><br><span class="line">| Hand((r&apos;, s&apos;), h&apos;) -&gt; if r = r&apos; then Some s&apos;</span><br><span class="line">else find(r, h&apos;)</span><br><span class="line">val find: rank * hand -&gt; suit option = &lt;fun&gt;</span><br></pre></td></tr></table></figure><p>其中<code>option type</code>表示由<code>Some</code>构造器实现的类型为<code>`a</code>的元素集合，是符合多态的任意类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;最近在实验室实习的过程中学到了很多有意思的东西，对&lt;code&gt;Programming Languages&lt;/code&gt;也有了更深的了解，&lt;code&gt;Ocaml&lt;/code&gt;是一门支持多范式的函数式编程语言。&lt;strong&gt;程序描述计算，但是又不仅仅是计算&lt;/strong&gt;。&lt;code&gt;Ocaml&lt;/code&gt;的学习带给我的不仅仅是语言本身，这个系列记录了其中的部分心得:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于&lt;code&gt;scripting/imperative/object-oriented/functional PL&lt;/code&gt;的基本概念&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Higher-order Functions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State-Full vs State-Free Computation&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Modelling Objects and Closures&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exceptions/Continuations to Defer Control&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Polymorphism&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Partial Evaluation/Lazy Programming/Modules&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于&lt;code&gt;reason about programs&lt;/code&gt;的方法&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Type Checking&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Induction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Operational Semantics&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuickCheck&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于设计一门语言的基本规则&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Ocaml" scheme="http://haotianmcihael.github.io/categories/Ocaml/"/>
    
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="FP" scheme="http://haotianmcihael.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>Lisp语言和Emacs</title>
    <link href="http://haotianmcihael.github.io/2021/02/16/Lisp%E8%AF%AD%E8%A8%80%E5%92%8CEmacs/"/>
    <id>http://haotianmcihael.github.io/2021/02/16/Lisp语言和Emacs/</id>
    <published>2021-02-16T13:58:30.000Z</published>
    <updated>2022-03-16T10:25:10.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>​    第一次接触<code>EMACS</code>是大二的时候，当时只顾着新奇的界面和强大的功能却忽视了其背后真正的理论。后来我写代码也一直不喜欢IDE这种东西，但现在回过头来看，这貌似也只是一种浮于表面而无关原理的执拗。 </p><p>​    这次重新回归到<code>Spacemacs</code>，我希望仔细从<code>Lisp</code>的角度理解这款编辑器，不管是其插件特性还是语言本身。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;​    第一次接触&lt;code&gt;EMACS&lt;/code&gt;是大二的时候，当时只顾着新奇的界面和强大的功能却忽视了其背后真正的理论。后来我写代码也一直不喜欢IDE这种东西，但现在回过头来看，这貌似也只是一种浮于表面而无关原理的执拗。 &lt;/p&gt;
&lt;p&gt;​    这次重新回归到&lt;code&gt;Spacemacs&lt;/code&gt;，我希望仔细从&lt;code&gt;Lisp&lt;/code&gt;的角度理解这款编辑器，不管是其插件特性还是语言本身。&lt;/p&gt;
    
    </summary>
    
      <category term="Lisp" scheme="http://haotianmcihael.github.io/categories/Lisp/"/>
    
    
      <category term="EMACS" scheme="http://haotianmcihael.github.io/tags/EMACS/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
  </entry>
  
  <entry>
    <title>WebAssembly和Wabt</title>
    <link href="http://haotianmcihael.github.io/2020/11/12/WebAssembly%E5%92%8CWabt/"/>
    <id>http://haotianmcihael.github.io/2020/11/12/WebAssembly和Wabt/</id>
    <published>2020-11-12T09:01:21.000Z</published>
    <updated>2022-03-16T09:54:07.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>最近参加<a href="https://github.com/deeplang-org" target="_blank" rel="noopener"><code>deeplang</code></a>的的过程中，接触到了一些编译领域的新技术，总结一下希望有时间了可以进一步的深入了解。参考资料是<a href="https://book.douban.com/subject/30396640/" target="_blank" rel="noopener">WebAssembly标准入门</a>。</p><a id="more"></a><h3 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h3><p>过去很多技术尝试将<code>C/C++</code>程序直接运行在浏览器中，比如<code>TypeScript</code> 将<code>C/C++</code>代码转换为<code>JS</code>。</p><ul><li><code>Emscripten</code></li></ul><p>而这个项目利用<code>LLVM</code>编译器前端编译<code>C/C++</code>代码，生成<code>LLVM</code>平台特有的跨平台中间语言代码，最终再将<code>IR</code>转换为<code>JavaScript</code>的<strong><code>asm.js</code>子集</strong>——这是<code>WebAssembly</code>的基础。</p><ul><li><code>AOT编译</code></li><li><code>JIT编译</code></li></ul><p><code>JIT</code>的优点在于<code>Profile-Based Optimization</code>，根据运行时信息然后随着时间的推移尽可能的得到最优的代码。</p><p>而<code>AOT</code>的优点在于无需<code>runtime</code>运行，直接静态链接至最终的程序中。</p><ul><li><code>WebAssembly</code></li></ul><p><code>JavaScript</code>运行在其虚拟机上，而<code>WebAssembly</code>也运行在其虚拟机上。而现在<code>Node.js 8.0</code>之后的版本也可以运行<code>WebAssembly</code>——也就是说<code>WebAssembly</code>虚拟机可以脱离<code>JS</code>的环境支持，不仅仅运行在浏览器中。</p><h3 id="WebAssembly概述"><a href="#WebAssembly概述" class="headerlink" title="WebAssembly概述"></a>WebAssembly概述</h3><p>和<code>LLVM IR</code>很像，有两种汇编表示——<code>.wat</code>文本表示和<code>.wasm</code>机器表示。</p><h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h4><ul><li>模块 </li></ul><p>由<code>.wasm</code>编译而来的可执行机器码的二进制对象。</p><ul><li>内存</li></ul><p>网页环境下，<code>wasm</code>的内存由<code>JavaScript</code>中的<code>ArrayBuffer</code>对象实现的。</p><ul><li>表格</li></ul><p>引入表格对象用于存储函数引用来模拟<code>C/C++</code>指针。</p><ul><li>实例<ul><li>导入对象  调用JS函数</li><li>导出对象   提供接口</li></ul></li></ul><p>指一个模块及其运行时的所有状态，包括内存，表格以及导入对象等。模块只有被实例化之后才可以调用。  </p><h4 id="程序生命周期"><a href="#程序生命周期" class="headerlink" title="程序生命周期"></a>程序生命周期</h4><ul><li>将<code>wat</code>或者其他语言编译成<code>.wasm</code>文件</li><li>网页中使用<code>fetch</code>等获取<code>.wasm</code>文件<ul><li><code>emrun --no_browser --port 8080 .</code> 将文件运行在<code>http</code>协议上</li><li>然后打开<code>http://localhost:8080/xxx.html</code></li></ul></li><li>将<code>.wasm</code>编译为模块，编译过程中进行合法性检查</li><li>实例化，初始化导入对象，创建模块实例</li><li>执行实例的导出函数，完成操作</li></ul><h4 id="虚拟机体系结构"><a href="#虚拟机体系结构" class="headerlink" title="虚拟机体系结构"></a>虚拟机体系结构</h4><ul><li>一个全局类型数组(函数签名)</li><li>一个全局函数数组</li><li>一个全局变量数组</li><li>一个全局表格对象(元素引用)</li><li>一个全局内存对象</li><li>一个运行时栈</li></ul><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>JavaScript部分<code>hello.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Show me the answer<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var wasmMem = new WebAssembly.Memory(&#123;initial:1&#125;);</span></span><br><span class="line"><span class="undefined">            function printStr(offset, length)&#123;</span></span><br><span class="line"><span class="undefined">                var bytes = new Uint8Array(wasmMem.buffer, offset, length);</span></span><br><span class="line"><span class="undefined">                var string = new TextDecoder('utf-8').decode(bytes);</span></span><br><span class="line"><span class="undefined">                console.log(string);</span></span><br><span class="line"><span class="undefined">                &#125;;</span></span><br><span class="line"><span class="undefined">            var importObj = &#123;js : &#123;print: printStr, mem: wasmMem&#125;&#125;; </span></span><br><span class="line"><span class="undefined">            fetch('hello.wasm').then(response=&gt;</span></span><br><span class="line"><span class="undefined">                        response.arrayBuffer()</span></span><br><span class="line"><span class="undefined">                        ).then(bytes=&gt;</span></span><br><span class="line"><span class="undefined">                          WebAssembly.instantiate(bytes, importObj)</span></span><br><span class="line"><span class="undefined">                        ).then(result =&gt; result.instance.exports.hello()</span></span><br><span class="line"><span class="undefined">                        );</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>wat部分<code>hello.wat</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ;; hello.wat</span><br><span class="line"></span><br><span class="line">(<span class="keyword">module</span></span><br><span class="line">      ;; import js::print as js_print(); </span><br><span class="line">      (import "js" "print" (func $js_print (param i32 i32)))</span><br><span class="line">      (import "js" "mem" (memory 1))  ;;import js::mem as memory</span><br><span class="line">      (data (i32.const 0) "你好，wasm")</span><br><span class="line">      (func (export "hello")</span><br><span class="line">           i32.const 0    ;; pass offset 0 to js_print</span><br><span class="line">           i32.const 13   ;; pass offset 13 to js_print</span><br><span class="line">           call $js_print </span><br><span class="line">            )</span><br><span class="line">       )</span><br></pre></td></tr></table></figure><p>首先将<code>.wat</code>编译成为<code>.wasm</code>,需要用到<a href="https://github.com/WebAssembly/wabt" target="_blank" rel="noopener">wabt工具集</a>。还需要下载<a href="https://github.com/juj/emsdk.git" target="_blank" rel="noopener"> Emscripten工具集</a>。编译好之后配置环境变量。就可以执行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wat2wasm hello.wat -o hello.wasm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> emrun --no_browser --port 8080 .</span></span><br></pre></td></tr></table></figure><p>然后打开<code>http://localhost:8080/xxx.html</code>，启动<code>Chrome</code>下的开发者模式，看到执行成功。</p><h3 id="WebAssembly核心"><a href="#WebAssembly核心" class="headerlink" title="WebAssembly核心"></a>WebAssembly核心</h3><h4 id="在JS环境中"><a href="#在JS环境中" class="headerlink" title="在JS环境中"></a>在JS环境中</h4><p>浏览器中的<code>wasm</code>运行在<code>JS</code>虚拟机上，页面可以通过一组<code>JS</code>对象进行<code>wasm</code>模块的编译，载入，配置，调用等操作。 </p><p>在<code>wasm</code>中的几个关键概念都有与之对应的对象：</p><ul><li>模块——<code>WebAssembly.Module</code></li><li>内存——<code>WebAssembly.Memory</code></li><li>表格——<code>WebAssembly.Table</code></li><li>实例——<code>WebAssembly.Instance</code></li></ul><h4 id="WebAssembly汇编语言"><a href="#WebAssembly汇编语言" class="headerlink" title="WebAssembly汇编语言"></a>WebAssembly汇编语言</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h3&gt;&lt;p&gt;最近参加&lt;a href=&quot;https://github.com/deeplang-org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;deeplang&lt;/code&gt;&lt;/a&gt;的的过程中，接触到了一些编译领域的新技术，总结一下希望有时间了可以进一步的深入了解。参考资料是&lt;a href=&quot;https://book.douban.com/subject/30396640/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebAssembly标准入门&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://haotianmcihael.github.io/categories/JavaScript/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="PL" scheme="http://haotianmcihael.github.io/tags/PL/"/>
    
      <category term="WebAssembly" scheme="http://haotianmcihael.github.io/tags/WebAssembly/"/>
    
  </entry>
  
  <entry>
    <title>LLVM漫谈（2-Implementing a Language）</title>
    <link href="http://haotianmcihael.github.io/2020/07/07/LLVM%E6%BC%AB%E8%B0%88%EF%BC%882-Implementing-a-Language%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2020/07/07/LLVM漫谈（2-Implementing-a-Language）/</id>
    <published>2020-07-06T23:05:29.000Z</published>
    <updated>2022-03-16T10:29:57.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>基于<code>LLVM</code>实现简单的编程语言<code>kaleidoscope</code>，来源于<a href="https://releases.llvm.org/9.0.0/docs/tutorial/LangImpl01.html" target="_blank" rel="noopener">LLVM9.0.0 tutorial</a>。  </p><p><code>LLVM</code>的官方文档还是很不错的，阅读完其中的<strong>tutorials</strong>就能大致上手<code>LLVM</code>了。实现的代码对<code>C++11</code>要求比较高，我放在了<a href="https://github.com/haotianmichael/LLVMSet/tree/master/Kaleidoscope" target="_blank" rel="noopener">Github</a>上。  </p><p>实现共分为10部分：</p><ul><li>实现<strong>词法分析器Lexer</strong></li><li>使用<strong>递归下降</strong>和<strong>运算符优先级解析</strong>实现<strong>语法分析器Parser</strong></li><li>将<strong><code>AST</code></strong>转化成<strong><code>LLVM-IR</code></strong></li><li>添加<strong><code>JIT</code>即时编译</strong>和<strong>优化器</strong>的支持</li><li>扩展——<strong>控制流</strong>，这一章会引入<strong><code>SSA</code></strong>概念</li><li>扩展——<strong>用户定义运算符</strong></li><li>扩展——<strong>自动变量</strong>，深入<strong><code>SSA</code></strong></li><li>目标代码生成</li><li>扩展——<strong>添加调试器</strong></li><li>深入——<strong>GC，异常等</strong></li></ul><a id="more"></a><h1 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h1><h2 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h2><h2 id="C-原理"><a href="#C-原理" class="headerlink" title="C++原理"></a>C++原理</h2><h1 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM-IR"></a>LLVM-IR</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;基于&lt;code&gt;LLVM&lt;/code&gt;实现简单的编程语言&lt;code&gt;kaleidoscope&lt;/code&gt;，来源于&lt;a href=&quot;https://releases.llvm.org/9.0.0/docs/tutorial/LangImpl01.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LLVM9.0.0 tutorial&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;LLVM&lt;/code&gt;的官方文档还是很不错的，阅读完其中的&lt;strong&gt;tutorials&lt;/strong&gt;就能大致上手&lt;code&gt;LLVM&lt;/code&gt;了。实现的代码对&lt;code&gt;C++11&lt;/code&gt;要求比较高，我放在了&lt;a href=&quot;https://github.com/haotianmichael/LLVMSet/tree/master/Kaleidoscope&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上。  &lt;/p&gt;
&lt;p&gt;实现共分为10部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现&lt;strong&gt;词法分析器Lexer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;递归下降&lt;/strong&gt;和&lt;strong&gt;运算符优先级解析&lt;/strong&gt;实现&lt;strong&gt;语法分析器Parser&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;&lt;code&gt;AST&lt;/code&gt;&lt;/strong&gt;转化成&lt;strong&gt;&lt;code&gt;LLVM-IR&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;添加&lt;strong&gt;&lt;code&gt;JIT&lt;/code&gt;即时编译&lt;/strong&gt;和&lt;strong&gt;优化器&lt;/strong&gt;的支持&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;控制流&lt;/strong&gt;，这一章会引入&lt;strong&gt;&lt;code&gt;SSA&lt;/code&gt;&lt;/strong&gt;概念&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;用户定义运算符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;自动变量&lt;/strong&gt;，深入&lt;strong&gt;&lt;code&gt;SSA&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目标代码生成&lt;/li&gt;
&lt;li&gt;扩展——&lt;strong&gt;添加调试器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;深入——&lt;strong&gt;GC，异常等&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>LLVM漫谈（1-LLVM编译框架）</title>
    <link href="http://haotianmcihael.github.io/2020/06/25/LLVM%E6%BC%AB%E8%B0%88%EF%BC%881-LLVM%E7%BC%96%E8%AF%91%E6%A1%86%E6%9E%B6%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2020/06/25/LLVM漫谈（1-LLVM编译框架）/</id>
    <published>2020-06-25T04:53:37.000Z</published>
    <updated>2022-03-16T10:29:30.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p><strong>LLVM</strong>，这个星球最牛逼的编译器。  </p><p>其核心设计理念就是<strong>统一的底层中间表达以及模块化的软件工程化方法。</strong>LLVM采用了<code>前端-优化器-后端</code>的组织形式，<strong>只是不同的前端和后端都采用统一的底层中间表示格式（LLVM IR）来最大可能复用优化器的代码。</strong>  </p><p>在<a href="http://nondot.org/sabre/" target="_blank" rel="noopener">Chris Lattner</a>将其开源后，<a href="http://llvm.org/" target="_blank" rel="noopener">LLVM</a>逐渐发展成为了成熟的编译框架，具有大量库和编译链工具。</p><p>我使用的平台是<code>macOS Mojave 10.14</code>，在编译的时候要注意版本是否兼容。  </p><p><strong>一般系统会通过打印二进制文件名称和无法加载的动态库的名称来发现链接错误。当屏幕上打印动态库名称时要予以注意，这说明系统动态链接器和加载器无法加载该库，因为该程序与当前系统不兼容。</strong>  </p><p>我编译<code>LLVM 10.0.0</code>的时候出错如下：</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>后来发现这个版本的<code>Xcode</code>工具链最高只支持<code>LLVM 9.0.0</code>版本，然后换了版本最后编译成功。</p><a id="more"></a><h1 id="BUILD"><a href="#BUILD" class="headerlink" title="BUILD"></a>BUILD</h1><div class="table-container"><table><thead><tr><th>Subproject Deployed On My System</th><th>Note</th></tr></thead><tbody><tr><td><strong>llvm-core</strong></td><td><strong>modern source- and target-independent <a href="http://llvm.org/docs/Passes.html" target="_blank" rel="noopener">optimizer</a>, along with <a href="http://llvm.org/docs/CodeGenerator.html" target="_blank" rel="noopener">code generation support</a> for many popular CPUs</strong></td></tr><tr><td><strong>Clang</strong></td><td><strong>“LLVM native” C/C++/Objective-C compiler front-end</strong></td></tr><tr><td><strong>LLDB</strong></td><td><strong>native debugger</strong></td></tr><tr><td><strong>LLD</strong></td><td><strong>native linker</strong></td></tr><tr><td><strong>libcxx/libcxxabi</strong></td><td><strong>standard conformant and high-performance implementation of the C++ Standard Library,</strong></td></tr><tr><td><strong>compiler-rt</strong></td><td><strong>highly tuned implementations of the low-level code generator support routines and implementations of run-time libraries</strong></td></tr></tbody></table></div><h2 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h2><p>以上的<code>subproject</code>通过以下编译方式完成部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//ought to download source of subprojects to local, besides </span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /LLVM/llvm-build  &amp;&amp; <span class="built_in">cd</span> //LLVM/llvm-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G Ninja -DLLVM_ENABLE_PROJECTS=<span class="string">'lldb;clang;compiler-rt;lld;'</span> \    </span></span><br><span class="line">        -DCMAKE_INSTALL_PREFIX='/LLVM/llvm-install'  \</span><br><span class="line">        ~/where you put llvm-src</span><br><span class="line"><span class="meta">$</span><span class="bash"> ninja &amp;&amp; ninja install</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> $?   //check</span></span><br></pre></td></tr></table></figure><h2 id="libcxx-libcxxabi"><a href="#libcxx-libcxxabi" class="headerlink" title="libcxx/libcxxabi"></a>libcxx/libcxxabi</h2><p>这里理清楚一个概念：</p><ul><li><code>glic</code>是<code>linux</code>最重要的运行库，其实现最底层的<code>API</code>供其他库使用比如<code>malloc/printf</code>等。</li><li><code>libstdc++</code>是一个<code>C++</code>标准库，如果跑在<code>linux</code>则依赖<code>Glibc</code></li><li><code>libcxx</code>是<code>LLVM</code>专门开发的一个代替<code>libstdc++</code>的<code>c++</code>标准库</li><li><code>compiler-rt</code>是<code>LLVM</code>开发来替代<code>libgcc</code>,主要用于为硬件不支持的低级功能提供特定于目标的支持</li></ul><p><code>clang++</code>构建可执行文件的时候使用<code>libcxx</code>或者<code>libclc</code>(OpenCL运行时库)。其中<code>libcxx</code>实现由<strong>库本身和一个低级函数层<code>libcxxabi</code>组成，这个函数层用来处理异常和运行时类型信息(RTTI)等功能，这种分离式设计使得<code>libcxxabi</code>更容易移植。</strong>  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/llvm/llvm-project.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> llvm-project</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /LLVM/libcxx-build &amp;&amp; <span class="built_in">cd</span> /LLVM/libcxx-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G Ninja -DCMAKE_C_COMPILER=clang \</span></span><br><span class="line">        -DCMAKE_CXX_COMPILER=clang++ \</span><br><span class="line">        -DLLVM_ENABLE_PROJECTS="libcxx;libcxxabi" \</span><br><span class="line">        -DCMAKE_INSTALL_PREFIX='/LLVM/llvm-install'   \</span><br><span class="line">        ~/where you put libcxx-src</span><br><span class="line"><span class="meta">$</span><span class="bash"> make <span class="comment"># Build</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make check-cxx <span class="comment"># Test</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install-cxx install-cxxabi <span class="comment"># Install</span></span></span><br></pre></td></tr></table></figure><h2 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h2><p>其中<code>llvm</code>和<code>libcxx</code>我是分开编译的，而且<strong>编译目录和安装目录都是指定的目录，默认很可能会安装到系统路径下，从而带来错误。</strong>  </p><ul><li><p><code>~/Document/LLVM9.0.0/</code></p><ul><li><code>llvm</code>   //llvm源代码</li><li><code>libcxx</code>   //libcxx源代码</li></ul></li><li><p><code>/LLVM/</code></p><ul><li><code>llvm-build</code>    //llvm编译路径</li><li><code>llvm-install</code>   //llvm安装路径</li></ul></li><li><code>/LLVM/</code><ul><li><code>libcxx-build</code>   //libcxx编译路径</li><li><code>libcxx-install</code>  //libcxx安装路径</li></ul></li></ul><h1 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h1><h2 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h2><p><code>LLVM</code>中最核心的就是<code>LLVM-IR</code> ：    </p><ul><li><strong><code>SSA</code>表示和允许快速优化的无限寄存器</strong></li><li><strong>通过将整个程序存储在磁盘IR表示中，实现便捷的链接时优化</strong></li></ul><p>当然<code>LLVM</code>不仅仅只有一种中间表示形式：  </p><ul><li>将<code>C</code>或<code>C++</code>转换为<code>LLVM-IR</code>的时候，<code>Clang</code>将使用<strong>抽象语法树<code>AST</code>结构</strong>在内存中表示程序</li><li>将<code>LLVM-IR</code>转换为特定于机器的汇编语言的时候，<code>LLVM</code>首先将程序转换为<strong>有向无环图<code>DAG</code></strong>格式以便进行<strong>指令选择</strong>，然后将其转换回<strong>三地址表示</strong>以进行<strong>指令调度</strong></li><li>为了实现汇编器和链接器，<code>LLVM</code>使用第四种中间数据结构<code>MCModule</code>在对象文件的上下文中保存成程序表示</li></ul><p>在整个框架中，”库”是一个很核心的概念。很多二进制工具都可以直接调用库来实现。而<strong>Clang作为编译驱动程序则可以通过链接小工具的库来实现其功能——代码重用。</strong>故<code>clang</code>在二进制文件中是最大的，因为它链接并利用了整个<code>LLVM</code>生态系统。<strong>而开发者一般都是将LLVM各个组件看出是库。</strong>  </p><p><img src="2.png" width="50%" height="50%" alt=""></p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><p><code>clang</code>作为编译器驱动程序隐式的调用从前端到链接器的所有工具。<strong>整个过程都是在内存中完成的，并不会将中间文件输出到磁盘中。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang hello.c -o hello</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clang -<span class="comment">### hello.c -o hello          //可以查看驱动程序调用的所有工具</span></span></span><br></pre></td></tr></table></figure><h3 id="独立工具"><a href="#独立工具" class="headerlink" title="独立工具"></a>独立工具</h3><p><code>LLVM</code>独立工具会将中间文件输出到磁盘上。  </p><div class="table-container"><table><thead><tr><th>Tools</th><th>Notes</th></tr></thead><tbody><tr><td><code>opt</code></td><td><strong>在IR级别对程序进行优化的工具，输入必须是LLVM位码文件(编码的LLVM-IR)，并且生成的输出文件必须具有相同的类型</strong></td></tr><tr><td><code>llc</code></td><td><strong>通过特定后端将LLVM位码转换为目标机器汇编语言文件或目标文件的工具，可以通过传递参数来选择优化级别，打开调试选项以及启用或禁用特定与目标的优化</strong></td></tr><tr><td><code>llvm-mc</code></td><td><strong>能够汇编指令并生成诸如<code>ELF</code>,<code>Mach-O</code>,<code>PE</code>等对香格式的可执行目标文件，也可以反汇编相同的对象，从而转储这些指令的汇编信息和内部<code>LLVM</code>机器指令数据结构</strong></td></tr><tr><td><code>lli</code></td><td><strong>是<code>LLVM IP</code>的解释器和<code>JIT</code>编译器</strong></td></tr><tr><td><code>llvm-link</code></td><td><strong>将几个<code>LLVM</code>位码链接在一起，以产生一个包含所有输入的<code>LLVM</code>位码</strong></td></tr><tr><td><code>llvm-as</code></td><td><strong>将人工可读的<code>LLVM-IR</code>文件(称为<code>LLVM</code>汇编码)转换为<code>LLVM</code>位码</strong></td></tr><tr><td><code>llvm-dis</code></td><td><strong>将<code>LLVM</code>位码解码成为<code>LLVM</code>汇编码</strong></td></tr></tbody></table></div><h4 id="emit-llvm"><a href="#emit-llvm" class="headerlink" title="-emit-llvm"></a><code>-emit-llvm</code></h4><ul><li><strong>LLVM位码</strong>：  编码的<code>LLVM-IR</code></li><li><strong>LLVM汇编码</strong>： 人工可读的<code>LLVM-IR</code></li></ul><p>假设<code>main.c</code>和<code>sum.c</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ vim main.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">main(<span class="keyword">void</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> r = sum(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"r = %d\n"</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ vim sum.c</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接使用<strong>编译器驱动程序<code>Clang</code></strong>的话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang main.c sum.c -o sum</span></span><br></pre></td></tr></table></figure><p>如果使用独立工具的话:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -emit-llvm -c main.c -o main.bc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clang -emit-llvm -c sum.c -o sum.bc</span></span><br></pre></td></tr></table></figure><p>其中<code>-emit-llvm</code>编译选项可以让<code>clang</code>根据<code>-c</code>或者<code>-S</code>参数来生成<strong><code>LLVM</code>位码</strong>还是<strong><code>LLVM</code>汇编码</strong>。  </p><ul><li><code>-c</code>  生成LLVM位码</li><li><code>-c -S</code>生成LLVM汇编码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -emit-llvm -c -S main.c -o main.ll</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clang -emit-llvm -c -S sum.c -o sum.ll</span></span><br></pre></td></tr></table></figure><h4 id="llc"><a href="#llc" class="headerlink" title="llc"></a>llc</h4><p>该工具从每个LLVM位码文件内生成特定于目标的可重定位目标文件，并通过将其链接到系统链接器来构建可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> llc -filetype=obj main.bc -o main.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> llc -filetype= obj sum.bc -o sum.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clang main.o sum.o -o sum</span></span><br></pre></td></tr></table></figure><h4 id="llvm-link"><a href="#llvm-link" class="headerlink" title="llvm-link"></a>llvm-link</h4><p>该工具将多个LLVM位码文件连接成为最终的LLVM位码文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> llvm-link main.bc sum.bc -o sum.linked.bc</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> llc -filetype=obj sum.linked.bc -o sum.linked.o</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> clang sum.linked.o -o sum</span></span><br></pre></td></tr></table></figure><p>可以看到所有的二进制工具都围绕几个中间形式的表示展开，这些中间表示在编译过程中占很重要的作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;LLVM&lt;/strong&gt;，这个星球最牛逼的编译器。  &lt;/p&gt;
&lt;p&gt;其核心设计理念就是&lt;strong&gt;统一的底层中间表达以及模块化的软件工程化方法。&lt;/strong&gt;LLVM采用了&lt;code&gt;前端-优化器-后端&lt;/code&gt;的组织形式，&lt;strong&gt;只是不同的前端和后端都采用统一的底层中间表示格式（LLVM IR）来最大可能复用优化器的代码。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;http://nondot.org/sabre/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Chris Lattner&lt;/a&gt;将其开源后，&lt;a href=&quot;http://llvm.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LLVM&lt;/a&gt;逐渐发展成为了成熟的编译框架，具有大量库和编译链工具。&lt;/p&gt;
&lt;p&gt;我使用的平台是&lt;code&gt;macOS Mojave 10.14&lt;/code&gt;，在编译的时候要注意版本是否兼容。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般系统会通过打印二进制文件名称和无法加载的动态库的名称来发现链接错误。当屏幕上打印动态库名称时要予以注意，这说明系统动态链接器和加载器无法加载该库，因为该程序与当前系统不兼容。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;我编译&lt;code&gt;LLVM 10.0.0&lt;/code&gt;的时候出错如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;1.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;后来发现这个版本的&lt;code&gt;Xcode&lt;/code&gt;工具链最高只支持&lt;code&gt;LLVM 9.0.0&lt;/code&gt;版本，然后换了版本最后编译成功。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
  </entry>
  
  <entry>
    <title>LLVM漫谈（0-编译系统概述）</title>
    <link href="http://haotianmcihael.github.io/2020/06/02/LLVM%E6%BC%AB%E8%B0%88%EF%BC%880-%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%EF%BC%89/"/>
    <id>http://haotianmcihael.github.io/2020/06/02/LLVM漫谈（0-编译系统概述）/</id>
    <published>2020-06-01T20:36:42.000Z</published>
    <updated>2022-03-16T10:28:29.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>从开始接触编译系统的学习已经快半年了，有些心得总结一下。  </p><p>什么是编译系统？我想从两个角度谈一下：  </p><p>首先从技术角度来讲，广义的编译系统负责将高级语言转换成为CPU可执行的二进制机器代码。编译系统包括<strong>编译器</strong>， <strong>汇编器</strong>，<strong>静态/动态链接器</strong>，<strong>操作系统装载器</strong>以及<strong>运行库</strong>。</p><ul><li>编译器： 是系统前半部分的核心，负责将源文件<strong>.c</strong>转换成为汇编文件<strong>.s</strong>。</li><li>汇编/链接/装载器：是系统后半部分的核心，主要是将<strong>.s</strong>转换为<strong>二进制ELF文件</strong>并进一步围绕<strong>ELF</strong>处理。</li><li>运行库：是操作系统层面用来支持<strong>高级语言运行环境</strong>比如内存池，标准API等的库文件。</li></ul><p>然后从专业的角度来讲，我觉得可以分为<strong>系统层面</strong>和<strong>算法优化层面</strong>，系统层面主要是整个编译框架比如LLVM，核心是和操作系统交互的部分，这部分内容是编译器工程师的基本功，需要掌握细节。而算法优化层面指的是<strong>编译优化</strong>——编译器工程师的最理想的方向就是做优化，这一部分需要精通，从静态单赋值SSA等传统的静态分析优化到现在主流的深度学习推理引擎比如TVM等。  </p><p>本文主要是对系统层面的学习，对系统层面的学习止步于对LLVM编译框架的使用和源代码阅读。</p><a id="more"></a> <h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本文主要分为三个部分，编译，ELF以及库文件。  </p><p>首先简单介绍一下编译器的整体框架和编译流程。    </p><p><strong>核心部分是学习*nix操作系统下的ELF文件的格式——普通c/c++高级程序在目标文件中是如何存储的；目标文件是如何被链接器链接在一起，并且形成可执行文件的过程。目标文件在链接时符号处理，重定位和地址分配如何进行。可执行文件如何被装载并且执行，可执行文件与进程的虚拟空间之间如何映射。讲解动态链接。  </strong></p><p>最后讲解一下运行库的原理和操作系统与编译系统交互的部分。   </p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器分为前端和后端，直观上讲<strong>就是将源语言形式化的表示并翻译成为汇编目标语言</strong>。前端主要有：</p><ul><li><p><strong>词法分析器</strong></p></li><li><p><strong>语法分析器</strong>，</p></li><li><strong>语义分析器</strong></li></ul><p>等完成源语言的语法推导，语义处理，然后将特定信息收集到符号表中，不同的编译器前端会生成不同的<strong>中间表示</strong>——比如<strong>LLVM IR</strong>就是一种非常重要的中间代码。    </p><p>后端主要是：</p><ul><li><p><strong>寄存器分配</strong></p></li><li><p><strong>指令选择</strong></p></li><li><p><strong>指令调度</strong></p></li></ul><p><strong>后端和目标机的关系比较紧密，也是优化的重点平台。     </strong></p><h1 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h1><p>当编译器将源文件翻译成为汇编语言之后，<strong>.s</strong>文件需要进一步的被<strong>汇编器</strong>进行转换成为<strong>可重定位目标文件（Relocatable File）</strong>。  </p><p>因为汇编语言本质上就是助记符，<strong>汇编器就是将汇编文件翻译成为机器可执行的初步的二进制文件，这里的初步是汇编器汇编之后生成的.o文件还不能直接在操作系统中运行，这是因为.o文件中很多符号和变量的地址都没有确定——属于相对地址，所以无法加载到进程地址空间中，而且其运行还需要操作系统提供的运行库提供支持，这一切都需要链接器来完成。所以.o文件又称为可重定位目标文件。</strong>  </p><p>从<strong>.s</strong>文件翻译成为<strong>.o</strong>文件，必须按照特定指令集的机器码，还有ELF文件的格式来转换，实现起来不是很难——<strong>需要精通目标机器的体系结构，以及目标机器的ELF文件格式</strong>。这里不涉及体系结构的知识。</p><h1 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h1><h2 id="ELF简介"><a href="#ELF简介" class="headerlink" title="ELF简介"></a>ELF简介</h2><p>其实从汇编器的实现中就已经用到了ELF的知识。  </p><p>ELF可以说是编译系统工具链中的最重要的文件格式了，离开编译器之后的所有编译步骤几乎都和ELF相关或者围绕ELF展开，所以对它的研究非常有意义。  </p><p>最早是由Unix System V Release3提出了COFF的概念以及使用规范。后来Windows基于COFF指定了PE格式标准，而Linux也以ELF作为基本格式。COFF的主要贡献就是提供了“段segment”的概念。</p><h2 id="ELF类型"><a href="#ELF类型" class="headerlink" title="ELF类型"></a>ELF类型</h2><p>根据ELF文件标准，可以分为下面4类：</p><div class="table-container"><table><thead><tr><th>ELF文件类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td><strong>可重定位目标文件(Relocatable File)</strong></td><td>由汇编器生成的.o文件，又被称为<strong>目标文件</strong>，因为需要连接重定位其文件中的符号地址所以叫Relocatable；另外，<strong>静态链接库.a其实也是使用ar程序将很多.o文件压缩并对其进行索引和编号。所以也算此类型。</strong></td><td>Linux下的.o文件，.a静态库文件；Windows下的.obj，.lib静态库文件</td></tr><tr><td><strong>可执行文件(Executable File)</strong></td><td>是可以直接执行的程序，又被称为<strong>可执行文件</strong>。</td><td>/usr/bash文件；Windows下的.exe</td></tr><tr><td><strong>共享目标文件(Shared Object File)</strong></td><td><strong>共享</strong>就是动态链接的本质。其可以被链接器继续链接生成新的目标文件；也可以和可执行文件结合，作为进程映像的一部分来运行。</td><td>Linux下的.so；Windows下的DLL</td></tr><tr><td><strong>核心转储文件(Core Dump File)</strong></td><td>当进程意外终止的时候，系统可以将该进程的地址空间及终止时的一些其他信息转储到核心转储文件中。</td><td>Linux下的core dump</td></tr></tbody></table></div><h2 id="ELF格式"><a href="#ELF格式" class="headerlink" title="ELF格式"></a>ELF格式</h2><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>以目标文件<strong>.o</strong>为例介绍，目标文件中的内容至少含有编译后的机器指令<strong>代码和数据</strong>。按照COFF的历史规定，ELF格式也是按照<strong>段-segment</strong>来管理的。下面是ELF文件的基本格式：</p><p><img src="1.png" width="50%" height="50%" alt=""></p><p>从图中可以看到，ELF的开头是<strong>ELF Header</strong>，描述了整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接及入口地址（如果是可执行文件的话），目标硬件，操作系统等信息。ELF中第二重要的数据结构是<strong>Section Header table</strong>——描述文件中各个段的数组。段表描述了文件中各个段在文件中的偏移量以及段的属性等，从其中可以得到每个段的所有信息。<strong>ELF Header</strong>后面就是各个段的内容。分段的目的如下：</p><ul><li>当指令和数据分离的时候，<strong>操作系统可以分配不同的读写权限便于管理</strong></li><li>当指令和数据分离的时候，<strong>CPU缓存的命中率会更高</strong></li><li>当指令和数据分离的时候，<strong>多个进程可以共享同一份指令，节省开销</strong></li></ul><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h3><p>是ELF文件最开头的一个结构体。它包含了描述整个文件的基本属性。因为ELF文件在各个平台下都通用，为了对每个成员的大小做出明确的规定以便保持兼容性。ELF使用typedef定义了一套自己的变量体系类似<code>Elf32_Addr</code>这种。下面简单列出文件头中的关键信息：</p><ul><li>ELF魔数，文件机器字节长度，数据存储方式，版本，运行平台，</li><li>ABI版本，ELF重定位类型，硬件平台，<strong>入口地址（OS加载的虚拟地址，可重定位目标文件该值为0）</strong>，程序头入口和长度，</li><li><strong>Section Header table的位置（以偏移量的方式）</strong>和长度及段的数量</li></ul><p>魔数：当年的UNIX是在PDP小型机器上开发的，而当时的系统加载可执行文件直接从第一个字节开始运行，人们一般将第一条指令设置为跳转指令，这个魔数就是当时的JMP指令，为了兼容性被保留下来。</p><h3 id="Section-Header-table"><a href="#Section-Header-table" class="headerlink" title="Section Header table"></a>Section Header table</h3><p>段表描述了ELF的各个段segment的信息比如段名，段长度，段偏移以及段的读写权限等。  实现上，一般会采取一个结构体数组来表示段表。  </p><ul><li>段类型： 很多类型比如<code>.data</code>,<code>.text</code>或者<code>.rel</code>,<code>.string</code>等</li><li>段标志位：表示该段在进程内虚拟地址空间中的属性</li></ul><h3 id="Relocation-Table"><a href="#Relocation-Table" class="headerlink" title="Relocation Table"></a>Relocation Table</h3><p>目标文件中代码段和数据段那些对绝对地址的引用，需要在链接的时候重定位。每一个需要重定位的位置，最后都会有一个<strong>相应的重定位表</strong>比如<code>.rel.txt</code>,<code>.rel.data</code>等。  </p><h3 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h3><ul><li><code>.data</code>:  保存初始化的全局变量和局部静态变量</li><li><code>.bss</code>:  保存未初始化的全局变量和局部静态变量</li><li><code>.data</code>: 保存代码段，等等</li></ul><p>整个ELF文件有很多段比如字符串段，调试信息段strip等。包括在不同的平台标准上ELF格式都不同，这里不展开说了。  </p><h1 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h1><p>链接的本质就是要把多个不同的目标文件之间相互“粘”在一起——<strong>实际上就是目标文件之间地址的引用，及对函数和变量的地址的引用。</strong>  </p><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p><strong>在链接过程中，每一个ELF目标文件都会有一个相应的符号表，这个符号表对应ELF中的一个段<code>.symtab</code>，这个表里记录了目标文件所用到的所有符号，每个定义的符号有一个符号值，对于变量和函数来说该值就是其地址。</strong>      </p><p>ELF的符号可以大致分为：</p><ul><li><strong>定义</strong>在目标文件中的<strong>全局符号</strong></li><li>在目标文件内中<strong>引用</strong>的<strong>全局符号，又称为外部符号</strong></li><li>段名</li><li>局部符号</li><li>链接器在生成可执行文件的时候，自行定义的特殊符号比如程序起始地址<code>__executable_start</code></li></ul><p>其中最重要的就是<strong>全局符号</strong>，因为其他的符号只是在目标文件中可见，而全局符号的作用域是跨文件的。</p><p>UNIX系统通过<strong>符号修饰</strong>和<strong>函数签名</strong>机制防止不同目标文件中的符号名称冲突。  </p><h3 id="强-弱符号-定义-引用"><a href="#强-弱符号-定义-引用" class="headerlink" title="(强/弱符号)(定义/引用)"></a>(强/弱符号)(定义/引用)</h3><p>编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。<strong>强符号和弱符号都是针对定义来说的，不是针对符号的引用。</strong>  </p><ul><li>不同的目标文件中不允许有同名的强符号</li><li>强符号可以屏蔽弱符号</li></ul><p>而当外部变量的符号引用在目标文件被链接成为可执行文件时，如果是强引用，如果定义不存在则报错，而弱引用不会报错。<strong>强/弱引用一般用于库文件的链接过程。</strong>  </p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>链接器一般都采用<strong>Two-pass Linking</strong>的方式：</p><ul><li><strong>空间与地址分配：</strong>  扫描所有的输入文件，获得它们各个段的长度，属性和位置，<strong>并将输入目标文件中的符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表。</strong></li><li><strong>符号解析与重定位：</strong>  读取输入文件中段的数据，重定位信息；进行<strong>符号解析与重定位，调整代码中的地址。</strong><ul><li>各个段中的符号地址</li><li>代码中的地址引用</li></ul></li></ul><h3 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h3><p>链接器能够获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度和位置，并建立映射关系。</p><p><img src="2.png" width="50%" height="50%" alt=""></p><h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><p>这里有两部分，符号的地址和代码中的地址。其中链接器在完成地址和空间分配之后就可以确定所有<strong>符号</strong>的虚拟地址了，而链接器就可以根据符号的地址(<strong>通过查找由所有输入目标文件的符号表组成的全局符号表</strong>)对每个需要<strong>重定位的指令——即会用到外部符号的指令</strong>进行地址修正。  </p><h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><p>链接器通过ELF文件中的重定位表来完成指令中地址的调整。</p><h4 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h4><p>指的是和二进制兼容性有关的内容：</p><ul><li>内置类型的大小和在存储器中的放置方式（大端，小端，对齐方式等）</li><li>组合类型（结构体，数组等）的存储方式和内存分布</li><li>外部符号与用户定义的符号之间的命名方式和解析方式</li><li>函数调用方式，比如参数入栈顺序，返回值如何保存等</li><li>堆栈的分布方式，比如参数和局部变量在堆栈中的位置，参数传递方式等</li><li>寄存器使用约定 </li></ul><h4 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h4><p>静态链接库实际上就是一组目标文件的集合。即很多目标文件经过压缩打包之后的一个文件。  </p><p><img src="3.png" width="50%" height="50%" alt=""></p><h2 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h2><h3 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h3><p>首先32位CPU指的是CPU的数据线是32位的，但是其地址线不一定只有32位，PAE地址扩展方式修改了页映射的方式使得可以访问到更多的物理内存。而操作系统提供一个窗口映射的方式，将这些额外的内存映射到进程地址空间中。应用程序可以根据需要来申请和映射，比如Linux中的mmap系统调用。    </p><p>关于现代操作系统的虚拟内存管理机制这里不展开介绍。  </p><h3 id="内核装载ELF可执行文件"><a href="#内核装载ELF可执行文件" class="headerlink" title="内核装载ELF可执行文件"></a>内核装载ELF可执行文件</h3><p>一共有如下四个步骤：</p><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p><strong>第一步是创建一个独立的虚拟地址空间。  </strong></p><p>创建虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构。在i386的Linux下，<strong>创建虚拟地址空间实际上就是分配一个页目录</strong>就可以了，甚至不设置页映射关系——这些等到后面程序发生缺页中断的时候再进行设置（<strong>当程序发生了页错误，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，在设置缺页和物理页框的映射关系</strong>）。     </p><p><strong>这一步本质上就是完成虚拟空间到物理内存的映射关系。</strong></p><h4 id="完成ELF和进程的映射"><a href="#完成ELF和进程的映射" class="headerlink" title="完成ELF和进程的映射"></a>完成ELF和进程的映射</h4><p><strong>第二步是读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。 </strong> </p><p>很明显，这种映射关系是保存在操作系统中的一个数据结构（类似页目录）。<strong>Linux中将进程虚拟空间中的一个段叫做虚拟内存区域（VMA，Virtual Memory Area）。</strong>操作系统在内部保存这种VMA结构，就是因为当程序发生段错误的时候，可以通过查找这样一个数据结构来定位错误页在可执行文件中的位置。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p><strong>第三步是将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</strong>  </p><p>操作系统进行内核堆栈和用户堆栈的切换，CPU运行权限的切换，然后设置CPU的指令寄存器并将控制权交给进程。</p><h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><p>在上述步骤都完成之后，其实可执行文件的真正指令和数据都没有被装载进内存中。<strong>操作系统只是通过可执行文件头部的信息建立起来可执行文件和进程虚存之间的映射关系而已。</strong>  </p><p><strong>当发生一次缺页中断的时候，操作系统将查询这个数据结构，然后找到空页面所在的VMA ，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与物理页之间建立映射关系，完成真正的装载。</strong></p><p><img src="4.png" width="50%" height="50%" alt="">  </p><h3 id="进程虚拟地址空间分布"><a href="#进程虚拟地址空间分布" class="headerlink" title="进程虚拟地址空间分布"></a>进程虚拟地址空间分布</h3><h4 id="ELF文件链接视图和执行视图"><a href="#ELF文件链接视图和执行视图" class="headerlink" title="ELF文件链接视图和执行视图"></a>ELF文件链接视图和执行视图</h4><p>操作系统装载ELF可执行文件的时候是以段segment为单位的，一般只关心跟装载有关的问题，最主要的是段的权限(可读，可写，可执行)。ELF文件中，段的权限往往只有为数不多的几种组合，基本上是三种：</p><ul><li>以代码段为代表的权限为可读可执行的段</li><li>以数据段和BSS段为代表的权限为可读可写的段</li><li>以只读数据段为代表的权限为只读的段</li></ul><p><strong>一般对于相同权限的段，把它们合并在一起作为一个段进行映射——成为segment。多个sections组合成为segment，装载的时候一个segment在进程虚拟空间中只有一个对应的VMA，这样可以明显的减少内部碎片，从而节省了内存空间。  </strong>  </p><p>所以对于系统来讲，section是链接视图，而segment是执行视图。  </p><p>在操作系统装载的时候，VMA除了用来映射可执行文件中的各个segment以外，事实上进程虚拟空间中的堆栈也是以VMA的形式存在的。所以总结一下，操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间，基本原则就是相同权限属性的，有相同映像文件的映射成一个VMA，一个进程基本上可以分为如下几种VMA区域：</p><ul><li>代码VMA，权限只读、可执行；有映像文件</li><li>数据VMA，权限可读写，可执行；有映像文件</li><li>堆VMA，权限可读写，可执行；无映像文件，匿名，可向上扩展</li><li>栈VMA，权限可读写，不可执行；无映像文件，匿名，可向下扩展</li></ul><p><img src="5.png" width="50%" height="50%" alt="">  </p><h4 id="段地址对齐"><a href="#段地址对齐" class="headerlink" title="段地址对齐"></a>段地址对齐</h4><p>因为装载过程是通过虚拟内存的页映射机制完成的。假设页大小默认为4096Bytes，所以如果要将一段物理内存和进程虚拟地址空间之间建立映射关系，<strong>这段内存空间的长度必须是4K的整数倍，并且这段空间在物理内存和进程虚拟地址空间中的起始地址必须是4096的整数倍。  </strong>  系统为了防止碎片化，也会采取一些优化的映射方案，这里不深入了。  </p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>静态链接有<strong>空间浪费</strong>和<strong>更新困难</strong>两个问题。    </p><p>共享文件在内存中只存在一份，这样不仅仅节省内存，还增加CPU缓存的命中率。ELF动态链接文件称为<strong>.so</strong>共享对象文件，而Windows动态链接库称为<strong>.dll</strong>文件。  </p><p>当程序被装载的时候，系统的<strong>动态链接器</strong>会将程序所需要的所有动态链接库装载到进程的地址空间，并且将程序中所有<strong>未决议的符号</strong>绑定到相应的动态链接库中，并进行重定位工作。<strong>也就是说动态链接器把链接这个过程从本来的程序装载前被推迟到装载的时候。</strong>这样的话<strong>动态链接与静态链接相比，性能损失大约在5%以下。这点损失换取空间上的节省和程序构建和升级时的灵活性，是想当值得的。</strong>  </p><p><img src="6.png" width="50%" height="50%" alt="">  </p><h3 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h3><p>由性质可以知道<strong>共享对象在编译的时候不能假设自己在进程虚拟地址空间中的位置。</strong>而可执行文件基本可以确定自己在虚拟地址空间中的起始位置。这里注意动态链接的模块概念：可执行文件模块和正常静态链接一样，而共享对象模块即动态链接库就不行。    </p><p>那共享对象在被加载的时候，如何确定它在进程虚拟地址空间中的位置？  </p><p>这里提出一个问题：<code>如果直接将目标文件推迟到装载的时候再链接可以吗？</code>  </p><p>答案是不行。<strong>动态链接模块被装载映射到虚拟空间之后，指令部分是在多个进程中共享的，由于装载的时候重定位的方法需要修改指令（会影响代码段中的绝对地址引用），所以没有办法做到同一份指令被多个进程共享。</strong>  </p><p>所以最终的解决办法就是：<strong>将共享的指令部分中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一份副本——所谓地址无关代码(PIC, Pisition-independent Code)技术。</strong>   </p><h4 id="代码段地址无关代码"><a href="#代码段地址无关代码" class="headerlink" title="代码段地址无关代码"></a>代码段地址无关代码</h4><p>这里把共享对象模块中的地址引用按照是否跨模块分为两类：模块内部引用和模块外部引用；按照不同的引用方式有可以分为指令引用和数据访问。  </p><ul><li>模块内部的函数调用，跳转等</li><li>模块内部的数据访问，比如模块中定义的全局变量，静态变量</li><li>模块外部的函数调用，跳转等</li><li>模块外部的数据访问，比如模块中定义的全局变量，静态变量</li></ul><p><img src="7.png" width="50%" height="50%" alt="">  </p><p>这里提一下模块间，因为这些全局变量的地址是跟模块装载地址有关的。ELF的做法就是在数据段中建立一个<strong>指向这些变量的指针数组，也被称为全局偏离表(Global Offset Table GOT)</strong>，当代码需要引用该全局变量的时候，可以通过GOT中相对应的项间接引用。  </p><p><img src="8.png" width="50%" height="50%" alt="">  </p><p>链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。GOT在数据段所以可被修改。总结一下：</p><div class="table-container"><table><thead><tr><th></th><th>指令跳转，调用</th><th>数据访问</th></tr></thead><tbody><tr><td>模块内部</td><td>相对跳转和调用</td><td>相对地址访问</td></tr><tr><td>模块外部</td><td>间接跳转和调用GOT</td><td>间接访问GOT</td></tr></tbody></table></div><h5 id="共享模块的全局变量问题"><a href="#共享模块的全局变量问题" class="headerlink" title="共享模块的全局变量问题"></a>共享模块的全局变量问题</h5><p>这里需要注意，如果一个模块引用了一个定义在共享对象的全局变量的时候。编译器无法判断该global是在同一个模块的其他目标文件中，还是定义在另一个共享对象中。  </p><p>解决办法是所有的全局变量都通过GOT访问。  </p><h4 id="数据段地址无关代码"><a href="#数据段地址无关代码" class="headerlink" title="数据段地址无关代码"></a>数据段地址无关代码</h4><p>数据段中也会出现绝对地址引用的情况：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int a;</span><br><span class="line">static int *p = &amp;a;</span><br></pre></td></tr></table></figure><p>这里的指针p就是一个绝对地址。一般来说，如果发现数据段中有绝对地址引用，编译器和链接器会产生一个重定位表。  </p><p>对于可执行文件来说，默认情况下，如果可执行文件是动态链接的，那么编译器会使用PIC的方法来产生可执行文件的代码段部分，以便于不同的进程能够共享代码段，节省内存。所以一般动态链接的可执行文件中会有<code>.got</code>段。  </p><h3 id="动态链接过程"><a href="#动态链接过程" class="headerlink" title="动态链接过程"></a>动态链接过程</h3><p>动态链接情况下，可执行文件的装载与静态链接情况基本一样。首先操作系统会读取可执行文件的头部，检查文件的合法性，然后文件头中读取每个“Segment”的虚拟地址，文件地址和属性，并将它们映射到进程虚拟空间的相应位置，这些步骤跟前面的静态链接情况下的装载基本无异。在静态链接情况下，操作系统接着就可以把控制权转交给可执行文件的入口地址，然后程序开始执行，一切很顺利。  </p><p>但是在动态链接下，操作系统还不能再装载完可执行文件之后就把控制权交给可执行文件，因为我们知道可执行文件依赖于很多共享对象，<strong>这时候可执行文件里对于很多外部符号的引用还处于无效地址的状态，即还没有跟相应的共享对象中的实际位置链接起来</strong>。所以在映射完可执行文件之后，操作系统会其中一个动态链接器。  </p><p>动态链接分为三步：启动动态链接器本身，然后装载所有需要的共享对象，最后是重定位和初始化。  </p><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>因为动态链接的诸多优点，操作系统中一般有很多共享对象——按照合理的组织和使用方式构建起来的共享库。共享库的更新会影响ABI的使用。  </p><h1 id="运行库"><a href="#运行库" class="headerlink" title="运行库"></a>运行库</h1><p>经过前面的介绍，基本上编译系统的概念都介绍完了。下面的部分涉及操作系统接口，也只是简单的介绍一下。  </p><p>操作系统装载程序之后，首先运行的代码并不是<code>main</code>的第一行，而是某些别的代码，这些代码负责准备好<code>main</code>函数执行所需要的环境，并且负责调用<code>main</code>函数，这时候才可以申请内存，使用系统调用，触发异常，访问I/O。在函数返回之后会记录<code>main</code>的返回值，调用<code>atexit</code>注册的函数，然后结束进程。  </p><p>运行这些代码的函数成为<strong>入口函数</strong>或者<strong>入口点</strong>。这些都是运行库的一部分。个人理解运行库的概念就是操作系统和应用层的接口，区别于系统调用，比如Glibc那样。</p><h1 id="常用二进制工具-基于LLVM"><a href="#常用二进制工具-基于LLVM" class="headerlink" title="常用二进制工具(基于LLVM)"></a>常用二进制工具(基于LLVM)</h1><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>llvm-size</code></td><td>查看ELF文件的各个段的大小</td></tr><tr><td><code>llvm-readelf -h</code></td><td>查看ELF Header(部分)</td></tr><tr><td><code>llvm-readelf -S</code></td><td>查看ELF Header(全部)</td></tr><tr><td><code>llvm-objdump -s</code></td><td>将所有ELF段以十六进制的方式打印</td></tr><tr><td><code>llvm-objdump -d</code></td><td>将所有指令段反汇编    <strong>字节寻址,小端</strong></td></tr><tr><td><code>llvm-nm</code></td><td>查看ELF文件的符号表</td></tr><tr><td><code>c++filt</code></td><td>解析函数签名</td></tr><tr><td><code>ld a.o b.o -e main -o ab</code></td><td>直接使用链接器生成可执行文件ab（将main函数作为程序入口）</td></tr><tr><td><code>llvm-objdump -r</code></td><td>查看目标文件的重定位表</td></tr><tr><td><code>ar -t libc.a</code></td><td>查看静态链接库包含了那些文件</td></tr><tr><td><code>clang -fPIC -shared lib.so  lib.c</code></td><td>编译一个共享对象文件</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;从开始接触编译系统的学习已经快半年了，有些心得总结一下。  &lt;/p&gt;
&lt;p&gt;什么是编译系统？我想从两个角度谈一下：  &lt;/p&gt;
&lt;p&gt;首先从技术角度来讲，广义的编译系统负责将高级语言转换成为CPU可执行的二进制机器代码。编译系统包括&lt;strong&gt;编译器&lt;/strong&gt;， &lt;strong&gt;汇编器&lt;/strong&gt;，&lt;strong&gt;静态/动态链接器&lt;/strong&gt;，&lt;strong&gt;操作系统装载器&lt;/strong&gt;以及&lt;strong&gt;运行库&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编译器： 是系统前半部分的核心，负责将源文件&lt;strong&gt;.c&lt;/strong&gt;转换成为汇编文件&lt;strong&gt;.s&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;汇编/链接/装载器：是系统后半部分的核心，主要是将&lt;strong&gt;.s&lt;/strong&gt;转换为&lt;strong&gt;二进制ELF文件&lt;/strong&gt;并进一步围绕&lt;strong&gt;ELF&lt;/strong&gt;处理。&lt;/li&gt;
&lt;li&gt;运行库：是操作系统层面用来支持&lt;strong&gt;高级语言运行环境&lt;/strong&gt;比如内存池，标准API等的库文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后从专业的角度来讲，我觉得可以分为&lt;strong&gt;系统层面&lt;/strong&gt;和&lt;strong&gt;算法优化层面&lt;/strong&gt;，系统层面主要是整个编译框架比如LLVM，核心是和操作系统交互的部分，这部分内容是编译器工程师的基本功，需要掌握细节。而算法优化层面指的是&lt;strong&gt;编译优化&lt;/strong&gt;——编译器工程师的最理想的方向就是做优化，这一部分需要精通，从静态单赋值SSA等传统的静态分析优化到现在主流的深度学习推理引擎比如TVM等。  &lt;/p&gt;
&lt;p&gt;本文主要是对系统层面的学习，对系统层面的学习止步于对LLVM编译框架的使用和源代码阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
      <category term="LLVM" scheme="http://haotianmcihael.github.io/tags/LLVM/"/>
    
      <category term="Linker" scheme="http://haotianmcihael.github.io/tags/Linker/"/>
    
      <category term="Loader" scheme="http://haotianmcihael.github.io/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>GCC-RISCV交叉编译工具链</title>
    <link href="http://haotianmcihael.github.io/2020/02/16/Gcc-RISCV%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>http://haotianmcihael.github.io/2020/02/16/Gcc-RISCV交叉编译工具链/</id>
    <published>2020-02-15T18:16:45.000Z</published>
    <updated>2022-03-16T10:25:43.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Absrtact"><a href="#Absrtact" class="headerlink" title="Absrtact"></a>Absrtact</h3><p>旨在x86平台上编译RISCV架构的可执行文件。  </p><p>RISCV作为一款极具使命感的指令集，其软件栈也是非常完整的。交叉编译环境可以在<a href="https://github.com/riscv/riscv-gnu-toolchain" target="_blank" rel="noopener">这里</a>下载。      </p><p>交叉编译工具链包括:</p><ul><li><code>GCC</code>编译器</li><li>C运行库<ul><li><code>Glibc</code> :    <code>gnu</code>旗下的库，作为<code>linux</code>的标准库和内核打交道</li><li><code>Newlib</code>：  在嵌入式中使用广泛</li></ul></li><li><code>Buntils</code>二进制套件</li><li><code>GDB</code>调试器</li></ul><a id="more"></a><h3 id="不同版本的工具链"><a href="#不同版本的工具链" class="headerlink" title="不同版本的工具链"></a>不同版本的工具链</h3><div class="table-container"><table><thead><tr><th>Version</th><th>Note</th></tr></thead><tbody><tr><td>Riscv-unknown-linux-gnu-gcc</td><td><sup>1</sup>32位架构的<sup>2</sup><strong>Linux版本</strong></td></tr><tr><td>Riscv-unknown-elf-gcc</td><td>32位架构的<strong>非Linux版本</strong></td></tr></tbody></table></div><ul><li>每个版本都有32位架构和64位架构，这里的位数和运行本机的字长无关，<strong>指的是没有通过<code>-march=</code>和<code>-mabi=</code>选项指定RISCV架构的位宽</strong></li><li><strong>Linux版本</strong>指的是<strong>该工具链使用Linux系统中运行的<code>Glibc</code>作为C运行库——</strong>另外的个版本则使用<code>Newlibc</code>库</li></ul><h3 id="交叉编译选项"><a href="#交叉编译选项" class="headerlink" title="交叉编译选项"></a>交叉编译选项</h3><h4 id="march"><a href="#march" class="headerlink" title="-march="></a>-march=</h4><p>​    由于$RISCV$为模块化指令，该选项支持不同的模块化指令集组合,关于$RISCV$模块见后面的介绍:</p><ul><li><code>rv32i[m][a][f[d]][c]</code></li><li><code>rv32g[c]</code></li><li><code>rv64i[m][a][f[d]][c]</code></li><li><code>rv64g[c]</code></li></ul><h4 id="mabi"><a href="#mabi" class="headerlink" title="-mabi="></a>-mabi=</h4><p>​    该选项选定了目标平台所支持的<code>ABI</code>函数调用:</p><ul><li><code>ilp32</code>，<code>ilp32f</code>，<code>ilp32d</code>     32位架构(int-32位   long-32位  long long-64位)</li><li><code>lp64</code>，<code>lp64f</code>，<code>lp64d</code>    64位架构(int-32位    long-64位)</li></ul><h4 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h4><div class="table-container"><table><thead><tr><th>suffix</th><th>Note</th></tr></thead><tbody><tr><td>—</td><td>使用浮点类型操作直接使用RISCV浮点指令进行支持，但是当浮点数作为函数参数进行传递时，无论是单精度还是双精度均需要存储器中的堆栈进行传递</td></tr><tr><td>-f</td><td>使用浮点类型操作直接使用RISCV浮点指令进行支持，但是当浮点数作为函数参数进行传递时，单精度通过寄存拿起传递，双精度通过内存堆栈传递</td></tr><tr><td>-d</td><td>使用浮点类型操作直接使用RISCV浮点指令进行支持，但是当浮点数作为函数参数进行传递时，单/双精度均可通过寄存器传递</td></tr></tbody></table></div><p><strong>只有<code>-march=</code>支持浮点扩展，(-mabi=)才允许加上<code>f/d</code>后缀以支持浮点运算。</strong></p><p><img src="1.png" width="50%" height="50%" alt=""></p><h3 id="RISCV汇编语言简介"><a href="#RISCV汇编语言简介" class="headerlink" title="RISCV汇编语言简介"></a>RISCV汇编语言简介</h3><p><img src="2.png" width="50%" height="50%" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前交叉编译平台主要有两部分:  <code>riscv32-unknown-elf-gcc</code>平台编译生成$RISCV$可执行文件，而<code>qemu-riscv32</code>平台运行<code>RISCV</code>可执行文件。  </p><p><code>qemu</code>是一款很强大的虚拟机，分为系统模式和用户模式，用户模式运行可执行文件，而系统模式模拟特定指令集从而运行操作系统镜像文件。  </p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Absrtact&quot;&gt;&lt;a href=&quot;#Absrtact&quot; class=&quot;headerlink&quot; title=&quot;Absrtact&quot;&gt;&lt;/a&gt;Absrtact&lt;/h3&gt;&lt;p&gt;旨在x86平台上编译RISCV架构的可执行文件。  &lt;/p&gt;
&lt;p&gt;RISCV作为一款极具使命感的指令集，其软件栈也是非常完整的。交叉编译环境可以在&lt;a href=&quot;https://github.com/riscv/riscv-gnu-toolchain&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;下载。      &lt;/p&gt;
&lt;p&gt;交叉编译工具链包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GCC&lt;/code&gt;编译器&lt;/li&gt;
&lt;li&gt;C运行库&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Glibc&lt;/code&gt; :    &lt;code&gt;gnu&lt;/code&gt;旗下的库，作为&lt;code&gt;linux&lt;/code&gt;的标准库和内核打交道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Newlib&lt;/code&gt;：  在嵌入式中使用广泛&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Buntils&lt;/code&gt;二进制套件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GDB&lt;/code&gt;调试器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="RISCV" scheme="http://haotianmcihael.github.io/tags/RISCV/"/>
    
      <category term="Compiler" scheme="http://haotianmcihael.github.io/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>从syscall的角度理解操作系统</title>
    <link href="http://haotianmcihael.github.io/2019/06/25/%E4%BB%8Esyscall%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://haotianmcihael.github.io/2019/06/25/从syscall的角度理解操作系统/</id>
    <published>2019-06-25T06:34:20.000Z</published>
    <updated>2022-03-16T09:53:19.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>操作系统控制硬件资源并完成底层抽象。  </p><p>UNIX和C的发展一脉相承。20世纪80年代以来，针对UNIX的各种<strong>标准化工作</strong>对其实现提供了具体的限制以此来完善系统不同实现之间的可移植性——<strong>ISO-C，IEEE-POSIX以及Single UNIX Specification</strong>等等。    </p><p><strong>这些标准本质上是应用程序和操作系统接口的子集。</strong>一个操作系统的具体实现除了内核之外，最重要的就是对API的封装。<strong>UNIX一般通过系统调用和运行库的方式来完成应用程序接口，比如GNU为Linux开发的Gblic就支持ISO-C和IEEE-POSIX等核心标准。</strong>  </p><p>个人觉得从<strong>系统编程和内存</strong>的角度去理解<strong>文件系统</strong>和<strong>进程/线程</strong>等OS核心概念会比较有趣。  </p><a id="more"></a><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文件系统是一种持久性存储的系统抽象。并涉及到<strong>磁盘空间</strong>和<strong>内存空间</strong>的IO操作，比较难理解：</p><ul><li><strong>文件描述符表</strong>，<strong>打开文件表</strong>，<strong>i节点</strong>是文件存储的本质，而<strong>文件长度</strong>，<strong>文件偏移量</strong>，<strong>文件所占磁盘空间</strong>，<strong>文件用户权限</strong>是文件的重要属性。可以从<code>dup</code>，<code>lseek</code>，<code>stat/chmod</code>等函数理解</li><li><strong>理解内核获取文件的过程是最核心的</strong>。这涉及到<strong>内核页高速缓存</strong>，<strong>用户区间缓冲区</strong>，<strong>标准IO缓冲区</strong>等核心概念。可以从<code>read/write</code>，<code>fgets/fputs</code>，<code>sync/flush</code>函数理解</li><li>从<strong>用户时间</strong>和<strong>CPU时间</strong>理解标准IO函数和<code>read/write</code>等系统调用。<strong>系统调用的开销要大于函数调用。</strong>而这一切都取决于双方缓冲区的选择</li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程是独立功能的程序在数据集合上的一次动态执行过程。  </p><ul><li>准备</li><li>就绪</li><li>阻塞</li><li>执行</li><li>结束</li></ul><p>内核为每个进程维护一个<strong>进程控制块</strong>，从<code>fork/exit/wait</code>等函数可以理解这些状态。另外<code>fork/exec</code>区分了父子进程在创建前后所共享的资源：</p><ul><li>代码段（<strong>但是子进程获得父进程数据空间，堆栈空间的副本</strong>）</li><li>打开的文件描述符</li><li>实际ID，有效ID，设置ID</li><li>存储映像</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>每个线程都包含又表示执行环境所必需的信息，其中包括进程中表示线程的线程ID，一组寄存器值，栈，调度优先级和策略，信号屏蔽字，errno变量以及线程私有数据。<strong>一个进程的的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码，程序的全局内存和堆内存，栈以及文件描述符。</strong>  </p><ul><li>进程是资源分配单位</li><li>线程是CPU调度单位</li></ul><p><strong>多线程切换因为相同那那个的地址空间——页表，因此切换更快。</strong>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;操作系统控制硬件资源并完成底层抽象。  &lt;/p&gt;
&lt;p&gt;UNIX和C的发展一脉相承。20世纪80年代以来，针对UNIX的各种&lt;strong&gt;标准化工作&lt;/strong&gt;对其实现提供了具体的限制以此来完善系统不同实现之间的可移植性——&lt;strong&gt;ISO-C，IEEE-POSIX以及Single UNIX Specification&lt;/strong&gt;等等。    &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些标准本质上是应用程序和操作系统接口的子集。&lt;/strong&gt;一个操作系统的具体实现除了内核之外，最重要的就是对API的封装。&lt;strong&gt;UNIX一般通过系统调用和运行库的方式来完成应用程序接口，比如GNU为Linux开发的Gblic就支持ISO-C和IEEE-POSIX等核心标准。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;个人觉得从&lt;strong&gt;系统编程和内存&lt;/strong&gt;的角度去理解&lt;strong&gt;文件系统&lt;/strong&gt;和&lt;strong&gt;进程/线程&lt;/strong&gt;等OS核心概念会比较有趣。  &lt;/p&gt;
    
    </summary>
    
      <category term="C" scheme="http://haotianmcihael.github.io/categories/C/"/>
    
    
      <category term="OS" scheme="http://haotianmcihael.github.io/tags/OS/"/>
    
      <category term="UNIX" scheme="http://haotianmcihael.github.io/tags/UNIX/"/>
    
      <category term="Syscall" scheme="http://haotianmcihael.github.io/tags/Syscall/"/>
    
  </entry>
  
</feed>
