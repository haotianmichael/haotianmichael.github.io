<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HBlog</title>
  
  <subtitle>Haotian</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://haotianmcihael.github.io/"/>
  <updated>2018-10-11T12:55:15.050Z</updated>
  <id>http://haotianmcihael.github.io/</id>
  
  <author>
    <name>haotianmichael</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编语言（王爽）ch3</title>
    <link href="http://haotianmcihael.github.io/2018/10/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch3/"/>
    <id>http://haotianmcihael.github.io/2018/10/11/汇编语言（王爽）ch3/</id>
    <published>2018-10-10T21:29:35.000Z</published>
    <updated>2018-10-11T12:55:15.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三部分-指令核心"><a href="#第三部分-指令核心" class="headerlink" title="第三部分:指令核心"></a>第三部分:指令核心</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><blockquote><p>内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，<strong>注意这里的内存指的是内存地址空间</strong>。<br>CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。<br><a id="more"></a><br>寻址的方式有很多种类 ，不过归结到底都是<code>段地址+偏移地址</code>。段地址存储在段寄存器中，而偏移地址的方式就有很多种。见下图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/%2013.png" alt="pic13">  </p></blockquote><blockquote><p>需要注意的是:</p><ul><li>上图中的<code>idata</code>表示立即数，<code>[]</code>表示偏移地址。<code>(ax)</code>表示寄存器ax的内容。</li><li><code>[]</code>中的除了立即数之外，只有<code>bx</code>,<code>si</code>,<code>di</code>和<code>bp</code>四个寄存器可以进行寻址，其他的寄存器不行。</li><li><code>[bp]</code>的段寄存器默认是<code>ss</code>。</li></ul></blockquote><h4 id="数据处理-总结性质"><a href="#数据处理-总结性质" class="headerlink" title="数据处理(总结性质)"></a>数据处理(总结性质)</h4><blockquote><p>计算机处理的最终还是数据，那么就有两个最基本的问题:</p><ul><li>处理的数据在什么地方？</li><li>要处理的数据有多长？</li></ul></blockquote><h5 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h5><blockquote><p>绝大部分机器指令都是进行数据处理的指令，处理大致分为三类:读取，写入，运算。在机器指令这一层来说并不关心数据的值，而关心<strong>指令执行前一秒，将要处理的数据所在的位置</strong>。指令在执行之前，所要处理的数据可以在三个地方:CPU内部，寄存器，端口。</p></blockquote><h5 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h5><blockquote><p>8086指令可以处理两种尺寸的数据:Byte和Word。所以在机器指令中需要指明是字操作和字节操作。  </p><ul><li>通过寄存器指明:<code>ax</code>，<code>al</code>等</li><li>用操作符<code>X ptr</code>指明内存单元的长度，<code>X</code>是<code>word</code>或者<code>byte</code>。比如:<code>mov byte ptr ds:[0],1</code>。</li><li>还有一些默认的操作比如栈操作默认为字操作。</li></ul></blockquote><h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4><h5 id="伪指令补充"><a href="#伪指令补充" class="headerlink" title="伪指令补充"></a>伪指令补充</h5><ul><li><code>db</code>    定义字节型数据</li><li><code>dw</code>  定义字型数据</li><li><code>dd</code>  定义双字节型数据</li><li><code>dup</code> 和前面三个伪指令结合使用，用来进行数据的重复。<code>db 3 dup(1,2,3)</code>表示定义的三个字节型数据分别为1,2,3。</li></ul><h5 id="LOOP循环指令"><a href="#LOOP循环指令" class="headerlink" title="LOOP循环指令"></a>LOOP循环指令</h5><blockquote><p>主要进行两步操作，（cx）=(cx)-1，判断cx中的值。不为零则转至标号处执行程序，如果为零则向下执行。可见<code>cx</code>中的值影响了loop指令的执行结果。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:</span><br><span class="line">循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><h5 id="JMP转移指令"><a href="#JMP转移指令" class="headerlink" title="JMP转移指令"></a>JMP转移指令</h5><blockquote></blockquote><h5 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h5><blockquote></blockquote><h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第三部分-指令核心&quot;&gt;&lt;a href=&quot;#第三部分-指令核心&quot; class=&quot;headerlink&quot; title=&quot;第三部分:指令核心&quot;&gt;&lt;/a&gt;第三部分:指令核心&lt;/h2&gt;&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;h4 id=&quot;内存寻址&quot;&gt;&lt;a href=&quot;#内存寻址&quot; class=&quot;headerlink&quot; title=&quot;内存寻址&quot;&gt;&lt;/a&gt;内存寻址&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，&lt;strong&gt;注意这里的内存指的是内存地址空间&lt;/strong&gt;。&lt;br&gt;CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch2</title>
    <link href="http://haotianmcihael.github.io/2018/10/04/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch2/"/>
    <id>http://haotianmcihael.github.io/2018/10/04/汇编语言（王爽）ch2/</id>
    <published>2018-10-03T20:26:50.000Z</published>
    <updated>2018-10-11T07:41:56.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二部分-汇编结构"><a href="#第二部分-汇编结构" class="headerlink" title="第二部分:汇编结构"></a>第二部分:汇编结构</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="汇编语言的结构"><a href="#汇编语言的结构" class="headerlink" title="汇编语言的结构"></a>汇编语言的结构</h4><h5 id="寄存器和内存之间"><a href="#寄存器和内存之间" class="headerlink" title="寄存器和内存之间"></a>寄存器和内存之间</h5><blockquote><p>汇编语言是由不同的段构成的，这些段的功能各异不过主要分为<code>指令</code>和<code>数据</code>两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。<br><a id="more"></a><br><strong>字节存储和字存储</strong>就是两种解决办法，在8086中寄存器是16位的(16位为一字)，而存储器的最小存储单元是8位也就是一个字节，所以如果在一些读写中需要用到字存储而不是字节存储的话，就需要两块连续的内存单元才能完成数据的传输，而且是<strong>高地址存放字的高位字节，低地址存放字的低位字节</strong>。<br><strong>要读写一块内存单元的时候，必须先要给出这个内存单元的地址。</strong>在实验1中我们知道了CPU使用<code>段地址+偏移地址</code>的方式来进行寻址。而实现这些功能的就是一些具有特殊功能的寄存器。这里提到的是最简单的也最常使用的两种类型:  </p><ul><li><code>CS</code>+<code>IP</code>————在任意时刻CPU将CS:IP指向的内容当做指令执行。  </li><li><code>DS</code>+[idata]————<code>DS</code>通常用来存放需要访问的数据的段地址。<br><strong>这里主要介绍汇编语言的结构，对应到寄存器和内存寻址的方式后面会讲。</strong></li></ul></blockquote><h5 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h5><blockquote><p>将一段内存当做数据段，是我们在编程的时候的一种安排，可以在具体操作的时候，<strong>用ds存放数据的段地址，</strong>再根据相关指令访问数据段中的具体单元。</p></blockquote><h5 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h5><blockquote><p>从硬件角度讲，CPU只认被CS:IP指向的内存单元中的内容为指令。要让CPU执行我们放在代码段的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。</p></blockquote><h5 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h5><blockquote><p>   <strong>栈是一种先进后出的数据结构</strong>，这是最基本的栈的概念。这里讲到的栈指的是内存区域。从操作系统的角度讲一个线程需要分配一个栈(stack)。相对应的一个进程需要分配一个堆(heap)。栈的大小在分配的时候就已经确定好了，其作用主要是存放一些局部和确定的变量和数据。<br>   关于栈也有两个寄存器:<code>SS:SP</code>。换句话讲CPU如何知道一段内存区域是不是栈？栈顶的段地址放在<code>SS</code>中，而偏移地址放在<code>SP</code>中。<strong>任意时刻，SS:SP指向栈顶元素</strong>。这是规定。<br>   另外，上微机原理课的时候，老师讲到栈的分类:  </p><ul><li>向高地址生长的称为递增堆栈。</li><li>向地地址生长的称为递减堆栈。<br> 地址延伸主要的影响就是内存中的大端寻址和小端寻址。<br>  <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/4.png" alt="pic4">  </li></ul></blockquote><ul><li>堆栈指针指向最后压入堆栈的有效数据项，叫做满堆栈。</li><li>堆栈指针指向下一个待压入数据的空位置，叫做空堆栈。<br>  <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/5.png" alt="pic5"></li></ul><h5 id="栈指令"><a href="#栈指令" class="headerlink" title="栈指令"></a>栈指令</h5><blockquote><p>   在i386的指令集中，栈操作都是以字为单位的。</p></blockquote><h6 id="push执行过程"><a href="#push执行过程" class="headerlink" title="push执行过程"></a>push执行过程</h6><pre><code>1. SP=SP-2;2. 向`SP:SS`指向的内存字单元中送入数据;</code></pre><h6 id="pop执行过程"><a href="#pop执行过程" class="headerlink" title="pop执行过程"></a>pop执行过程</h6><pre><code>1. 从`SP:SS`指向的内存字单元中读取数据;2. SP=SP+2;</code></pre><h5 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h5><blockquote><p>   之前讨论过关于<strong>段</strong>这个概念。我认为，还是因为在编程的时候可以通过一个系统化的结构来统一汇编语言的实现逻辑。使得这些指令看上去便于管理和协调合作。至于其物理实现，其实就是CPU的寻址方式决定的。书本中有一段话特别经典，我摘抄如下:  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">比如我们将10000H~1001F安排为代码段，并在里面存储如下代码:  </span><br><span class="line"></span><br><span class="line">MOV ax,1000H  </span><br><span class="line">MOV ss,ax</span><br><span class="line">MOV sp,0020H  //初始化栈顶</span><br><span class="line">MOV ax,cs</span><br><span class="line">MOV ds,ax  //设置数据段段地址</span><br><span class="line">MOV ax,[0]</span><br><span class="line">add ax,[2]</span><br><span class="line">add bx,[4]</span><br><span class="line">add bx,[6]</span><br><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax</span><br><span class="line">pop bx  </span><br><span class="line"></span><br><span class="line">设置CS=1000，IP=0.这段代码就会被执行，但是可以看到在这段代码中，我们又将  </span><br><span class="line">10000H~1001FH安排为栈段和数据段。  </span><br><span class="line">可见不管我们如何安排，CPU将内存中的某段内存当做代码，是因CS:IP指向了那里。  </span><br><span class="line">CPU将某段内存当做栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排，  </span><br><span class="line">以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们  </span><br><span class="line">的安排运行的时候做到游刃有余。  </span><br><span class="line">一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。  </span><br><span class="line">关键是在于CPU中寄存器的设置，机CS，IP，SS，SP，DS的指向。</span><br></pre></td></tr></table></figure><h5 id="多个段的统一"><a href="#多个段的统一" class="headerlink" title="多个段的统一"></a>多个段的统一</h5><blockquote><p>以前写的汇编都是单个段，并且主要是代码段。如果内存中的一段汇编代码需要包含多个数据段，代码段，栈段。该如何设计才能保证程序正常运行呢？<br><strong>我们应该有一个概念，就是所谓和CPU对应的程序一定是<code>CS:IP</code>指向的内存地址。</strong>所以实际上这个问题是在问保证<code>CS:IP</code>正确指向程序的前提下，如何让数据段，栈段合理的加进来？<br>这里有个<code>伪指令</code>的概念，伪指令主要是为汇编器提供一些编译的前提信息比如从哪里开始执行代码，其他的段的起始地址在哪里。所以问题也就解决了。</p><ul><li>如何保证<code>CS:IP</code>指向代码段:    <code>end</code>和<code>end start</code></li><li>如何定义一个段: <code>code segment</code>和<code>code ends</code></li><li>如何将段寄存器和段相对应: <code>assume cs:code</code></li></ul></blockquote><h4 id="汇编语言的编译、连接过程及其工具的使用"><a href="#汇编语言的编译、连接过程及其工具的使用" class="headerlink" title="汇编语言的编译、连接过程及其工具的使用"></a>汇编语言的编译、连接过程及其工具的使用</h4><blockquote><p>   这部分详细见书上。  </p></blockquote><h5 id="源程序组成"><a href="#源程序组成" class="headerlink" title="源程序组成"></a>源程序组成</h5><blockquote><p>   一个汇编程序的源程序由<code>汇编指令</code>和<code>伪指令</code>构成。汇编指令指的是编译成为机器指令最终为CPU所执行的代码。伪指令没有相对应的机器指令，主要是由编译器来执行的指令。</p></blockquote><h5 id="编译、链接、执行"><a href="#编译、链接、执行" class="headerlink" title="编译、链接、执行"></a>编译、链接、执行</h5><blockquote><p>源程序经过编译成为可重定位文件，然后经过链接成为可执行文件。可执行文件是可以直接在操作系统中执行的。上述两种文件都属于ELF格式的文件，ELF是Linux下面的一种文件格式，具体的细节在后面的操作系统中会谈到，这里只是了解。<br>    <code>编程</code>（edit）————&gt;<code>1.asm</code>————&gt;<code>编译</code>(masm)————&gt;<code>1.obj</code>————&gt;<code>链接</code>(link)————&gt;<code>1.exe</code>————&gt;<code>加载</code>(shell)————&gt;<code>内存中的程序</code>————&gt;<code>运行</code>(CPU)</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/6.png" alt="pic6"></p><h3 id="工具进阶"><a href="#工具进阶" class="headerlink" title="工具进阶"></a>工具进阶</h3><h4 id="debug-d"><a href="#debug-d" class="headerlink" title="debug -d"></a>debug -d</h4><blockquote><p>第一个实验中使用的debug工具，通过各种参数来对寄存器和内存进行读写。比如<code>d 段地址:偏移地址</code>指令会列出指定内存单元中的内容。但是debug也是一个程序，而能定位内存地址的方式在8086中只有段寄存器可以做到,实际上debug就是通过将地址写入段寄存器中的方式来进行内存寻址。这个原理适用于所有的参数。<br>而使用的这个段寄存器正是<code>DS</code>寄存器。<br>根据这个原理，就可以通过修改寄存器来进阶使用这些命令，比如:<code>-r ds</code>,<code>:1000</code>,<code>-d ds:0</code>这段代码就表示查看从1000：0开始的内存空间中的内容。这里主要是认识到段寄存器DS的寻址功能，为之后的寻址方式打基础。  </p></blockquote><h4 id="debug-p"><a href="#debug-p" class="headerlink" title="debug -p"></a>debug -p</h4><blockquote><p>在整个实验中，debug工具是经常要使用的。debug有两种用法，一种就是使用<code>a</code>参数直接写入程序然后调试。还有一种就是直接调试<code>exe</code>文件。<br>第一种之前一直在用，第二种方式加载的过程有一些不一样，ds段寄存器中存放着该程序的段地址，因为偏移为零所以DS:0就是所加载程序的首地址。而加载进来的程序前256字节存放的是一段通信程序，所以真正的代码是在<code>(DS+10H:0):0</code>开始的。<br>每一段汇编指令都需要以<code>mov ax,4c00H</code>，<code>int 21H</code>结尾。在调试到<code>int 21H</code>的时候需要使用<code>P</code>命令执行。出现<code>Program terminated normally</code>程序正常退出。</p></blockquote><h3 id="实验2-用机器指令和汇编指令编程"><a href="#实验2-用机器指令和汇编指令编程" class="headerlink" title="实验2 用机器指令和汇编指令编程"></a>实验2 用机器指令和汇编指令编程</h3><blockquote><p>这个实验很有意思，一共有两部分:</p></blockquote><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><blockquote><p>使用<code>a</code>将下面的汇编指令写入内存，然后使用<code>T</code>命令调试。如下: </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,10</span><br><span class="line">mov ax,3123</span><br><span class="line">push ax</span><br><span class="line">mov ax,3366</span><br><span class="line">push ax</span><br></pre></td></tr></table></figure><blockquote><p>会发现在单步调试的时候，在<code>mov ss,ax</code>之后的下一条指令竟然不是<code>mov sp,10</code>。但是查看寄存器的时候发现实际上这条执行已经被执行结束了。这是第一个现象。</p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/7.png" alt="pic7"></p><h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><blockquote><p>对上面的代码继续调试，如下：<br>会发现最开始对栈初始化之后，到执行到<code>mov ss,ax</code>指令的时候，查看原来的栈段内容竟然不再是零，且这些数字还都是和段寄存器相关的。  </p></blockquote><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/8.png" alt="pic8"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><p>下图是接下来的每一步后栈段中的内存变化。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/9.png" alt="pic9"><br>可以看到的现象是:开始的时候栈中是没有数据的，栈桢SP指向<code>2000:0010</code>的位置。<br>在<code>mov ss,ax</code>和<code>mov sp,10</code>这两步执行结束之后，发现栈中已经有数据了，这里称为初始化。初始化的一共有6字节的数据:4个字节为<code>CS:IP</code>，还有两字节在栈底确定为<code>01A3H</code>。<br>之后的每一条栈操作的指令执行结束之后栈中的<code>CS:IP</code>值也会跟着变化，这说明每一次指令都有可能产生一次中断。<br>但是在栈底的<code>01A3H</code>一直没有变化估计应该是中断向量号。在正式压栈操作的过程中发现最开始初始化过的那些数据并没有被压到栈底，<strong>这就意味着堆栈指针SP应该还在栈底，然后真正有数据项压栈的时候才会SP-=2操作。</strong></p></blockquote><h5 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h5><blockquote><p>就上面的三个现象，我在想仅仅是初始化的过程就已经占据了一大半栈空间，那如果将栈大小调整成为8字节的。那会出现什么情况？<br>   我将<code>mov sp,10</code>改成<code>mov sp,08</code>；然后准备了8字节数据，所以栈会被压满。这时候我想看看现象。<br>这是一张初始化的图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/10.png" alt="pic10"></p></blockquote><blockquote><p>这是末尾压栈满了的图:<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/11.png" alt="pic11"><br>因为书上关于中断的详细讲解在第四部分，所以这里只是一个猜测。<strong>现象中随着栈不断被压满，之前初始化的那些数据都被挤出去了，具体去哪了不知道。那6个字节的数据到底有什么用也不知道。</strong>  </p></blockquote><h5 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h5><blockquote><p>不过可以知道的是初始化栈帧的时候会有参数压到栈里，参数有<code>CS:IP</code>和中断向量号，其中<code>CS:IP</code>还在<strong>不断变化</strong>。而随着栈中的数据越来越多，栈中的这6个字节的参数被慢慢挤出。难道这6个字节不重要吗，或者说只是在初始化的时候用了一下？但是过程中这些参数一直也在变化，所以不可能不重要.不过这些数据之所以放到栈中的原因一定不是为了存储，否则就不会被随便挤出。<br>结合第一部分实验，<code>mov sp,10</code>是紧跟着前一条指令执行的，所以我能想到的唯一一个合理的解释就是:这些参数是在指令执行过程中直接使用的，而执行过程对shell屏蔽不可见，所以在栈中数据越来越多的时候这些参数还可以随意的移动位置并且被抛弃，这些参数是过程中使用的参数，而这个过程就是中断！至于中断到底是什么，到第4章再详细学习吧。</p></blockquote><h3 id="实验3-用编程、编译、连接、跟踪"><a href="#实验3-用编程、编译、连接、跟踪" class="headerlink" title="实验3 用编程、编译、连接、跟踪"></a>实验3 用编程、编译、连接、跟踪</h3><blockquote><p>最后一个实验查看PSP（就是加载开始前256字节）的内容。<br>使用<code>u</code>来查看汇编好像又和中断有关系。<br><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/12.png" alt="pic12"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第二部分-汇编结构&quot;&gt;&lt;a href=&quot;#第二部分-汇编结构&quot; class=&quot;headerlink&quot; title=&quot;第二部分:汇编结构&quot;&gt;&lt;/a&gt;第二部分:汇编结构&lt;/h2&gt;&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;h4 id=&quot;汇编语言的结构&quot;&gt;&lt;a href=&quot;#汇编语言的结构&quot; class=&quot;headerlink&quot; title=&quot;汇编语言的结构&quot;&gt;&lt;/a&gt;汇编语言的结构&lt;/h4&gt;&lt;h5 id=&quot;寄存器和内存之间&quot;&gt;&lt;a href=&quot;#寄存器和内存之间&quot; class=&quot;headerlink&quot; title=&quot;寄存器和内存之间&quot;&gt;&lt;/a&gt;寄存器和内存之间&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;汇编语言是由不同的段构成的，这些段的功能各异不过主要分为&lt;code&gt;指令&lt;/code&gt;和&lt;code&gt;数据&lt;/code&gt;两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch1</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch1/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch1/</id>
    <published>2018-10-02T09:03:13.000Z</published>
    <updated>2018-10-06T15:20:54.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一部分-硬件模型"><a href="#第一部分-硬件模型" class="headerlink" title="第一部分:硬件模型"></a>第一部分:硬件模型</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="硬件基础"><a href="#硬件基础" class="headerlink" title="硬件基础"></a>硬件基础</h4><blockquote><p>   全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————<code>冯诺依曼结构</code>。<br>   CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？<br><a id="more"></a>  </p></blockquote><ul><li>存储单元的地址（地址）</li><li>读/写操作（控制）</li><li>读/写的具体数据（数据）  </li></ul><blockquote><p> 答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它<code>内存地址空间</code>。  </p></blockquote><blockquote><p> 以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构<code>《微机原理和接口》</code>，也不是讲整个计算机系统的结构和功能<code>《组成原理》</code>。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。<br> 固有的硬件体系指的是这套<code>CPU+RAM</code>的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说<strong>不同的CPU有不同的汇编语言</strong>，用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。</p></blockquote><h4 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h4><blockquote><p>学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。<br>从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是<code>从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算</code>。但是如果我把<code>data1</code>和<code>data2</code>互换一下，其实也是可以的。但是需要考虑到的是<code>data2</code>所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。</p></blockquote><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><blockquote><p>   8086CPU有14个寄存器，都是16位的。但是这16位的寄存器也可以独立作为两个8位的寄存器使用。<br>   寄存器和内存是汇编程序猿眼中最直观的计算机样子。</p></blockquote><h5 id="汇编层面的CPU"><a href="#汇编层面的CPU" class="headerlink" title="汇编层面的CPU"></a>汇编层面的CPU</h5><ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制各种器件进行工作</li><li>内部总线连接各种器件，在它们之间进行数据的传送  </li></ul><h5 id="8086架构（16位机）"><a href="#8086架构（16位机）" class="headerlink" title="8086架构（16位机）"></a>8086架构（16位机）</h5><p>具体深究到物理实现就是《组成原理》知识了。  </p><ul><li>运算器一次最多可以处理16位数据  </li><li>寄存器的最大宽度为16位      </li><li>寄存器和运算器之间的通路为16位  </li></ul><h5 id="汇编层面的内存"><a href="#汇编层面的内存" class="headerlink" title="汇编层面的内存"></a>汇编层面的内存</h5><blockquote><p>CPU在访问内存单元的时候，需要知道内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存空间在这个空间上都有唯一的地址，这个惟一的地址就叫做<code>物理地址</code>。<br>CPU首先在内部形成这个物理地址，然后通过地址总线送入存储器。这个地址一定是一个内存单元的物理地址。不同的CPU架构形成地址的方式不一样。  </p></blockquote><h5 id="CS-IP"><a href="#CS-IP" class="headerlink" title="CS:IP"></a>CS:IP</h5><blockquote><p>   前面提到了8086CPU内部需要形成物理地址，但是8086是16位机————只能处理和传输16位的地址，但是8086的地址总线有20位，所以需要两个16位来共同形成一个20位的地址。<br>    14个寄存器中，CS是段寄存器，存放基地址。而IP存放偏移量。公式:<code>CSx16+IP</code>。<br>  首先需要明白的就是，一个内存单元是8位二进制也叫一个字节。而十六进制的一位可以表示成为二进制的4位。完全只是为了方便才写成16进制的。<strong>20位的地址（5位16进制）</strong>可以写成<code>4C780H</code>，后面的H表示16进制。<code>一个X进制的数据左移一位，相当于乘以X</code>。所以为了记起来方便一些可以记成<code>CS寄存器的数据左移一位+IP寄存器的值</code>。但是<strong>两个寄存器只有16位（4位16进制)</strong>，到后面计算的时候需要注意这两个前提，避免溢出。<br>  书中特别强调了对<strong>段</strong>的理解。这里的段并不是指内存被物理上分成一段一段的。而是因为CPU在管理内存的时候，使用<code>CSx16+IP</code>的方式来进行管理。<strong>所以可以将地址连续，起始地址为16的倍数的一组内存单元看成是一个段。</strong>重点在于不是所有的起始地址都可以作为段地址————这是因为<code>CSx16</code>决定的。而且因为<code>IP</code>是16位的所以每一个段的长度最大为<code>64KB</code>。  </p></blockquote><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><blockquote><p>   <strong>在8086机中，任意时刻CPU将CS:IP指向的内容当做指令执行。</strong>汇编中使用<code>jmp 段地址:偏移地址</code>对CS:IP进行修改。或者使用<code>jmp 寄存器</code>来修改IP的值。  </p></blockquote><h6 id="8086的工作过程"><a href="#8086的工作过程" class="headerlink" title="8086的工作过程"></a>8086的工作过程</h6><ul><li>从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓存器。</li><li>IP指向下一条指令。</li><li>执行指令,从CS:IP中取指令，重复上面的过程。  </li></ul><h3 id="书中划线"><a href="#书中划线" class="headerlink" title="书中划线"></a>书中划线</h3><ul><li>汇编语言和机器语言的差别在于指令的表示方法上。</li><li>微机存储器的容量是以<strong>字节</strong>为最小单位的来计算的。</li><li>在内存和磁盘上，数据和指令没有任何区别。</li><li>在汇编语言这门课中，我们所面对的是<strong>内存地址空间</strong>。CPU向这段地址中读写数据实际上就是向相应的物理存储器中读写数据。</li><li>内存地址空间的大小受到CPU地址总线宽度的限制。</li></ul><h3 id="实验1-查看CPU和内存，用机器指令和汇编指令编程"><a href="#实验1-查看CPU和内存，用机器指令和汇编指令编程" class="headerlink" title="实验1 查看CPU和内存，用机器指令和汇编指令编程"></a>实验1 查看CPU和内存，用机器指令和汇编指令编程</h3><h4 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h4><blockquote><p>   debug是DOS,Windows都提供的实模式（8086方式）程序的调试工具。下面是本次实验将会用到的参数:  </p></blockquote><h5 id="r-读写寄存器"><a href="#r-读写寄存器" class="headerlink" title="r (读写寄存器)"></a>r (读写寄存器)</h5><ul><li><code>r</code>查看所有的寄存器的值</li><li><code>r 寄存器名称</code>修改制定寄存器的值</li></ul><h5 id="d-（读写内存）"><a href="#d-（读写内存）" class="headerlink" title="d （读写内存）"></a>d （读写内存）</h5><ul><li><code>d 段地址:偏移地址</code> 列出从指定内存单元开始的128个内存单元的内容</li><li><code>d 段地址:起始偏移地址 结尾偏移地址</code>列出在偏移地址范围之内的内存单元的内容</li></ul><h5 id="e-（读写内存）"><a href="#e-（读写内存）" class="headerlink" title="e （读写内存）"></a>e （读写内存）</h5><ul><li><code>e 段地址:偏移地址  data1  data2 data3……</code>从特定单元开始讲数据写入内存</li><li><code>e 段地址:偏移地址 回车</code>表示挨个儿修改内存，空格表示默认不修改，回车表示修改结束</li></ul><h5 id="e-u-t"><a href="#e-u-t" class="headerlink" title="e+u+t"></a>e+u+t</h5><ul><li>使用<code>e</code>参数向内存中写入机器码</li><li>使用<code>u 段地址:偏移地址</code>可以将内存中机器码翻译成为汇编语言</li><li><code>t</code>参数执行<code>CS:IP</code>指向的内存地址单元的任何指令，注意修改参数</li></ul><h5 id="a"><a href="#a" class="headerlink" title="a"></a>a</h5><ul><li><code>a 段地址:偏移地址</code>可以直接使用汇编的格式写入机器指令</li></ul><h4 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h4><blockquote><p>   一共有4个实验。写出来的都是我觉得很有意思且值得讨论的实验。  </p></blockquote><h5 id="第二个实验"><a href="#第二个实验" class="headerlink" title="第二个实验"></a>第二个实验</h5><blockquote><p>   给出起始地址为<code>2000:0000</code>的三条指令，使用这三条指令计算2的8次方。<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/2.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>   有意思的是这个算法，a += a；如果这里的a是2的话，实际上<code>a+a</code>等于<code>ax2</code>所以可以2的8次方可以通过8次这样的加法完成，但是如果a是其他的值就不行了。</p></blockquote><h5 id="最后两个实验"><a href="#最后两个实验" class="headerlink" title="最后两个实验"></a>最后两个实验</h5><blockquote><p>使用<code>e</code>参数对特定的内存单元进行读写。<br>    <img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/3.png" width="300" height="200" alt="图片名称" align="center"></p></blockquote><blockquote><p>   这两个实验间接地证明了<strong>内存地址空间</strong>的存在。<br>   我在向内存<code>B810:0000</code>中写数据的时候，发现显示器上会出现有颜色的字符和表情包，猜想这个地址应该是显存的物理地址。这也说明这里的内存不仅仅指的是主存储器，还有其他的和CPU直接相连的RAM。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一部分-硬件模型&quot;&gt;&lt;a href=&quot;#第一部分-硬件模型&quot; class=&quot;headerlink&quot; title=&quot;第一部分:硬件模型&quot;&gt;&lt;/a&gt;第一部分:硬件模型&lt;/h2&gt;&lt;h3 id=&quot;笔记&quot;&gt;&lt;a href=&quot;#笔记&quot; class=&quot;headerlink&quot; title=&quot;笔记&quot;&gt;&lt;/a&gt;笔记&lt;/h3&gt;&lt;h4 id=&quot;硬件基础&quot;&gt;&lt;a href=&quot;#硬件基础&quot; class=&quot;headerlink&quot; title=&quot;硬件基础&quot;&gt;&lt;/a&gt;硬件基础&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;   全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————&lt;code&gt;冯诺依曼结构&lt;/code&gt;。&lt;br&gt;   CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？&lt;br&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言（王爽）ch0</title>
    <link href="http://haotianmcihael.github.io/2018/10/02/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch0/"/>
    <id>http://haotianmcihael.github.io/2018/10/02/汇编语言（王爽）ch0/</id>
    <published>2018-10-02T08:25:22.000Z</published>
    <updated>2018-10-10T14:01:34.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><blockquote><p>王爽老师的《汇编语言》是国内的经典教材。<br>学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。</p></blockquote><a id="more"></a>    <h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><blockquote><p>全书的实验都是在8086CPU的体系结构下展开的，这也是Intel第一块16位的处理器。<br>我们有两种办法在自己的计算机上模拟8086:一种是使用WindowsXP系统。一种是采用DOSBox模拟器，第二种比较方便。<a href="https://pan.baidu.com/s/1-Da6IPYym54QbokzFMiNvA" target="_blank" rel="noopener">这里是链接</a>。<br>本书有17个实验，2个课程设计，5个研究试验。我主要是以其中一些实验为章节展开学习。</p></blockquote><h4 id="全书架构"><a href="#全书架构" class="headerlink" title="全书架构"></a>全书架构</h4><blockquote><p>在我看来，全书应该可以分为这么几个部分:</p><ul><li>硬件模型Chapter.(1、2)————告诉你汇编编程就是程序员以<code>指令</code>为手段在<code>CPU的寄存器</code>和<code>内存地址空间</code>之间进行数据读写的的过程。</li><li>汇编结构Chapter.(3、4)————介绍了完整的汇编程序的组成部分:<code>数据段</code>，<code>代码段</code>、<code>栈段</code>。第4章介绍了汇编程序编译的全过程和基本工具的使用。</li><li>指令核心Chapter.(5~11)————从第5章作者开始引进一些新的指令，并且展开来讲汇编程序设计的核心部分。介绍了重点的指令比如<code>操作指令</code>,<code>跳转指令</code>，<code>比较指令</code>等及其用法等，并深入介绍了内存寻址的各种花式用法。</li><li>操作系统层面的应用Chapter.(12~17)和操作系统相关的概念比如中断等。</li></ul></blockquote><blockquote><p>整个学习过程中，<strong>寄存器和内存地址空间的读写是贯穿全书的核心</strong>，因为所有的操作最终都是产生了对内存或者某一个寄存器的读写。<strong>而完成这一切读写功能的就是汇编指令。</strong>这也是机器硬件的真正工作原理。<br>虽然这些部分都可以拆开来了解，但是实际上每一部分还有很多的细节和承上启下的概念，我也是站在我理解的角度对这些内容进行了划分，需要注意的是:全书还有很多的细节比如不同的存储单元和数据处理方式，这些都不是单独某一个章节可以完成的而是贯穿全书实验的前提。所以还是需要通读一遍全书来顺这些概念。</p></blockquote><h4 id="搭建实验条件"><a href="#搭建实验条件" class="headerlink" title="搭建实验条件"></a>搭建实验条件</h4><ul><li>将下载好的环境包放在<code>~/x86</code>，作为我们的工作目录。</li><li>打开DOSBox模拟器。</li><li>挂载C盘:<code>mount C ~/x86</code>。</li><li>进入C盘:<code>C:</code>。</li><li>开始实验:<code>debug</code>。</li><li>退出程序<code>quit</code>，退出模拟器<code>exit</code>。</li></ul><h4 id="安装成功展示"><a href="#安装成功展示" class="headerlink" title="安装成功展示"></a>安装成功展示</h4><p><img src="https://raw.githubusercontent.com/haotianmichael/markdownPhotos/master/i386/1.png" width="300" height="200" alt="图片名称" align="center"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;王爽老师的《汇编语言》是国内的经典教材。&lt;br&gt;学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/categories/Assembly/"/>
    
    
      <category term="i386" scheme="http://haotianmcihael.github.io/tags/i386/"/>
    
      <category term="Assembly" scheme="http://haotianmcihael.github.io/tags/Assembly/"/>
    
  </entry>
  
</feed>
