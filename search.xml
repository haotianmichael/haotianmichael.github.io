<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch3]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch3%2F</url>
    <content type="text"><![CDATA[第三部分:指令核心]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch2]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch2%2F</url>
    <content type="text"><![CDATA[第二部分:汇编结构笔记汇编语言的结构内存寻址 汇编的角度是寄存器。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。字节存储和字存储就是两种解决办法，在8086中寄存器是16位的(16位为一字)，而存储器的最小存储单元是8位也就是一个字节，所以如果在一些读写中需要用到字存储而不是字节存储的话，就需要两块连续的内存单元才能完成数据的传输，而且很重要的一点是高地址存放字的高位字节，低地址存放字的低位字节。CPU要读写一块内存单元的时候，必须先要给出这个内存单元的地址。在实验1中我们知道了CPU使用段地址+偏移地址的方式来进行寻址。而实现这些功能的就是一些具有特殊功能的寄存器。这里提到的是最简单的也最常使用的两种类型: CS+IP DS+[idata]在任意时刻CPU将CS:IP指向的内容当做指令执行。而DS通常用来存放需要访问的数据的段地址。 MOV指令 如果要访问具体的内存地址，下面就是两个例子: 123mov bx,1000hmov ds,bxmov al,[0] 第三条指令就是一条寄存器访问内存的指令。首先注意单位是字节因为使用的是8位的寄存器，其次这里的[0]指的是偏移地址，而段地址是默认存储在DS段寄存器中的。MOV指令的操作对象还有很多。下面做一些总结: MOV 寄存器，数据 MOV 寄存器，寄存器 MOV 寄存器，内存单元 MOV 内存单元，寄存器 MOV 段寄存器，寄存器等……所以总结一下，访问内存（内存寻址）注意的两点:处理数据的单位（字还是字节），使用什么方式。 数据段 将一段内存当做数据段，是我们在编程的时候的一种安排，可以在具体操作的时候，用ds存放数据的段地址，再根据相关指令访问数据段中的具体单元。 代码段 从硬件角度讲，CPU只认被CS:IP指向的内存单元中的内容为指令。要让CPU执行我们放在代码段的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。 栈段 栈是一种先进后出的数据结构，这是最基本的栈的概念。这里讲到的栈指的是内存区域。从操作系统的角度讲一个线程需要分配一个栈(stack)。相对应的一个进程需要分配一个堆(heap)。栈的大小在分配的时候就已经确定好了，其作用主要是存放一些局部和确定的变量和数据。 关于栈也有两个寄存器:SS:SP。换句话讲CPU如何知道一段内存区域是不是栈？栈顶的段地址放在SS中，而偏移地址放在SP中。任意时刻，SS:SP指向栈顶元素。这是规定。 另外，上微机原理课的时候，老师讲到栈的分类: 向高地址生长的称为递增堆栈。 向地地址生长的称为递减堆栈。 地址延伸主要的影响就是内存中的大端寻址和小端寻址。 堆栈指针指向最后压入堆栈的有效数据项，叫做满堆栈。 堆栈指针指向下一个待压入数据的空位置，叫做空堆栈。 栈指令 在i386的指令集中，栈操作都是以字为单位的。 push执行过程1. SP=SP-2; 2. 向`SP:SS`指向的内存字单元中送入数据; pop执行过程1. 从`SP:SS`指向的内存字单元中读取数据; 2. SP=SP+2; 段的概念 之前讨论过关于段这个概念。我认为，还是因为在编程的时候可以通过一个系统化的结构来统一汇编语言的实现逻辑。使得这些指令看上去便于管理和协调合作。至于其物理实现，其实就是CPU的寻址方式决定的。书本中有一段话特别经典，我摘抄如下: 123456789101112131415161718192021222324比如我们将10000H~1001F安排为代码段，并在里面存储如下代码: MOV ax,1000H MOV ss,axMOV sp,0020H //初始化栈顶MOV ax,csMOV ds,ax //设置数据段段地址MOV ax,[0]add ax,[2]add bx,[4]add bx,[6]push axpush bxpop axpop bx 设置CS=1000，IP=0.这段代码就会被执行，但是可以看到在这段代码中，我们又将 10000H~1001FH安排为栈段和数据段。 可见不管我们如何安排，CPU将内存中的某段内存当做代码，是因CS:IP指向了那里。 CPU将某段内存当做栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排， 以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们 的安排运行的时候做到游刃有余。 一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。 关键是在于CPU中寄存器的设置，机CS，IP，SS，SP，DS的指向。 汇编语言的编译、连接过程及其工具的使用 这部分详细见书上。 源程序组成 一个汇编程序的源程序由汇编指令和伪指令构成。汇编指令指的是编译成为机器指令最终为CPU所执行的代码。伪指令没有相对应的机器指令，主要是由编译器来执行的指令。 编译、链接、执行 源程序经过编译成为可重定位文件，然后经过链接成为可执行文件。可执行文件是可以直接在操作系统中执行的。上述两种文件都属于ELF格式的文件，ELF是Linux下面的一种文件格式，具体的细节在后面的操作系统中会谈到，这里只是了解。 编程（edit）————&gt;1.asm————&gt;编译(masm)————&gt;1.obj————&gt;链接(link)————&gt;1.exe————&gt;加载(shell)————&gt;内存中的程序————&gt;运行(CPU) 工具进阶debug -d 第一个实验中使用的debug工具，通过各种参数来对寄存器和内存进行读写。比如d 段地址:偏移地址指令会列出指定内存单元中的内容。但是debug也是一个程序，而能定位内存地址的方式在8086中只有段寄存器可以做到,实际上debug就是通过将地址写入段寄存器中的方式来进行内存寻址。这个原理适用于所有的参数。而使用的这个段寄存器正是DS寄存器。根据这个原理，就可以通过修改寄存器来进阶使用这些命令，比如:-r ds,:1000,-d ds:0这段代码就表示查看从1000：0开始的内存空间中的内容。这里主要是认识到段寄存器DS的寻址功能，为之后的寻址方式打基础。 debug -p 在整个实验中，debug工具是经常要使用的。debug有两种用法，一种就是使用a参数直接写入程序然后调试。还有一种就是直接调试exe文件。第一种之前一直在用，第二种方式加载的过程有一些不一样，ds段寄存器中存放着改程序的段地址。而加载进来的程序前256字节存放的是一段通信程序，所以真正的代码是在(DS+10H:0):0开始的。每一段汇编指令都需要以mov ax,4c00H，int 21H结尾。在调试到int 21H的时候需要使用P命令执行。出现Program terminated normally程序正常退出。 实验2 用机器指令和汇编指令编程 这个实验很有意思，一共有两部分: 第一部分 使用a将下面的汇编指令写入内存，然后使用T命令调试。如下: 1234567mov ax,2000mov ss,axmov sp,10mov ax,3123push axmov ax,3366push ax 会发现在单步调试的时候，在mov ss,ax之后的下一条指令竟然不是mov sp,10。但是查看寄存器的时候发现实际上这条执行已经被执行结束了。这是第一个现象。 第二部分 对上面的代码继续调试，如下：会发现最开始对栈初始化之后，到执行到mov ss,ax指令的时候，查看原来的栈段内容竟然不再是零，且这些数字还都是和段寄存器相关的。 总结 下图是接下来的每一步后栈段中的内存变化。可以看到的现象是:开始的时候栈中是没有数据的，栈桢SP指向2000:0010的位置。在mov ss,ax和mov sp,10这两步执行结束之后，发现栈中已经有数据了，这里称为初始化。初始化的一共有6字节的数据:4个字节为CS:IP，还有两字节在栈底确定为01A3H。之后的每一条栈操作的指令执行结束之后栈中的CS:IP值也会跟着变化，这说明每一次指令都有可能产生一次中断。但是在栈底的01A3H一直没有变化估计应该是中断向量号。在正式压栈操作的过程中发现最开始初始化过的那些数据并没有被压到栈底，这就意味着堆栈指针SP应该还在栈底，然后真正有数据项压栈的时候才会SP-=2操作。 小实验 就上面的三个现象，我在想仅仅是初始化的过程就已经占据了一大半栈空间，那如果将栈大小调整成为8字节的。那会出现什么情况？ 我将mov sp,10改成mov sp,08；然后准备了8字节数据，所以栈会被压满。这时候我想看看现象。这是一张初始化的图: 这是末尾压栈满了的图: 因为书上关于中断的详细讲解在第四部分，所以这里只是一个猜测。现象中随着栈不断被压满，之前初始化的那些数据都被挤出去了，具体去哪了不知道。那6个字节的数据到底有什么用也不知道。 猜测 不过可以知道的是初始化栈帧的时候会有参数压到栈里，参数有CS:IP和中断向量号，其中CS:IP还在不断变化。而随着栈中的数据越来越多，栈中的这6个字节的参数被慢慢挤出。难道这6个字节不重要吗，或者说只是在初始化的时候用了一下？但是过程中这些参数一直也在变化，所以不可能不重要.不过这些数据之所以放到栈中的原因一定不是为了存储，否则就不会被随便挤出。结合第一部分实验，mov sp,10是紧跟着前一条指令执行的，所以我能想到的唯一一个合理的解释就是:这些参数是在指令执行过程中直接使用的，而执行过程对shell屏蔽不可见，所以在栈中数据越来越多的时候这些参数还可以随意的移动位置并且被抛弃，这些参数是过程中使用的参数，而这个过程就是中断！至于中断到底是什么，到第4章再详细学习吧。 实验3 用编程、编译、连接、跟踪 最后一个实验查看PSP（就是加载开始前256字节）的内容。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch1]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch1%2F</url>
    <content type="text"><![CDATA[第一部分:硬件模型笔记硬件基础 全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————冯诺依曼结构。 CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？ 存储单元的地址（地址） 读/写操作（控制） 读/写的具体数据（数据） 答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它内存地址空间。 以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构《微机原理和接口》，也不是讲整个计算机系统的结构和功能《组成原理》。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。 固有的硬件体系指的是这套CPU+RAM的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说不同的CPU有不同的汇编语言，用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。 指令和数据 学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算。但是如果我把data1和data2互换一下，其实也是可以的。但是需要考虑到的是data2所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。 寄存器 8086CPU有14个寄存器，都是16位的。但是这16位的寄存器也可以独立作为两个8位的寄存器使用。 寄存器和内存是汇编程序猿眼中最直观的计算机样子。 汇编层面的CPU 运算器进行信息处理 寄存器进行信息存储 控制器控制各种器件进行工作 内部总线连接各种器件，在它们之间进行数据的传送 8086架构（16位机）具体深究到物理实现就是《组成原理》知识了。 运算器一次最多可以处理16位数据 寄存器的最大宽度为16位 寄存器和运算器之间的通路为16位 汇编层面的内存 CPU在访问内存单元的时候，需要知道内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存空间在这个空间上都有唯一的地址，这个惟一的地址就叫做物理地址。CPU首先在内部形成这个物理地址，然后通过地址总线送入存储器。这个地址一定是一个内存单元的物理地址。不同的CPU架构形成地址的方式不一样。 CS:IP 前面提到了8086CPU内部需要形成物理地址，但是8086是16位机————只能处理和传输16位的地址，但是8086的地址总线有20位，所以需要两个16位来共同形成一个20位的地址。 14个寄存器中，CS是段寄存器，存放基地址。而IP存放偏移量。公式:CSx16+IP。 首先需要明白的就是，一个内存单元是8位二进制也叫一个字节。而十六进制的一位可以表示成为二进制的4位。完全只是为了方便才写成16进制的。20位的地址（5位16进制）可以写成4C780H，后面的H表示16进制。一个X进制的数据左移一位，相当于乘以X。所以为了记起来方便一些可以记成CS寄存器的数据左移一位+IP寄存器的值。但是两个寄存器只有16位（4位16进制)，到后面计算的时候需要注意这两个前提，避免溢出。 书中特别强调了对段的理解。这里的段并不是指内存被物理上分成一段一段的。而是因为CPU在管理内存的时候，使用CSx16+IP的方式来进行管理。所以可以将地址连续，起始地址为16的倍数的一组内存单元看成是一个段。重点在于不是所有的起始地址都可以作为段地址————这是因为CSx16决定的。而且因为IP是16位的所以每一个段的长度最大为64KB。 执行过程 在8086机中，任意时刻CPU将CS:IP指向的内容当做指令执行。汇编中使用jmp 段地址:偏移地址对CS:IP进行修改。或者使用jmp 寄存器来修改IP的值。 8086的工作过程 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓存器。 IP指向下一条指令。 执行指令,从CS:IP中取指令，重复上面的过程。 书中划线 汇编语言和机器语言的差别在于指令的表示方法上。 微机存储器的容量是以字节为最小单位的来计算的。 在内存和磁盘上，数据和指令没有任何区别。 在汇编语言这门课中，我们所面对的是内存地址空间。CPU向这段地址中读写数据实际上就是向相应的物理存储器中读写数据。 内存地址空间的大小受到CPU地址总线宽度的限制。 实验1 查看CPU和内存，用机器指令和汇编指令编程工具介绍 debug是DOS,Windows都提供的实模式（8086方式）程序的调试工具。下面是本次实验将会用到的参数: r (读写寄存器) r查看所有的寄存器的值 r 寄存器名称修改制定寄存器的值 d （读写内存） d 段地址:偏移地址 列出从指定内存单元开始的128个内存单元的内容 d 段地址:起始偏移地址 结尾偏移地址列出在偏移地址范围之内的内存单元的内容 e （读写内存） e 段地址:偏移地址 data1 data2 data3……从特定单元开始讲数据写入内存 e 段地址:偏移地址 回车表示挨个儿修改内存，空格表示默认不修改，回车表示修改结束 e+u+t 使用e参数向内存中写入机器码 使用u 段地址:偏移地址可以将内存中机器码翻译成为汇编语言 t参数执行CS:IP指向的内存地址单元的任何指令，注意修改参数 a a 段地址:偏移地址可以直接使用汇编的格式写入机器指令 实验任务 一共有4个实验。写出来的都是我觉得很有意思且值得讨论的实验。 第二个实验 给出起始地址为2000:0000的三条指令，使用这三条指令计算2的8次方。 有意思的是这个算法，a += a；如果这里的a是2的话，实际上a+a等于ax2所以可以2的8次方可以通过8次这样的加法完成，但是如果a是其他的值就不行了。 最后两个实验 使用e参数对特定的内存单元进行读写。 这两个实验间接地证明了内存地址空间的存在。 我在向内存B810:0000中写数据的时候，发现显示器上会出现有颜色的字符和表情包，猜想这个地址应该是显存的物理地址。这也说明这里的内存不仅仅指的是主存储器，还有其他的和CPU直接相连的RAM。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch0]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch0%2F</url>
    <content type="text"><![CDATA[Abstract 王爽老师的《汇编语言》是国内的经典教材。学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。 实验环境 全书的实验都是在8086CPU的体系结构下展开的，这也是Intel第一块16位的处理器。我们有两种办法在自己的计算机上模拟8086:一种是使用WindowsXP系统。一种是采用DOSBox模拟器，第二种比较方便。这里是链接。本书有17个实验，2个课程设计，5个研究试验。我主要是以其中一些实验为章节展开学习。 全书架构 在我看来，全书应该可以分为这么几个部分: 硬件模型Chapter.(1、2)————告诉你汇编编程就是程序员以指令为手段在CPU的寄存器和内存地址空间之间进行数据读写的的过程。 汇编结构Chapter.(3、4)————介绍了完整的汇编程序的组成部分:数据段，代码段、栈段。第4章介绍了汇编程序编译的全过程和基本工具的使用。 指令核心Chapter.(5~11)————从第5章作者开始引进一些新的指令，并且展开来讲汇编程序设计的核心部分。介绍了重点的指令比如操作指令,跳转指令，比较指令等及其用法等，并深入介绍了内存寻址的各种花式用法。 操作系统层面的应用Chapter.(12~17)和操作系统相关的概念比如中断等。 整个学习过程中，寄存器和内存地址空间的读写是贯穿全书的核心，因为所有的操作最终都是产生了对内存或者某一个寄存器的读写。而完成这一切读写功能的就是汇编指令。这也是机器硬件的真正工作原理。虽然这些部分都可以拆开来了解，但是实际上每一部分还有很多的细节和承上启下的概念，我也是站在我理解的角度对这些内容进行了划分，需要注意的是:全书还有很多的细节比如不同的存储单元和数据处理方式，这些都不是单独某一个章节可以完成的而是贯穿全书实验的前提。所以还是需要通读一遍全书来顺这些概念。 搭建实验条件 将下载好的环境包放在~/x86，作为我们的工作目录。 打开DOSBox模拟器。 挂载C盘:mount C ~/x86。 进入C盘:C:。 开始实验:debug。 退出程序quit，退出模拟器exit。 安装成功展示]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
</search>
