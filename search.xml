<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch4]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch4%2F</url>
    <content type="text"><![CDATA[第四部分:中断Abstract 在之前的实验中，我们所编写的汇编程序从编译到运行出结果都很顺利。这个过程映射到CPU层面就是CS:IP的跳转唯一取决于汇编程序员的代码。CSAPP将这个过程称为程序控制流。而中断则是将这种流程打断，建立更复杂的异常控制流。中断分为内中断和外中断两种。作者很强调知识屏蔽以达到专注统一的目的。但是从汇编的角度看中断本身也是具有一定的局限性，主要体现在写汇编的人无法一直站在纯硬件的角度来思考。有组成原理的基础当然很好————但就本书来讲，汇编也只是其中一种角度而已。 内中断中断产生 8086CPU使用中断类型码来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源————具体指的是产生中断信息的事件，简称中断源。下面是8086中4种常见的中断源及其中断类型码: 除法错误: 0 单步执行: 1 执行into指令: 4 执行int n指令: n 中断过程 CPU获得中断类型码之后，需要跳转到该中断类型码对应的中断处理程序中进行处理。如何跳转呢？使用中断向量表。而跳转通常意味着改变CPU的状态，所以需要使用栈来保存现场。所以识别，保存和跳转就是中断过程主要干的事儿————其中识别由硬件完成！中断向量表保存在内存0000:0000到0000:03FF的这1KB单元里。一个表项存放一个中断向量————也就是中断处理程序的地址入口。占4个字节，高地址放段地址，低地址放偏移地址。 识别 下图是一张8086的内存分布图:从内存0开始，所以存储N号中断源对应的中断向量的偏移地址的内存地址为:0000:4N，存储N号中断源对应的中断向量的段地址的内存地址为:0000：4N+2。看下图: 跳转和保存 获得中断类型码 标志寄存器的值入栈: pushf 设置标志寄存器第8位TF和第9位IF的值位0: TF=0,IF=0 CS的内容入栈: push CS IP的内容入栈: push IP 通过中断类型码获取入口地址: (IP)=(N*4),(CS)=(N*4+2) 最后一步执行结束后，CPU开始执行由程序员编写的中断处理程序 中断处理 所谓中断处理程序就是操作系统对各种中断的反应。 由于CPU随时可能检测到中断，所以中断处理程序必须一直存储在内存某段空间中。下面的实验就是通过来实现内中断处理程序。 0号中断 即除法溢出错误。 123mov ax, 1000hmov bh,1div bh 该除法指令在执行的过程中会发生溢出错误，导致产生0号中断从而引发中断过程。 实验 编写0号中断的处理程序 中断类型码:0 中断处理程序: 选择0000：0200到0000：02ff这256个Bytes内存的区域来存放 中断向量表: 0号中断的段地址0000:0002偏移地址0000:0000安装处理程序do0 得确保中断处理程序不会变动，所以选择一块合适的内存区域将其安装进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 assume cs:code code segment start: mov ax,cs mov ds,ax mov si,offset do0 //设置ds:si指向被拷贝的程序地址 mov ax,0 mov es,ax //设置es:di指向拷贝的目的地址 mov di,200h mov cx,offset do0end-offset do0 //设置需要拷贝的代码长度度 cld //设置传输方向为正 rep movsb /* 设置中断向量表 */ mov ax, 4c00h int 21h do0: jmp short do0start db &quot;overflow!&quot; do0start: mov ax,cs mov ds,ax mov si,200h //设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 //设置es:di指向显存空间的中间位置 mov cx,9 //字符串的长度 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h do0end: nop code ends end start 设置中断向量号 当中断发生的时候，确保0号中断的处理程序跳转地址是上一个设置好的地址。 1234mov ax,0mov es,axmov word ptr es:[0*4],200hmov word ptr es:[0*4+2], 0 验证 注意，在跳转到中断处理程序之前，所有的CPU现场已经入栈保存好了，而跳转过程本身也是硬件过程，所以我们所做的仅仅只是设置好跳转的地址和该地址相应的处理代码。 实验 1号中断 在CPU保存现场的时候，对状态寄存器压栈，并且将其中两个状态位设置为零:TF=0;IF=0;主要是因为当CPU每执行完一条指令的时候，就会去查看状态寄存器的TF位是否为1，如果是则引发1号中断————单步中断。整个中断的过程和其他的没有什么区别，作者提到debug -t的单步执行功能，实际上就是通过debug调用1号中断对CPU进行控制。那为什么要在处理之前又将TF设置为零呢？注意前面的每执行完一条指令的意思，CPU在执行中断处理程序的时候是不能响应其他中断的，TF=0是防止在过程中递归的陷入。 但是在有些特殊情况下中断的产生，CPU不见得马上处理。比如mov ss, ax和MOV sp, 10这两条设置堆栈的指令，在前面的实验中出现过，]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch3]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch3%2F</url>
    <content type="text"><![CDATA[第三部分:指令核心Abstract内存寻址 内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，注意这里的内存指的是内存地址空间。CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。寻址的方式有很多种类 ，不过归结到底都是段地址+偏移地址。段地址存储在段寄存器中，而偏移地址的方式就有很多种。见下图: 需要注意的是: 上图中的idata表示立即数，[]表示偏移地址。(ax)表示寄存器ax的内容。 []中的除了立即数之外，只有bx,si,di和bp四个寄存器可以进行寻址，其他的寄存器不行。 [bp]的段寄存器默认是ss。 编译器masm和调试器debug两个工具对于mov ax,[idata]中的idata处理不同，编译器会将其识别为idata,所以在使用编译器的时候这种形式应该写成mov ax,ds:[idata] 数据处理(总结性质) 计算机处理的最终还是数据，那么就有两个最基本的问题: 处理的数据在什么地方？ 要处理的数据有多长？ 问题一 绝大部分机器指令都是进行数据处理的指令，处理大致分为三类:读取，写入，运算。在机器指令这一层来说并不关心数据的值，而关心指令执行前一秒，将要处理的数据所在的位置。指令在执行之前，所要处理的数据可以在三个地方:CPU内部，寄存器，端口。 问题二 8086指令可以处理两种尺寸的数据:Byte和Word。所以在机器指令中需要指明是字操作和字节操作。 通过寄存器指明:ax，al等 用操作符X ptr指明内存单元的长度，X是word或者byte。比如:mov byte ptr ds:[0],1。 还有一些默认的操作比如栈操作默认为字操作。 指令详解伪指令补充 db 定义字节型数据 dw 定义字型数据 dd 定义双字节型数据 dup 和前面三个伪指令结合使用，用来进行数据的重复。db 3 dup(1,2,3)表示定义的三个字节型数据分别为1,2,3。 LOOP循环指令 主要进行两步操作，（cx）=(cx)-1，判断cx中的值。不为零则转至标号处执行程序，如果为零则向下执行。可见cx中的值影响了loop指令的执行结果。 1234mov cx,循环次数s: 循环执行的程序段 loop s JMP转移指令 可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的的指令。根据修改的方式，只修改IP的称为段内转移，修改IP和CS的称为段间转移。由于转移指令对IP的修改范围不同，段内转移又分为:短转移（8位）和近转移（16位）。不同的转移方式，其基本的原理确实相同的。 1-JMP short offset 转移指令值得注意的点就是offset指的不是确定的地址，而是从标号到指令之间的位移。(IP)=(IP)+8位位移，段内短转移的位移范围位8位有符号数，用补码表示。offset处的地址-JMP指令后的第一个字节的地址。 1-JMP near ptr offset (IP)=(IP)+16位位移 ,段内近转移的位移范围是16位有符号数，用补码表示。原理和前者一样。 2-JMP far ptr offset 前面的几种类型地址都是通过offset和位移，而接下来的几种是在寄存器和内存中的给定IP或者CS。内存地址单元可以用任意的寻址方式得到。（CS）=标号所在段的段地址，（IP）=标号所在段中的偏移地址 。段间转移，会发现其跳转地址实际上是在指令中的offset的地址。和前两个还是有区别的。 2-JMP 16位reg 最基础的跳转指令，只是修改IP=16位的寄存器中内容。 2-JMP word ptr 内存单元地址 比如:jmp word ptr ds:[0]中ptr后面的就是一个地址，jmp word ds:[0],0后面跟两个地址。注意（CS）=(内存地址单元+2)，（IP）=（内存地址单元）。 2-jcxz 该指令为有条件转移指令，所有的有条件转移指令都是短转移。方式为:if((cx)==0)jmp short offset另外，所有的loop循环指令都是短转移。 CALL和RET指令ret(近转移) 书中说ret指令用栈中的数据修改IP中的内容。之前对栈有一个分类，这里的栈是满递减堆栈。所以由此可知堆栈指针SP一直指向最后一个压栈的数据。ret指令实际上把堆栈中的最后一个数据作为自己跳转的偏移地址。方式如下:(IP)=((ss)*16+(sp)),(sp)=(sp)+2从上面也可以看出来这两条指令等同于:pop IP retf(远转移) 书中说retf指令用栈中的数据修改IP和CS中的内容。类似:(IP)=((ss)*16+(sp)),(sp)=(sp)+2（CS）=（（ss）*16+(sp)）,(sp)=(sp)+2这四条指令等同于:pop IP,pop CS call指令 call指令不能实现短转移，但是其转移的原理和jmp指令相同。如下：(sp)=(sp)-2,((ss)*16+(sp))=(IP),(IP)=(IP)+16位位移这几条指令相当于:push IP和jmp near ptr offset call和ret指令(子程序) 先看一段代码: 12345678910111213assume cs:codecode segmentstart: mov ax,1 mov cx,3 call s mov bx,ax mov ax,4c00h int 21h s: add ax,ax loop s retcode endsend start 程序执行到call s的时候，IP指向了后面的一条指令，然后CPU执行call s指令————将当前的IP（mov bx,ax的地址）压栈，然后修改为s地址。然后子程序开始执行，执行结束之后执行ret指令————从栈中弹出一个值，将CS:IP的值指向mov bx,ax。然后返回为原来的地址。这两条指令为子程序的调用提供了可能。 标志寄存器 寄存器是汇编程序员解决问题的最有利的手段，不仅仅在于可以存储数据，还具有辅助指令执行的功能。标志寄存器就是如此，用来存储CPU执行指令的某些执行结果。存储的信息称为“程序状态字PSW”。状态寄存器的每一位都有具体的含义。下面分别介绍: ZF标志 零标志位，相关指令执行结束如果结果为0，zf=1；如果不为0，zf=0. PF标志 奇偶标志位，相关指令执行结束如果结果的所有bit位中1的个数为偶数，pf=1,否则pf=0. SF标志 符号标志位，相关指令执行结束如果结果为负，sf=1；否则sf=0。该标志是CPU对有符号数计算结果的一种记录。 CF标志 进位标志位，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 OF标志 溢出标志位，在进行有符号数运算的时候，记录了是否发生溢出。 标志寄存器在Debug中的使用 标志寄存器是按照有意义的各个标志位单独表示的。如下。下图是已知的标志位的表示: 其他指令（总结性质） 还有很多的指令比如MOV,CMP，abc等。但这里并不打算详细讲解每一条指令，就像书中所说:汇编语言只是载体，目的在于理解机器运行的原理和方式。至此，我们已经学习了寄存器，内存,汇编指令，并且掌握了一个正常的程序控制流在机器层面的运行过程。接下来的内容，就属于操作系统的层面，引入异常控制流，也就是在正常的执行过程中有外界干扰的情况，这是理解整个OS的重点，也是我写这几篇技术博客的主要学习目的。(mit6.828中的汇编大同小异，只是指令集换成了AT&amp;T的格式)。 实验7 寻址方式在结构化数据访问中的应用实验9 根据材料编程实验10 编写子程序]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch2]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch2%2F</url>
    <content type="text"><![CDATA[第二部分:汇编结构Abstract汇编语言的结构寄存器和内存之间 汇编语言是由不同的段构成的，这些段的功能各异不过主要分为指令和数据两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。字节存储和字存储就是两种解决办法，在8086中寄存器是16位的(16位为一字)，而存储器的最小存储单元是8位也就是一个字节，所以如果在一些读写中需要用到字存储而不是字节存储的话，就需要两块连续的内存单元才能完成数据的传输，而且是高地址存放字的高位字节，低地址存放字的低位字节。要读写一块内存单元的时候，必须先要给出这个内存单元的地址。在实验1中我们知道了CPU使用段地址+偏移地址的方式来进行寻址。而实现这些功能的就是一些具有特殊功能的寄存器。这里提到的是最简单的也最常使用的两种类型: CS+IP————在任意时刻CPU将CS:IP指向的内容当做指令执行。 DS+[idata]————DS通常用来存放需要访问的数据的段地址。这里主要介绍汇编语言的结构，对应到寄存器和内存寻址的方式后面会讲。 数据段 将一段内存当做数据段，是我们在编程的时候的一种安排，可以在具体操作的时候，用ds存放数据的段地址，再根据相关指令访问数据段中的具体单元。 代码段 从硬件角度讲，CPU只认被CS:IP指向的内存单元中的内容为指令。要让CPU执行我们放在代码段的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。 栈段 栈是一种先进后出的数据结构，这是最基本的栈的概念。这里讲到的栈指的是内存区域。从操作系统的角度讲一个线程需要分配一个栈(stack)。相对应的一个进程需要分配一个堆(heap)。栈的大小在分配的时候就已经确定好了，其作用主要是存放一些局部和确定的变量和数据。 关于栈也有两个寄存器:SS:SP。换句话讲CPU如何知道一段内存区域是不是栈？栈顶的段地址放在SS中，而偏移地址放在SP中。任意时刻，SS:SP指向栈顶元素。这是规定。 另外，上微机原理课的时候，老师讲到栈的分类: 向高地址生长的称为递增堆栈。 向地地址生长的称为递减堆栈。 地址延伸主要的影响就是内存中的大端寻址和小端寻址。 堆栈指针指向最后压入堆栈的有效数据项，叫做满堆栈。 堆栈指针指向下一个待压入数据的空位置，叫做空堆栈。 栈指令 在i386的指令集中，栈操作都是以字为单位的。 push执行过程1. SP=SP-2; 2. 向`SP:SS`指向的内存字单元中送入数据; pop执行过程1. 从`SP:SS`指向的内存字单元中读取数据; 2. SP=SP+2; 段的概念 之前讨论过关于段这个概念。我认为，还是因为在编程的时候可以通过一个系统化的结构来统一汇编语言的实现逻辑。使得这些指令看上去便于管理和协调合作。至于其物理实现，其实就是CPU的寻址方式决定的。书本中有一段话特别经典，我摘抄如下: 123456789101112131415161718192021222324比如我们将10000H~1001F安排为代码段，并在里面存储如下代码: MOV ax,1000H MOV ss,axMOV sp,0020H //初始化栈顶MOV ax,csMOV ds,ax //设置数据段段地址MOV ax,[0]add ax,[2]add bx,[4]add bx,[6]push axpush bxpop axpop bx 设置CS=1000，IP=0.这段代码就会被执行，但是可以看到在这段代码中，我们又将 10000H~1001FH安排为栈段和数据段。 可见不管我们如何安排，CPU将内存中的某段内存当做代码，是因CS:IP指向了那里。 CPU将某段内存当做栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排， 以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们 的安排运行的时候做到游刃有余。 一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。 关键是在于CPU中寄存器的设置，机CS，IP，SS，SP，DS的指向。 多个段的统一 以前写的汇编都是单个段，并且主要是代码段。如果内存中的一段汇编代码需要包含多个数据段，代码段，栈段。该如何设计才能保证程序正常运行呢？我们应该有一个概念，就是所谓和CPU对应的程序一定是CS:IP指向的内存地址。所以实际上这个问题是在问保证CS:IP正确指向程序的前提下，如何让数据段，栈段合理的加进来？这里有个伪指令的概念，伪指令主要是为汇编器提供一些编译的前提信息比如从哪里开始执行代码，其他的段的起始地址在哪里。所以问题也就解决了。 如何保证CS:IP指向代码段: end和end start 如何定义一个段: code segment和code ends 如何将段寄存器和段相对应: assume cs:code 汇编语言的编译、连接过程及其工具的使用 这部分详细见书上。 源程序组成 一个汇编程序的源程序由汇编指令和伪指令构成。汇编指令指的是编译成为机器指令最终为CPU所执行的代码。伪指令没有相对应的机器指令，主要是由编译器来执行的指令。 编译、链接、执行 源程序经过编译成为可重定位文件，然后经过链接成为可执行文件。可执行文件是可以直接在操作系统中执行的。上述两种文件都属于ELF格式的文件，ELF是Linux下面的一种文件格式，具体的细节在后面的操作系统中会谈到，这里只是了解。 编程（edit）————&gt;1.asm————&gt;编译(masm)————&gt;1.obj————&gt;链接(link)————&gt;1.exe————&gt;加载(shell)————&gt;内存中的程序————&gt;运行(CPU) 工具进阶debug -d 第一个实验中使用的debug工具，通过各种参数来对寄存器和内存进行读写。比如d 段地址:偏移地址指令会列出指定内存单元中的内容。但是debug也是一个程序，而能定位内存地址的方式在8086中只有段寄存器可以做到,实际上debug就是通过将地址写入段寄存器中的方式来进行内存寻址。这个原理适用于所有的参数。而使用的这个段寄存器正是DS寄存器。根据这个原理，就可以通过修改寄存器来进阶使用这些命令，比如:-r ds,:1000,-d ds:0这段代码就表示查看从1000：0开始的内存空间中的内容。这里主要是认识到段寄存器DS的寻址功能，为之后的寻址方式打基础。 debug -p 在整个实验中，debug工具是经常要使用的。debug有两种用法，一种就是使用a参数直接写入程序然后调试。还有一种就是直接调试exe文件。第一种之前一直在用，第二种方式加载的过程有一些不一样，ds段寄存器中存放着该程序的段地址，因为偏移为零所以DS:0就是所加载程序的首地址。而加载进来的程序前256字节存放的是一段通信程序，所以真正的代码是在(DS+10H:0):0开始的。每一段汇编指令都需要以mov ax,4c00H，int 21H结尾。在调试到int 21H的时候需要使用P命令执行。出现Program terminated normally程序正常退出。 实验2 用机器指令和汇编指令编程 这个实验很有意思，一共有两部分: 第一部分 使用a将下面的汇编指令写入内存，然后使用T命令调试。如下: 1234567mov ax,2000mov ss,axmov sp,10mov ax,3123push axmov ax,3366push ax 会发现在单步调试的时候，在mov ss,ax之后的下一条指令竟然不是mov sp,10。但是查看寄存器的时候发现实际上这条执行已经被执行结束了。这是第一个现象。 第二部分 对上面的代码继续调试，如下：会发现最开始对栈初始化之后，到执行到mov ss,ax指令的时候，查看原来的栈段内容竟然不再是零，且这些数字还都是和段寄存器相关的。 总结 下图是接下来的每一步后栈段中的内存变化。可以看到的现象是:开始的时候栈中是没有数据的，栈桢SP指向2000:0010的位置。在mov ss,ax和mov sp,10这两步执行结束之后，发现栈中已经有数据了，这里称为初始化。初始化的一共有6字节的数据:4个字节为CS:IP，还有两字节在栈底确定为01A3H。之后的每一条栈操作的指令执行结束之后栈中的CS:IP值也会跟着变化，这说明每一次指令都有可能产生一次中断。但是在栈底的01A3H一直没有变化估计应该是中断向量号。在正式压栈操作的过程中发现最开始初始化过的那些数据并没有被压到栈底，这就意味着堆栈指针SP应该还在栈底，然后真正有数据项压栈的时候才会SP-=2操作。 小实验 就上面的三个现象，我在想仅仅是初始化的过程就已经占据了一大半栈空间，那如果将栈大小调整成为8字节的。那会出现什么情况？ 我将mov sp,10改成mov sp,08；然后准备了8字节数据，所以栈会被压满。这时候我想看看现象。这是一张初始化的图: 这是末尾压栈满了的图: 因为书上关于中断的详细讲解在第四部分，所以这里只是一个猜测。现象中随着栈不断被压满，之前初始化的那些数据都被挤出去了，具体去哪了不知道。那6个字节的数据到底有什么用也不知道。 猜测 不过可以知道的是初始化栈帧的时候会有参数压到栈里，参数有CS:IP和中断向量号，其中CS:IP还在不断变化。而随着栈中的数据越来越多，栈中的这6个字节的参数被慢慢挤出。难道这6个字节不重要吗，或者说只是在初始化的时候用了一下？但是过程中这些参数一直也在变化，所以不可能不重要.不过这些数据之所以放到栈中的原因一定不是为了存储，否则就不会被随便挤出。结合第一部分实验，mov sp,10是紧跟着前一条指令执行的，所以我能想到的唯一一个合理的解释就是:这些参数是在指令执行过程中直接使用的，而执行过程对shell屏蔽不可见，所以在栈中数据越来越多的时候这些参数还可以随意的移动位置并且被抛弃，这些参数是过程中使用的参数，而这个过程就是中断！至于中断到底是什么，到第4章再详细学习吧。 实验3 用编程、编译、连接、跟踪 最后一个实验查看PSP（就是加载开始前256字节）的内容。使用u来查看汇编好像又和中断有关系。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch1]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch1%2F</url>
    <content type="text"><![CDATA[第一部分:硬件模型Abstract硬件基础 全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————冯诺依曼结构。 CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？ 存储单元的地址（地址） 读/写操作（控制） 读/写的具体数据（数据） 答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它内存地址空间。 以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构《微机原理和接口》，也不是讲整个计算机系统的结构和功能《组成原理》。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。 固有的硬件体系指的是这套CPU+RAM的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说不同的CPU有不同的汇编语言，用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。 指令和数据 学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算。但是如果我把data1和data2互换一下，其实也是可以的。但是需要考虑到的是data2所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。 寄存器 8086CPU有14个寄存器，都是16位的。但是这16位的寄存器也可以独立作为两个8位的寄存器使用。 寄存器和内存是汇编程序猿眼中最直观的计算机样子。 汇编层面的CPU 运算器进行信息处理 寄存器进行信息存储 控制器控制各种器件进行工作 内部总线连接各种器件，在它们之间进行数据的传送 8086架构（16位机）具体深究到物理实现就是《组成原理》知识了。 运算器一次最多可以处理16位数据 寄存器的最大宽度为16位 寄存器和运算器之间的通路为16位 汇编层面的内存 CPU在访问内存单元的时候，需要知道内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存空间在这个空间上都有唯一的地址，这个惟一的地址就叫做物理地址。CPU首先在内部形成这个物理地址，然后通过地址总线送入存储器。这个地址一定是一个内存单元的物理地址。不同的CPU架构形成地址的方式不一样。 CS:IP 前面提到了8086CPU内部需要形成物理地址，但是8086是16位机————只能处理和传输16位的地址，但是8086的地址总线有20位，所以需要两个16位来共同形成一个20位的地址。 14个寄存器中，CS是段寄存器，存放基地址。而IP存放偏移量。公式:CSx16+IP。 首先需要明白的就是，一个内存单元是8位二进制也叫一个字节。而十六进制的一位可以表示成为二进制的4位。完全只是为了方便才写成16进制的。20位的地址（5位16进制）可以写成4C780H，后面的H表示16进制。一个X进制的数据左移一位，相当于乘以X。所以为了记起来方便一些可以记成CS寄存器的数据左移一位+IP寄存器的值。但是两个寄存器只有16位（4位16进制)，到后面计算的时候需要注意这两个前提，避免溢出。 书中特别强调了对段的理解。这里的段并不是指内存被物理上分成一段一段的。而是因为CPU在管理内存的时候，使用CSx16+IP的方式来进行管理。所以可以将地址连续，起始地址为16的倍数的一组内存单元看成是一个段。重点在于不是所有的起始地址都可以作为段地址————这是因为CSx16决定的。而且因为IP是16位的所以每一个段的长度最大为64KB。 执行过程 在8086机中，任意时刻CPU将CS:IP指向的内容当做指令执行。汇编中使用jmp 段地址:偏移地址对CS:IP进行修改。或者使用jmp 寄存器来修改IP的值。 8086的工作过程 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓存器。 IP指向下一条指令。 执行指令,从CS:IP中取指令，重复上面的过程。 书中划线 汇编语言和机器语言的差别在于指令的表示方法上。 微机存储器的容量是以字节为最小单位的来计算的。 在内存和磁盘上，数据和指令没有任何区别。 在汇编语言这门课中，我们所面对的是内存地址空间。CPU向这段地址中读写数据实际上就是向相应的物理存储器中读写数据。 内存地址空间的大小受到CPU地址总线宽度的限制。 实验1 查看CPU和内存，用机器指令和汇编指令编程工具介绍 debug是DOS,Windows都提供的实模式（8086方式）程序的调试工具。下面是本次实验将会用到的参数: r (读写寄存器) r查看所有的寄存器的值 r 寄存器名称修改制定寄存器的值 d （读写内存） d 段地址:偏移地址 列出从指定内存单元开始的128个内存单元的内容 d 段地址:起始偏移地址 结尾偏移地址列出在偏移地址范围之内的内存单元的内容 e （读写内存） e 段地址:偏移地址 data1 data2 data3……从特定单元开始讲数据写入内存 e 段地址:偏移地址 回车表示挨个儿修改内存，空格表示默认不修改，回车表示修改结束 e+u+t 使用e参数向内存中写入机器码 使用u 段地址:偏移地址可以将内存中机器码翻译成为汇编语言 t参数执行CS:IP指向的内存地址单元的任何指令，注意修改参数 a a 段地址:偏移地址可以直接使用汇编的格式写入机器指令 实验任务 一共有4个实验。写出来的都是我觉得很有意思且值得讨论的实验。 第二个实验 给出起始地址为2000:0000的三条指令，使用这三条指令计算2的8次方。 有意思的是这个算法，a += a；如果这里的a是2的话，实际上a+a等于ax2所以可以2的8次方可以通过8次这样的加法完成，但是如果a是其他的值就不行了。 最后两个实验 使用e参数对特定的内存单元进行读写。 这两个实验间接地证明了内存地址空间的存在。 我在向内存B810:0000中写数据的时候，发现显示器上会出现有颜色的字符和表情包，猜想这个地址应该是显存的物理地址。这也说明这里的内存不仅仅指的是主存储器，还有其他的和CPU直接相连的RAM。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch0]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch0%2F</url>
    <content type="text"><![CDATA[Abstract 王爽老师的《汇编语言》是国内的经典教材。学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。 实验环境 全书的实验都是在8086CPU的体系结构下展开的，这也是Intel第一块16位的处理器。我们有两种办法在自己的计算机上模拟8086:一种是使用WindowsXP系统。一种是采用DOSBox模拟器，第二种比较方便。这里是链接。本书有17个实验，2个课程设计，5个研究试验。我主要是以其中一些实验为章节展开学习。 全书架构 在我看来，全书应该可以分为这么几个部分: 硬件模型Chapter.(1、2)————告诉你汇编编程就是程序员以指令为手段在CPU的寄存器和内存地址空间之间进行数据读写的的过程。 汇编结构Chapter.(3、4)————介绍了完整的汇编程序的组成部分:数据段，代码段、栈段。第4章介绍了汇编程序编译的全过程和基本工具的使用。 指令核心Chapter.(5~11)————从第5章作者开始引进一些新的指令，并且展开来讲汇编程序设计的核心部分。介绍了重点的指令比如操作指令,跳转指令，比较指令等及其用法等，并深入介绍了内存寻址的各种花式用法。 操作系统层面的应用Chapter.(12~17)和操作系统相关的概念比如中断等。 整个学习过程中，寄存器和内存地址空间的读写是贯穿全书的核心，因为所有的操作最终都是产生了对内存或者某一个寄存器的读写。而完成这一切读写功能的就是汇编指令。这也是机器硬件的真正工作原理。虽然这些部分都可以拆开来了解，但是实际上每一部分还有很多的细节和承上启下的概念，我也是站在我理解的角度对这些内容进行了划分，需要注意的是:全书还有很多的细节比如不同的存储单元和数据处理方式，这些都不是单独某一个章节可以完成的而是贯穿全书实验的前提。所以还是需要通读一遍全书来顺这些概念。 搭建实验条件 将下载好的环境包放在~/x86，作为我们的工作目录。 打开DOSBox模拟器。 挂载C盘:mount C ~/x86。 进入C盘:C:。 开始实验:debug。 退出程序quit，退出模拟器exit。 安装成功展示]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
</search>
