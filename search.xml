<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mit6.828(Fall 2018) Lab1]]></title>
    <url>%2F2018%2F11%2F05%2FMit6-828-Fall2018-Lab1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Mit6.828(Fall 2018) Lab0]]></title>
    <url>%2F2018%2F11%2F05%2FMit6-828-Fall-2018-Lab0%2F</url>
    <content type="text"><![CDATA[Lab0Abstract 从8086汇编实验之后，前后两周的时间勉强通过Lab1。最大的感触是基础太差:对C语言的理解，对程序编译链接本质的理解，对GDB等工具的使用……当然也包括弱弱的英语理解能力。导致完成Lab1用了这么久的时间。但是这次触动中却又多了一丝见山不是山，见山又是山的感觉。主要体现在我对操作系统的理解最终都回归到代码上来。比如printf函数的实现就涉及C语言中变参的特性。有理由相信这种血浓于水的关系在后续的Lab中还会进一步加强，所以我也希望这会是我学习OS最完美的方法论——————Talk is cheap, show me the code.。截止到Lab1，整个学习的过程显得很清晰————就是通过调试kernel的反汇编代码来理解运行原理并加以修改。Lab0是我在实验过程中掉进的坑，查阅的资料和逐渐点亮的技能树，缩短实验前的准备时间对理解OS本身还是很有帮助的。 6.828实验环境的搭建 虚拟机环境: Ubuntu14.4 (32位) 仿真器: Qemu git clone https://github.com/mit-pdos/6.828-qemu.git qemu 实验代码: Lab git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab 虚拟机环境32位，因为JOS就是32位的操作系统。仿真器使用MIT进行patched过的(见上链接)。原因是实验中分页机制是有意修改过的，使用patched version的话在后面Exercise中不需要手动转换地址。关于实验代码，默认熟悉Git和MakeFile。每做完一个Exercise可以使用./grade-labx进行测试。在整个实验环境搭建的过程中，可能会因为虚拟机发型版本的不同而出现不同的链接库丢失，Google一下。详细的搭建过程见Tools Guide 关于6.828 MIT的OS课程。学习共有三条主线:Lectures,Readings,Labs。当然最重要的就是Labs。关于剩余的两部分，主要围绕一个叫做xv6的小型OS展开的。简单来讲，这是一个麻雀虽小五脏俱全的OS。有Documents和Source Code两份资料。知乎上评价很高，有人将其翻译成为中文版本上传至Github.XV6_Ch，传说看懂源码之后可以超神……做Lab的过程中，课程会提供大量的Readings来阅读，当然都是英文的。详细见Reference。 80386汇编和内联汇编AT&amp;T-80386 在之前的汇编实验中，我们学习了16位的Intel-8086汇编。而在32位机器上需要使用32位的80386汇编语言。虽然对于Linux来说，8086和80386的机器是有很大的差别的，主要体现在实模式和保护模式上。但是就语言本身而言，更多的是递进的关系而语法差别并不大。目前还没有遇到保护模式相关的障碍。x86的汇编主要有两种格式:Intel和AT&amp;T。6.828使用的是AT&amp;T,而实际上Linux中的汇编也是后者居多。汇编语言本身主要有指令集Instruction Set和伪指令Directives两大部分内容。当然最全的文献是Intel自家的Documents，不过我觉得有些太杂和多了。下面的的资料在实验过程中帮了我很多。值得细看。 MIT—-pcasm-book。 Wikipedia—-x86 Instruction Set Oracle—-x86 Assembler Directives 内联汇编 因为操作系统本身就是和硬件打交道最频繁的系统软件，有些地方需要使用到汇编来简单粗暴的完成工作。内联汇编就是嵌入在C语言中的汇编语言，格式和原来的有很大的不同。不过IBM的那份资料可以解决一大半问题，也是难得的中文文档…… MIT—-Brennan’s Guide to Inline Assembly IBM—-汇编语言开发指南 ELF文件 实名Diss网上各种对ELF的讲解，故意弄混section和segment的概念。加上对不同的二进制工具不熟练，让我一度以为链接的难度是整个实验过程中最难的。直到我看到CSAPP中关于链接部分的讲解。才明白section和segment的关系。 反汇编工具 基本工具可以通过man来查看用法，这里列出几个最常见的。 Objdump -f Display file headers -d Disassembly -h Section headers -x All headers -S Display source code ReadElf -h headers -l Programm Headers -s Section Headers NmHexdumpVIM进阶 虽然我是Emacs党，但是不得不承认VIM在进行文本操作的时候还是更方便:)一些。 Ctags 这个就很强大了，用于在tags文件所在的根目录下寻找函数声明和宏定义，尤其是在多文件目录下尤其有用。 CListTmux 这又是一个神器，终端分屏功能强大，有window,pannel等概念。和on-my-zsh配合使用简直了。不愿意折腾的话也可以在bash下直接使用。我们在GDB调试OS的时候使用她作为分屏工具，需要在家目录下加入配置文件~/.tmux.conf。 VimGrep 用于在制定目录下进行全局搜索并在另一个窗口打开;关键字sample;在vim命令模式下执行命令； :vim/sample/% | copen 当前文件搜索 :vim/sample/* | copen 当前目录搜索 :vim/sample/ ../** | copen 从上一级目录开始递归搜索 :vim/sample path1/** path2/** | copen 多路径搜索 : cclose 关闭当前搜索]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
        <tag>MIT 6.828</tag>
        <tag>OS</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch5]]></title>
    <url>%2F2018%2F10%2F16%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch5%2F</url>
    <content type="text"><![CDATA[第五部分:中断IIAbstract CPU实现I/O功能的两个问题:从何处获得外设的输入？如何解决外设输入随时可能发生的问题？首先外设芯片内部有若干寄存器，CPU将这些寄存器当做端口来访问。外设的输入输出不直接送入CPU和内存而是通过这些寄存器。第二，CPU通过外中断控制I/O的随时性。 端口 CPU可以直接读写三个地方的数据: 内部寄存器 内存单元 端口CPU通过端口地址来定位不同的端口，最多可以定位64KB个端口，则端口地址范围为0~65535。端口的读写指令in和out。只能使用al和ax来存放对端口进行读写的数据。 外中断 外中断是由相关芯片发送给CPU中的。分为可屏蔽中断和不可屏蔽中断。不可屏蔽中断指那些CPU一定需要响应的中断，这种中断很少，中断类型码固定为2。大多数外中断指的是可屏蔽中断。CPU要不要响应可屏蔽中断完全取决于状态寄存器的IF位。为1则响应，否则不响应。8086中手动设置IF的指令: sti:设置为1 cli:设置为0 实验 编写9号中断例程PC机键盘的处理过程 键盘中有一个芯片扫描每一个键的状态——按下还是松开。按下产生一个扫描码称为通码，松开也产生一个扫描码称为断码。断码=通码+80h。扫描码被送到60h端口中。int 9h是BIOS提供的不可屏蔽中断。一旦CPU收到该信号: 读出60h端口的扫描码 如果是字符键的扫描码，将该扫描码和所对应的字符码送入内存中的BIOS键盘缓存区(16个字单元)。如果是控制键(Ctrl)和切换键(CapsLock)的扫描码，则将其转变为状态字节写进内存中存储状态字节的单元。 对键盘系统进行相关的控制。 实验 在屏幕中间依次显示”a”~”z”,在显示的过程中按下Esc键后改变颜色。实验有意思的地方在于:因为键盘上所有的键都会触发int 9h中断，需要在保证其他键无效的情况下，Esc键触发中断————就相当于出现了两个中断例程，两个中断向量。更有趣的是需要这两个中断同时有效，在一个int 9h中断下！方法也很简单，就是使用if_else判断扫描码。当然汇编中没有if_else。 中断向量和中断例程 键盘无论是哪一个键当然只会触发int 9h中断这个不会变。不过得分别写例程: 12345678910111213141516171819202122232425262728assume cs:code stack segment db 128 dup (0) stack ends data segment dw 0,0 data ends code segment start: mov ax,stack mov ss,ax mov sp,128 mov ax,data mov ds,ax mov ax,0 mov es,ax push es:[9*4] pop ds:[0] push es:[9*4+2] pop ds:[2] mov word ptr es:[9*4],offset int 9 mov es:[9*4+2],cs 上面的代码主要就是设置了中断向量表。可以看到讲原来的int 9h中断例程地址保存在ds:0,ds:2地址处，换上新的例程地址cs:(offset int 9)。新的例程代码:12345678910111213141516171819202122int9: push ax push bx push es in al,60h pushf call dword ptr ds:[0] ;这里的实际上模拟了int 9中断例程的功能，实现子程序中的调用 cmp al,1 jne int9ret ;下面是Esc例程代码 mov ax,0b800h mov es,ax inc byte ptr es:[160*12+40*2+1] ;改变属性值，改变颜色int9ret:pop es pop bx pop ax iret 其中cmp al,1和jne int9ret就相当于if_else的功能。在主程序中有了栈，栈在中断例程中的主要作用就是保护现场，分析一下: 需要保护最开始的int 9h的中断向量号 因为在显示字符的主程序中，ax,es,bx都保存了重要的中间参数，所以需要保护除此之外,栈并没有起到什么作用。这样看下来其实源程序也简单了不少。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch4]]></title>
    <url>%2F2018%2F10%2F12%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch4%2F</url>
    <content type="text"><![CDATA[第四部分:中断IAbstract 在之前的实验中，我们所编写的汇编程序从编译到运行出结果都很顺利。这个过程映射到CPU层面就是CS:IP的跳转唯一取决于汇编程序员的代码。CSAPP将这个过程称为程序控制流。而中断则是将这种流程打断，建立更复杂的异常控制流。中断分为内中断和外中断两种。 内中断中断产生 8086CPU使用中断类型码来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源————具体指的是产生中断信息的事件，简称中断源。下面是8086中4种常见的中断源及其中断类型码: 除法错误: 0 单步执行: 1 执行into指令: 4 执行int n指令: n 中断过程 CPU获得中断类型码之后，需要跳转到该中断类型码对应的中断处理程序中进行处理。如何跳转呢？使用中断向量表。而跳转通常意味着改变CPU的状态，所以需要使用栈来保存现场。所以识别，保存和跳转就是中断过程主要干的事儿————其中识别由硬件完成！中断向量表保存在内存0000:0000到0000:03FF的这1KB单元里。一个表项存放一个中断向量————也就是中断处理程序的地址入口。占4个字节，高地址放段地址，低地址放偏移地址。 识别 下图是一张8086的内存分布图:从内存0开始，所以存储N号中断源对应的中断向量的偏移地址的内存地址为:0000:4N，存储N号中断源对应的中断向量的段地址的内存地址为:0000：4N+2。看下图: 跳转和保存 获得中断类型码 标志寄存器的值入栈: pushf 设置标志寄存器第8位TF和第9位IF的值位0: TF=0,IF=0 CS的内容入栈: push CS IP的内容入栈: push IP 通过中断类型码获取入口地址: (IP)=(N*4),(CS)=(N*4+2) 最后一步执行结束后，CPU开始执行由程序员编写的中断处理程序 中断处理 所谓中断处理程序就是操作系统对各种中断的反应。 由于CPU随时可能检测到中断，所以中断处理程序必须一直存储在内存某段空间中。下面的实验就是通过来实现内中断处理程序。 0号中断 即除法溢出错误。 123mov ax, 1000hmov bh,1div bh 该除法指令在执行的过程中会发生溢出错误，导致产生0号中断从而引发中断过程。 实验 编写0号中断的处理程序 中断类型码:0 中断处理程序: 选择0000：0200到0000：02ff这256个Bytes内存的区域来存放 中断向量表: 0号中断的段地址0000:0002偏移地址0000:0000安装处理程序do0 得确保中断处理程序不会变动，所以选择一块合适的内存区域将其安装进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 assume cs:code code segment start: mov ax,cs mov ds,ax mov si,offset do0 ;设置ds:si指向被拷贝的程序地址 mov ax,0 mov es,ax ;设置es:di指向拷贝的目的地址 mov di,200h mov cx,offset do0end-offset do0 ;设置需要拷贝的代码长度度 cld ;设置传输方向为正 rep movsb /* 设置中断向量表 */ mov ax, 4c00h int 21h do0: jmp short do0start db &quot;overflow!&quot; do0start: mov ax,cs mov ds,ax mov si,200h ;设置ds:si指向字符串 mov ax,0b800h mov es,ax mov di,12*160+36*2 ;设置es:di指向显存空间的中间位置 mov cx,9 ;字符串的长度 s: mov al,[si] mov es:[di],al inc si add di,2 loop s mov ax,4c00h int 21h do0end: nop code ends end start 设置中断向量号 当中断发生的时候，确保0号中断的处理程序跳转地址是上一个设置好的地址。 1234mov ax,0mov es,axmov word ptr es:[0*4],200hmov word ptr es:[0*4+2], 0 验证 注意，在跳转到中断处理程序之前，所有的CPU现场已经入栈保存好了，而跳转过程本身也是硬件过程，所以我们所做的仅仅只是设置好跳转的地址和该地址相应的处理代码。经过实验发现DOSBox的和传统的DOS还是有一些区别的，这里用一个小实验验证中断:首先我们直接在debug下面将0号中断向量号改写成为0000:0200处，然后在另一块内存0200:0000中写进了会引发0号中断的代码:然后修改好了CS:IP地址并开始执行: 现象 单步执行,可以看到CS:IP的值在执行到div bh的时候，立马从0200:0005变成了0000:0002!,我写的中断处理mov cx,ffff也被执行！然后一直执行到结束退出。实验的整个过程实际上就是做了一个跳转，然后我们仔细对比一下跳转前后寄存器值的差距:会发现除了CS:IP有变化之外，SS:SP大小也有变化，这是CPU保存现场的缘故————从00F7到00FD共3个字对应CS，IP和TF；而且状态寄存器EI也变为DI,估计也和TF和IF相关;因为我们的中断处理直接退出程序所以栈中的数据没有派上用场，不过如果需要返回源程序做一些操作的时候栈就会起到恢复的作用。我还尝试过在中断产生的时候查看栈中的内容，但是每次指令刚执行就被强制退出……不知道为什么。不过这是下一个实验的内容了。另外，这里可以回过头看一下ch2中关于栈的那个猜测，基本上没有毛病。 1号中断 在CPU保存现场的时候，对状态寄存器压栈，并且将其中两个状态位设置为零:TF=0;IF=0;主要是因为当CPU每执行完一条指令的时候，就会去查看状态寄存器的TF位是否为1，如果是则引发1号中断————单步中断。整个中断的过程和其他的没有什么区别，作者提到debug -t的单步执行功能，实际上就是通过debug调用1号中断对CPU进行控制。这里的控制主要体现在中断处理程序上————比如debug -t就是设置寄存器的值显示在屏幕上。那为什么要在处理之前又将TF设置为零呢？注意前面的每执行完一条指令的意思，CPU在执行中断处理程序的时候是不能响应其他中断的，TF=0是防止在过程中递归的陷入。 但是在有些特殊情况下中断的产生，CPU不见得马上处理。比如mov ss, ax和MOV sp, 10这两条设置堆栈的指令，在前面的实验中出现过。 int 指令中断例程 int n是一种很重要的内中断。n是中断类型码，该条指令功能就是可以引发中断过程。执行如下: 取终端类型码n 标志寄存器入栈，IF=0,TF=0 push cs,push ip (IP)=(n4),(CS)=(n4+2)注意一下这里的压栈顺序，后面的实验中会有用到。一般情况下，系统会将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用，通常就是使用int指令。将这些自己编写的中断处理程序叫做中断例程。 编写loop中断例程 在屏幕中间显示80个“！”。这个程序一看就知道需要使用到loop指令，但是该指令到底是如何实现的呢？我们知道跳转指令实际上就是改变CS:IP的值，而给定次数的跳转和给定目标的跳转合在一起就会比较麻烦。跳转指令是靠两个标号之间的相对位移而不是靠标号的地址这一点很重要。我们用cx存放循环次数，用bx存放相对位移。先看一下例程代码: 123456789101112131415161718192021assume cs:codecode segment start:mov ax,0b800h mov es,ax mov di,160*12 mov bx,offset s-offset se mov cx,80s: mov byte ptr es:[di],&apos;!&apos; add di,2 /* int 7ch例程代码:如果（cx）!=0,跳转到标号s处 */se: nop mov ax,4c00 int 21h code endsend start 至此，应该已经完全可以看懂这些汇编程序。可是核心的功能呢？如下:跳转到标号s处需要知道s的段地址和偏移地址。先来分析一下在执行int 7ch之后发生了什么？画得不好凑活着看吧:) x86中的栈是一个满堆栈。首先标志寄存器入栈，然后对se标号的CS:IP压栈。因为代码只有一个段，所以se的段地址和s的段地址一样。而bx中存储了s-se，所以对于s来说:bx+se就是它自己的偏移量。而se的偏移量就是栈中的IP。所以思路顺下来了。可以写代码了。 1234567lp: push bp mov bp,sp dec cx ;cx-- jcxz lpret ;if(cx=0) (cs:ip)=lpret add [bp+2],bx ;重点lpret: pop bp iret 上述代码中add [bp+2],bx就是前面刚顺下来的算法实现。将栈中的IP修改称为s的偏移地址。这里的重点是iret指令，这个指令和跳转指令经常组合在一起共同使用，相当于pop ip,pop cs,popf这三条指令的和。上述代码就是在栈中修改好CS:IP的值，然后使用iret出栈执行。 结果 本次实验的过程实际上就是分为两部分:安装例程和执行例程。 安装例程 对于7ch中断类型码来说，对应的中断例程地址应该在0000:01f0。我们首先将中断例程写进该地址，然后修改中断向量表项。 1234567891011121314151617181920212223242526272829303132333435363738assume cs:code code segmentstart: mov ax,cs mov ds,ax mov si,offset do0 mov ax,0 mov es,ax mov di,200h mov cx,offset do0end-offset do0 ;将中断例程写进对应的地址中 cld rep movsb mov ax,0 ;这4行代码修改中断向量表 mov es,ax mov word ptr es:[7ch*4],200h mov word ptr es:[7ch*4+2],0 mov ax,4c00h int 21hdo0: ;这是中断例程 push bp mov bp,sp dec cx jcxz lpret add [bp+2],bxlpret: pop bp iret do0end: nop code endsend start 我们将上述代码保存为sample.asm然后编译连接。然后执行sample.exe:上图分别是地址0000:0200处的中断例程，和0000:01f0处的中断向量表。可以看到成功写入内存。 执行例程 执行程序就是调用int 7ch这个例程看是否有效。我们将执行程序保存为demo.asm编译连接。 12345678910111213141516171819assume cs:codecode segmentstart: mov ax,0b800h mov es,ax mov di,160*12 ;确定显存的地址 mov bx,offset s-offset se mov cx,80s: mov byte ptr es:[di],&apos;!&apos; add di,2 int 7ch ;在这里int指令充当了loop的功能se: nop mov ax,4c00h int 21h code endsend start 然后执行demo.exe,看现象: 总结 这是最简单的一个例程，不过我们可以因此得知跳转指令和栈的重要性! BIOS和DOS所提供的中断例程 关于BIOS和DOS已经很熟悉了，从计算机加电开始，CS:IP会自动跳转到ffff:0000的地址执行程序，到底执行的是啥？有两大部分:自检程序和初始化程序。初始化程序将建立BIOS所支持的中断向量。BIOS中的中断例程主要有: 外部中断和内部中断的中断例程 用于对硬件设备进行I/O操作的中断例程 其他和硬件系统相关的中断例程 自检和初始化完成之后，调用int 19h进行操作系统的引导。而DOS也有自己的中断例程，这些中断例程是操作系统提供给程序员的资源。另外，DOS和硬件设备相关的中断例程一般都是调用了BIOS的中断例程。每一个中断例程都是由很多的子程序构成的。不管是BIOS还是DOS的中断例程都通过ah来传递内部子程序的编号。 BIOS中断例程 int 10h用来设置和字符和光标。见代码: 看现象: 下面是代码: 1234567891011121314151617181920assume cs:codecode segment mov ah,2 ;置光标 mov bh,0 ;第0页 mov dh,5 ;行号 mov dl,12 ;列号 int 10h mov ah,9 ;在光标位置显示字符 mov al, &apos;a&apos; ;字符 mov bl,11001010b ;颜色属性 mov bh,0 ;第0页 mov cx,5 ;字符重复个数 int 10h mov ax,4c00h int 21h code ends end DOS中断例程 DOS中断int 21h，之前一直使用4ch00参数即程序返回功能。参数ah=9表示调用第21h号中断例程的9号子程序:在光标位置上显示字符串.看现象:下面是代码: 1234567891011121314151617181920212223assume cs:codedata segment db &apos;Dos is shit!&apos;,&apos;$&apos; data endscode segmentstart: mov ah,2 mov bh,0 mov dl,12 int 10h ;BIOS 中断例程 mov ax,data mov ds,ax mov dx,0 mov ah,9 int 21h ;DOS中断例程 mov ax,4c00h int 21hcode endsend start]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch3]]></title>
    <url>%2F2018%2F10%2F11%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch3%2F</url>
    <content type="text"><![CDATA[第三部分:指令核心Abstract内存寻址 内存是啥？计算机从诞生之初，就面临着CPU和I/O之间，与存储器之间越来越明显的速度矛盾。正是因此才诞生了内存，cache等一系列缓冲的加速设备。你可以理解为内存是CPU获取运行代码的唯一途径，注意这里的内存指的是内存地址空间。CPU如何访问内存？当然是使用寄存器;那寄存器如何访问内存？这就涉及到内存寻址的知识。寻址的方式有很多种类 ，不过归结到底都是段地址+偏移地址。段地址存储在段寄存器中，而偏移地址的方式就有很多种。见下图: 需要注意的是: 上图中的idata表示立即数，[]表示偏移地址。(ax)表示寄存器ax的内容。 []中的除了立即数之外，只有bx,si,di和bp四个寄存器可以进行寻址，其他的寄存器不行。 [bp]的段寄存器默认是ss。 编译器masm和调试器debug两个工具对于mov ax,[idata]中的idata处理不同，编译器会将其识别为idata,所以在使用编译器的时候这种形式应该写成mov ax,ds:[idata] 数据处理(总结性质) 计算机处理的最终还是数据，那么就有两个最基本的问题: 处理的数据在什么地方？ 要处理的数据有多长？ 问题一 绝大部分机器指令都是进行数据处理的指令，处理大致分为三类:读取，写入，运算。在机器指令这一层来说并不关心数据的值，而关心指令执行前一秒，将要处理的数据所在的位置。指令在执行之前，所要处理的数据可以在三个地方:CPU内部，寄存器，端口。 问题二 8086指令可以处理两种尺寸的数据:Byte和Word。所以在机器指令中需要指明是字操作和字节操作。 通过寄存器指明:ax，al等 用操作符X ptr指明内存单元的长度，X是word或者byte。比如:mov byte ptr ds:[0],1。 还有一些默认的操作比如栈操作默认为字操作。 指令详解伪指令补充 db 定义字节型数据 dw 定义字型数据 dd 定义双字节型数据 dup 和前面三个伪指令结合使用，用来进行数据的重复。db 3 dup(1,2,3)表示定义的三个字节型数据分别为1,2,3。 LOOP循环指令 主要进行两步操作，（cx）=(cx)-1，判断cx中的值。不为零则转至标号处执行程序，如果为零则向下执行。可见cx中的值影响了loop指令的执行结果。 1234mov cx,循环次数s: 循环执行的程序段 loop s JMP转移指令 可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的的指令。根据修改的方式，只修改IP的称为段内转移，修改IP和CS的称为段间转移。由于转移指令对IP的修改范围不同，段内转移又分为:短转移（8位）和近转移（16位）。不同的转移方式，其基本的原理确实相同的。 1-JMP short offset 转移指令值得注意的点就是offset指的不是确定的地址，而是从标号到指令之间的位移。(IP)=(IP)+8位位移，段内短转移的位移范围位8位有符号数，用补码表示。offset处的地址-JMP指令后的第一个字节的地址。 1-JMP near ptr offset (IP)=(IP)+16位位移 ,段内近转移的位移范围是16位有符号数，用补码表示。原理和前者一样。 2-JMP far ptr offset 前面的几种类型地址都是通过offset和位移，而接下来的几种是在寄存器和内存中的给定IP或者CS。内存地址单元可以用任意的寻址方式得到。（CS）=标号所在段的段地址，（IP）=标号所在段中的偏移地址 。段间转移，会发现其跳转地址实际上是在指令中的offset的地址。和前两个还是有区别的。 2-JMP 16位reg 最基础的跳转指令，只是修改IP=16位的寄存器中内容。 2-JMP word ptr 内存单元地址 比如:jmp word ptr ds:[0]中ptr后面的就是一个地址，jmp word ds:[0],0后面跟两个地址。注意（CS）=(内存地址单元+2)，（IP）=（内存地址单元）。 2-jcxz 该指令为有条件转移指令，所有的有条件转移指令都是短转移。方式为:if((cx)==0)jmp short offset另外，所有的loop循环指令都是短转移。 CALL和RET指令ret(近转移) 书中说ret指令用栈中的数据修改IP中的内容。之前对栈有一个分类，这里的栈是满递减堆栈。所以由此可知堆栈指针SP一直指向最后一个压栈的数据。ret指令实际上把堆栈中的最后一个数据作为自己跳转的偏移地址。方式如下:(IP)=((ss)*16+(sp)),(sp)=(sp)+2从上面也可以看出来这两条指令等同于:pop IP retf(远转移) 书中说retf指令用栈中的数据修改IP和CS中的内容。类似:(IP)=((ss)*16+(sp)),(sp)=(sp)+2（CS）=（（ss）*16+(sp)）,(sp)=(sp)+2这四条指令等同于:pop IP,pop CS call指令 call指令不能实现短转移，但是其转移的原理和jmp指令相同。如下：(sp)=(sp)-2,((ss)*16+(sp))=(IP),(IP)=(IP)+16位位移这几条指令相当于:push IP和jmp near ptr offset call和ret指令(子程序) 先看一段代码: 12345678910111213assume cs:codecode segmentstart: mov ax,1 mov cx,3 call s mov bx,ax mov ax,4c00h int 21h s: add ax,ax loop s retcode endsend start 程序执行到call s的时候，IP指向了后面的一条指令，然后CPU执行call s指令————将当前的IP（mov bx,ax的地址）压栈，然后修改为s地址。然后子程序开始执行，执行结束之后执行ret指令————从栈中弹出一个值，将CS:IP的值指向mov bx,ax。然后返回为原来的地址。这两条指令为子程序的调用提供了可能。 标志寄存器 寄存器是汇编程序员解决问题的最有利的手段，不仅仅在于可以存储数据，还具有辅助指令执行的功能。标志寄存器就是如此，用来存储CPU执行指令的某些执行结果。存储的信息称为“程序状态字PSW”。状态寄存器的每一位都有具体的含义。下面分别介绍: ZF标志 零标志位，相关指令执行结束如果结果为0，zf=1；如果不为0，zf=0. PF标志 奇偶标志位，相关指令执行结束如果结果的所有bit位中1的个数为偶数，pf=1,否则pf=0. SF标志 符号标志位，相关指令执行结束如果结果为负，sf=1；否则sf=0。该标志是CPU对有符号数计算结果的一种记录。 CF标志 进位标志位，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。 OF标志 溢出标志位，在进行有符号数运算的时候，记录了是否发生溢出。 标志寄存器在Debug中的使用 标志寄存器是按照有意义的各个标志位单独表示的。如下。下图是已知的标志位的表示: 其他指令（总结性质） 还有很多的指令比如MOV,CMP，abc等。但这里并不打算详细讲解每一条指令，就像书中所说:汇编语言只是载体，目的在于理解机器运行的原理和方式。至此，我们已经学习了寄存器，内存,汇编指令，并且掌握了一个正常的程序控制流在机器层面的运行过程。接下来的内容，就属于操作系统的层面，引入异常控制流，也就是在正常的执行过程中有外界干扰的情况，这是理解整个OS的重点，也是我写这几篇技术博客的主要学习目的。(mit6.828中的汇编大同小异，只是指令集换成了AT&amp;T的格式)。 实验7 寻址方式在结构化数据访问中的应用实验9 根据材料编程实验10 编写子程序]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch2]]></title>
    <url>%2F2018%2F10%2F04%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch2%2F</url>
    <content type="text"><![CDATA[第二部分:汇编结构Abstract汇编语言的结构寄存器和内存之间 汇编语言是由不同的段构成的，这些段的功能各异不过主要分为指令和数据两部分。运行汇编代码的意思就是将汇编代码加载到内存中，通过寄存器完成内存和CPU之间的交互。从这个角度看寄存器就是汇编的一种手段。但是寄存器和内存实际上是两个完全不一样的硬件设备，暂时先不考虑性能和速率差的问题。指令和数据到底是如何在不同的存储单元之间传递的。字节存储和字存储就是两种解决办法，在8086中寄存器是16位的(16位为一字)，而存储器的最小存储单元是8位也就是一个字节，所以如果在一些读写中需要用到字存储而不是字节存储的话，就需要两块连续的内存单元才能完成数据的传输，而且是高地址存放字的高位字节，低地址存放字的低位字节。要读写一块内存单元的时候，必须先要给出这个内存单元的地址。在实验1中我们知道了CPU使用段地址+偏移地址的方式来进行寻址。而实现这些功能的就是一些具有特殊功能的寄存器。这里提到的是最简单的也最常使用的两种类型: CS+IP————在任意时刻CPU将CS:IP指向的内容当做指令执行。 DS+[idata]————DS通常用来存放需要访问的数据的段地址。这里主要介绍汇编语言的结构，对应到寄存器和内存寻址的方式后面会讲。 数据段 将一段内存当做数据段，是我们在编程的时候的一种安排，可以在具体操作的时候，用ds存放数据的段地址，再根据相关指令访问数据段中的具体单元。 代码段 从硬件角度讲，CPU只认被CS:IP指向的内存单元中的内容为指令。要让CPU执行我们放在代码段的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。 栈段 栈是一种先进后出的数据结构，这是最基本的栈的概念。这里讲到的栈指的是内存区域。从操作系统的角度讲一个线程需要分配一个栈(stack)。相对应的一个进程需要分配一个堆(heap)。栈的大小在分配的时候就已经确定好了，其作用主要是存放一些局部和确定的变量和数据。 关于栈也有两个寄存器:SS:SP。换句话讲CPU如何知道一段内存区域是不是栈？栈顶的段地址放在SS中，而偏移地址放在SP中。任意时刻，SS:SP指向栈顶元素。这是规定。 另外，上微机原理课的时候，老师讲到栈的分类: 向高地址生长的称为递增堆栈。 向地地址生长的称为递减堆栈。 地址延伸主要的影响就是内存中的大端寻址和小端寻址。 堆栈指针指向最后压入堆栈的有效数据项，叫做满堆栈。 堆栈指针指向下一个待压入数据的空位置，叫做空堆栈。 栈指令 在i386的指令集中，栈操作都是以字为单位的。 push执行过程1. SP=SP-2; 2. 向`SP:SS`指向的内存字单元中送入数据; pop执行过程1. 从`SP:SS`指向的内存字单元中读取数据; 2. SP=SP+2; 段的概念 之前讨论过关于段这个概念。我认为，还是因为在编程的时候可以通过一个系统化的结构来统一汇编语言的实现逻辑。使得这些指令看上去便于管理和协调合作。至于其物理实现，其实就是CPU的寻址方式决定的。书本中有一段话特别经典，我摘抄如下: 123456789101112131415161718192021222324比如我们将10000H~1001F安排为代码段，并在里面存储如下代码: MOV ax,1000H MOV ss,axMOV sp,0020H //初始化栈顶MOV ax,csMOV ds,ax //设置数据段段地址MOV ax,[0]add ax,[2]add bx,[4]add bx,[6]push axpush bxpop axpop bx 设置CS=1000，IP=0.这段代码就会被执行，但是可以看到在这段代码中，我们又将 10000H~1001FH安排为栈段和数据段。 可见不管我们如何安排，CPU将内存中的某段内存当做代码，是因CS:IP指向了那里。 CPU将某段内存当做栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排， 以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们 的安排运行的时候做到游刃有余。 一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么都不是。 关键是在于CPU中寄存器的设置，机CS，IP，SS，SP，DS的指向。 多个段的统一 以前写的汇编都是单个段，并且主要是代码段。如果内存中的一段汇编代码需要包含多个数据段，代码段，栈段。该如何设计才能保证程序正常运行呢？我们应该有一个概念，就是所谓和CPU对应的程序一定是CS:IP指向的内存地址。所以实际上这个问题是在问保证CS:IP正确指向程序的前提下，如何让数据段，栈段合理的加进来？这里有个伪指令的概念，伪指令主要是为汇编器提供一些编译的前提信息比如从哪里开始执行代码，其他的段的起始地址在哪里。所以问题也就解决了。 如何保证CS:IP指向代码段: end和end start 如何定义一个段: code segment和code ends 如何将段寄存器和段相对应: assume cs:code 汇编语言的编译、连接过程及其工具的使用 这部分详细见书上。 源程序组成 一个汇编程序的源程序由汇编指令和伪指令构成。汇编指令指的是编译成为机器指令最终为CPU所执行的代码。伪指令没有相对应的机器指令，主要是由编译器来执行的指令。 编译、链接、执行 源程序经过编译成为可重定位文件，然后经过链接成为可执行文件。可执行文件是可以直接在操作系统中执行的。上述两种文件都属于ELF格式的文件，ELF是Linux下面的一种文件格式，具体的细节在后面的操作系统中会谈到，这里只是了解。 编程（edit）————&gt;1.asm————&gt;编译(masm)————&gt;1.obj————&gt;链接(link)————&gt;1.exe————&gt;加载(shell)————&gt;内存中的程序————&gt;运行(CPU) 工具进阶debug -d 第一个实验中使用的debug工具，通过各种参数来对寄存器和内存进行读写。比如d 段地址:偏移地址指令会列出指定内存单元中的内容。但是debug也是一个程序，而能定位内存地址的方式在8086中只有段寄存器可以做到,实际上debug就是通过将地址写入段寄存器中的方式来进行内存寻址。这个原理适用于所有的参数。而使用的这个段寄存器正是DS寄存器。根据这个原理，就可以通过修改寄存器来进阶使用这些命令，比如:-r ds,:1000,-d ds:0这段代码就表示查看从1000：0开始的内存空间中的内容。这里主要是认识到段寄存器DS的寻址功能，为之后的寻址方式打基础。 debug -p 在整个实验中，debug工具是经常要使用的。debug有两种用法，一种就是使用a参数直接写入程序然后调试。还有一种就是直接调试exe文件。第一种之前一直在用，第二种方式加载的过程有一些不一样，ds段寄存器中存放着该程序的段地址，因为偏移为零所以DS:0就是所加载程序的首地址。而加载进来的程序前256字节存放的是一段通信程序，所以真正的代码是在(DS+10H:0):0开始的。每一段汇编指令都需要以mov ax,4c00H，int 21H结尾。在调试到int 21H的时候需要使用P命令执行。出现Program terminated normally程序正常退出。 实验2 用机器指令和汇编指令编程 这个实验很有意思，一共有两部分: 第一部分 使用a将下面的汇编指令写入内存，然后使用T命令调试。如下: 1234567mov ax,2000mov ss,axmov sp,10mov ax,3123push axmov ax,3366push ax 会发现在单步调试的时候，在mov ss,ax之后的下一条指令竟然不是mov sp,10。但是查看寄存器的时候发现实际上这条执行已经被执行结束了。这是第一个现象。 第二部分 对上面的代码继续调试，如下：会发现最开始对栈初始化之后，到执行到mov ss,ax指令的时候，查看原来的栈段内容竟然不再是零，且这些数字还都是和段寄存器相关的。 总结 下图是接下来的每一步后栈段中的内存变化。可以看到的现象是:开始的时候栈中是没有数据的，栈桢SP指向2000:0010的位置。在mov ss,ax和mov sp,10这两步执行结束之后，发现栈中已经有数据了，这里称为初始化。初始化的一共有6字节的数据:4个字节为CS:IP，还有两字节在栈底确定为01A3H。之后的每一条栈操作的指令执行结束之后栈中的CS:IP值也会跟着变化，这说明每一次指令都有可能产生一次中断。但是在栈底的01A3H一直没有变化估计应该是中断相关。在正式压栈操作的过程中发现最开始初始化过的那些数据并没有被压到栈底，这就意味着堆栈指针SP应该还在栈底，然后真正有数据项压栈的时候才会SP-=2操作。 小实验 就上面的三个现象，我在想仅仅是初始化的过程就已经占据了一大半栈空间，那如果将栈大小调整成为8字节的。那会出现什么情况？ 我将mov sp,10改成mov sp,08；然后准备了8字节数据，所以栈会被压满。这时候我想看看现象。这是一张初始化的图: 这是末尾压栈满了的图: 因为书上关于中断的详细讲解在第四部分，所以这里只是一个猜测。现象中随着栈不断被压满，之前初始化的那些数据都被挤出去了，具体去哪了不知道。那6个字节的数据到底有什么用也不知道。 猜测 不过可以知道的是初始化栈帧的时候会有参数压到栈里，参数有CS:IP和中断向量号，其中CS:IP还在不断变化。而随着栈中的数据越来越多，栈中的这6个字节的参数被慢慢挤出。难道这6个字节不重要吗，或者说只是在初始化的时候用了一下？但是过程中这些参数一直也在变化，所以不可能不重要.不过这些数据之所以放到栈中的原因一定不是为了存储，否则就不会被随便挤出。结合第一部分实验，mov sp,10是紧跟着前一条指令执行的，所以我能想到的唯一一个合理的解释就是:这些参数是在指令执行过程中直接使用的，而执行过程对shell屏蔽不可见，所以在栈中数据越来越多的时候这些参数还可以随意的移动位置并且被抛弃，这些参数是过程中使用的参数，而这个过程就是中断！至于中断到底是什么，到第4章再详细学习吧。 实验3 用编程、编译、连接、跟踪 最后一个实验查看PSP（就是加载开始前256字节）的内容。使用u来查看汇编好像又和中断有关系。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch1]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch1%2F</url>
    <content type="text"><![CDATA[第一部分:硬件模型Abstract硬件基础 全书的核心在使用汇编语言进行编程，老师在第一章就抽象出了完整的编程模型供汇编程序员参考————冯诺依曼结构。 CPU只是一个运算单元，只有提供了数据和指令才可以正常运行，而数据和指令存储在内存中。那CPU和内存如何进行交互？ 存储单元的地址（地址） 读/写操作（控制） 读/写的具体数据（数据） 答案是总线，地址总线决定了CPU的寻址能力；数据总线决定了CPU一次能够处理多少数据；控制总线决定了CPU对外部器件的控制能力。这里的外部器件指的是除内存外的其他存储单元比如VGA等。所以在模型内部实际上还有一层抽象————那就是由系统中所有的存储单元组成的统一的逻辑存储器。实际上CPU面向的就是这个逻辑存储器，书中叫它内存地址空间。 以上就是整个书中抽象出来最简单的编程模型，王爽老师在一开始就定下这本书的基调————不是讲CPU和外设的物理结构《微机原理和接口》，也不是讲整个计算机系统的结构和功能《组成原理》。学习汇编语言是利用固有的硬件体系和特有的指令集进行编程从而对硬件系统进行控制。 固有的硬件体系指的是这套CPU+RAM的计算机模型是图灵，冯诺依曼这些先驱们总结出来的一套最适合的结构。而特有的指令集则是说不同的CPU有不同的汇编语言，用x86的汇编语言的原因主要是因为这套指令集只有14个寄存器和1MB(20位地址总线)寻址空间，比较容易掌握。 指令和数据 学习组成的时候就对这两个概念很模糊，但是做实验的过程中其实发现：其实CPU看到的东西就是一堆01而已，真正将这堆01赋予意义的还是我们。换句话说就是数据和指令只是一个应用上的概念，你将它放到PC中它就是地址，而将它放到另外一个寄存器中它可能就直接被用来运算了。从原理上看，主要是不同的寄存器对这些数据赋予了不同的功能。CPU的工作用一句话来概括就是从特定的寄存器中取出data1作为地址，然后把内存中这个地址相对应的data2作为指令进行计算。但是如果我把data1和data2互换一下，其实也是可以的。但是需要考虑到的是data2所代表的地址是不是在内存地址空间的范围之内，我的理解是寄存器，总线，内存中存储数据的位数有可能都是不一样的。但是说到底它们只是来存储数据的，写错最坏的情况也就是CPU跑崩了。 寄存器 8086CPU有14个寄存器，都是16位的。但是这16位的寄存器也可以独立作为两个8位的寄存器使用。 寄存器和内存是汇编程序猿眼中最直观的计算机样子。 汇编层面的CPU 运算器进行信息处理 寄存器进行信息存储 控制器控制各种器件进行工作 内部总线连接各种器件，在它们之间进行数据的传送 8086架构（16位机）具体深究到物理实现就是《组成原理》知识了。 运算器一次最多可以处理16位数据 寄存器的最大宽度为16位 寄存器和运算器之间的通路为16位 汇编层面的内存 CPU在访问内存单元的时候，需要知道内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存空间在这个空间上都有唯一的地址，这个惟一的地址就叫做物理地址。CPU首先在内部形成这个物理地址，然后通过地址总线送入存储器。这个地址一定是一个内存单元的物理地址。不同的CPU架构形成地址的方式不一样。 CS:IP 前面提到了8086CPU内部需要形成物理地址，但是8086是16位机————只能处理和传输16位的地址，但是8086的地址总线有20位，所以需要两个16位来共同形成一个20位的地址。 14个寄存器中，CS是段寄存器，存放基地址。而IP存放偏移量。公式:CSx16+IP。 首先需要明白的就是，一个内存单元是8位二进制也叫一个字节。而十六进制的一位可以表示成为二进制的4位。完全只是为了方便才写成16进制的。20位的地址（5位16进制）可以写成4C780H，后面的H表示16进制。一个X进制的数据左移一位，相当于乘以X。所以为了记起来方便一些可以记成CS寄存器的数据左移一位+IP寄存器的值。但是两个寄存器只有16位（4位16进制)，到后面计算的时候需要注意这两个前提，避免溢出。 书中特别强调了对段的理解。这里的段并不是指内存被物理上分成一段一段的。而是因为CPU在管理内存的时候，使用CSx16+IP的方式来进行管理。所以可以将地址连续，起始地址为16的倍数的一组内存单元看成是一个段。重点在于不是所有的起始地址都可以作为段地址————这是因为CSx16决定的。而且因为IP是16位的所以每一个段的长度最大为64KB。 执行过程 在8086机中，任意时刻CPU将CS:IP指向的内容当做指令执行。汇编中使用jmp 段地址:偏移地址对CS:IP进行修改。或者使用jmp 寄存器来修改IP的值。 8086的工作过程 从CS:IP指向的内存单元中读取指令，读取的指令进入指令缓存器。 IP指向下一条指令。 执行指令,从CS:IP中取指令，重复上面的过程。 书中划线 汇编语言和机器语言的差别在于指令的表示方法上。 微机存储器的容量是以字节为最小单位的来计算的。 在内存和磁盘上，数据和指令没有任何区别。 在汇编语言这门课中，我们所面对的是内存地址空间。CPU向这段地址中读写数据实际上就是向相应的物理存储器中读写数据。 内存地址空间的大小受到CPU地址总线宽度的限制。 实验1 查看CPU和内存，用机器指令和汇编指令编程工具介绍 debug是DOS,Windows都提供的实模式（8086方式）程序的调试工具。下面是本次实验将会用到的参数: r (读写寄存器) r查看所有的寄存器的值 r 寄存器名称修改制定寄存器的值 d （读写内存） d 段地址:偏移地址 列出从指定内存单元开始的128个内存单元的内容 d 段地址:起始偏移地址 结尾偏移地址列出在偏移地址范围之内的内存单元的内容 e （读写内存） e 段地址:偏移地址 data1 data2 data3……从特定单元开始讲数据写入内存 e 段地址:偏移地址 回车表示挨个儿修改内存，空格表示默认不修改，回车表示修改结束 e+u+t 使用e参数向内存中写入机器码 使用u 段地址:偏移地址可以将内存中机器码翻译成为汇编语言 t参数执行CS:IP指向的内存地址单元的任何指令，注意修改参数 a a 段地址:偏移地址可以直接使用汇编的格式写入机器指令 实验任务 一共有4个实验。写出来的都是我觉得很有意思且值得讨论的实验。 第二个实验 给出起始地址为2000:0000的三条指令，使用这三条指令计算2的8次方。 有意思的是这个算法，a += a；如果这里的a是2的话，实际上a+a等于ax2所以可以2的8次方可以通过8次这样的加法完成，但是如果a是其他的值就不行了。 最后两个实验 使用e参数对特定的内存单元进行读写。 这两个实验间接地证明了内存地址空间的存在。 我在向内存B810:0000中写数据的时候，发现显示器上会出现有颜色的字符和表情包，猜想这个地址应该是显存的物理地址。这也说明这里的内存不仅仅指的是主存储器，还有其他的和CPU直接相连的RAM。]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言（王爽）ch0]]></title>
    <url>%2F2018%2F10%2F02%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%EF%BC%88%E7%8E%8B%E7%88%BD%EF%BC%89ch0%2F</url>
    <content type="text"><![CDATA[Abstract 王爽老师的《汇编语言》是国内的经典教材。学习汇编是为了获得底层编程的体验和理解机器运行程序的机理。所以经典的做法往往不是只针对于某一种指令集，而是以一种指令集为手段来深入理解机器工作的原理，体会一个没有操作系统的编程开发环境。正如书中所讲:编程的平台是硬件而不是操作系统。或许这也是汇编语言真正的价值所在吧。 实验环境 全书的实验都是在8086CPU的体系结构下展开的，这也是Intel第一块16位的处理器。我们有两种办法在自己的计算机上模拟8086:一种是使用WindowsXP系统。一种是采用DOSBox模拟器，第二种比较方便。这里是链接。本书有17个实验，2个课程设计，5个研究试验。我主要是以其中一些实验为章节展开学习。 全书架构 在我看来，全书应该可以分为这么几个部分: 硬件模型Chapter.(1、2)————告诉你汇编编程就是程序员以指令为手段在CPU的寄存器和内存地址空间之间进行数据读写的的过程。 汇编结构Chapter.(3、4)————介绍了完整的汇编程序的组成部分:数据段，代码段、栈段。第4章介绍了汇编程序编译的全过程和基本工具的使用。 指令核心Chapter.(5~11)————从第5章作者开始引进一些新的指令，并且展开来讲汇编程序设计的核心部分。介绍了重点的指令比如操作指令,跳转指令，比较指令等及其用法等，并深入介绍了内存寻址的各种花式用法。 操作系统层面的应用Chapter.(12~17)和操作系统相关的概念比如中断等。 整个学习过程中，寄存器和内存地址空间的读写是贯穿全书的核心，因为所有的操作最终都是产生了对内存或者某一个寄存器的读写。而完成这一切读写功能的就是汇编指令。这也是机器硬件的真正工作原理。虽然这些部分都可以拆开来了解，但是实际上每一部分还有很多的细节和承上启下的概念，我也是站在我理解的角度对这些内容进行了划分，需要注意的是:全书还有很多的细节比如不同的存储单元和数据处理方式，这些都不是单独某一个章节可以完成的而是贯穿全书实验的前提。所以还是需要通读一遍全书来顺这些概念。 搭建实验条件 将下载好的环境包放在~/x86，作为我们的工作目录。 打开DOSBox模拟器。 挂载C盘:mount C ~/x86。 进入C盘:C:。 开始实验:debug。 退出程序quit，退出模拟器exit。 安装成功展示]]></content>
      <categories>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>i386</tag>
        <tag>Assembly</tag>
      </tags>
  </entry>
</search>
